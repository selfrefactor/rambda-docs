{
  "add": {
    "typing": "\nadd(a: number, b: number): number",
    "allTypings": "add(a: number, b: number): number;\nadd(a: number): (b: number) => number;",
    "categories": [
      "Number"
    ],
    "notes": "It doesn't work with strings, as the inputs are parsed to numbers before calculation.",
    "rambdaSource": "export function add(a, b){\n  if (arguments.length === 1) return _b => add(a, _b)\n\n  return Number(a) + Number(b)\n}",
    "rambdaSpecs": "import { add } from './add'\n\ntest('with number', () => {\n  expect(add(2, 3)).toEqual(5)\n  expect(add(7)(10)).toEqual(17)\n})\n\ntest('string is bad input', () => {\n  expect(add('foo', 'bar')).toBeNaN()\n})\n\ntest('ramda specs', () => {\n  expect(add('1', '2')).toEqual(3)\n  expect(add(1, '2')).toEqual(3)\n  expect(add(true, false)).toEqual(1)\n  expect(add(null, null)).toEqual(0)\n  expect(add(undefined, undefined)).toEqual(NaN)\n  expect(add(new Date(1), new Date(2))).toEqual(3)\n})",
    "explanation": "It adds `a` and `b`.",
    "example": "R.add(2, 3) // =>  5",
    "typescriptDefinitionTest": "import {add} from 'rambda'\n\ndescribe('R.add', () => {\n  it('happy', () => {\n    const result = add(4, 1)\n\n    result // $ExpectType number\n  })\n  it('curried', () => {\n    const result = add(4)(1)\n\n    result // $ExpectType number\n  })\n})"
  },
  "adjust": {
    "typing": "\nadjust<T>(index: number, replaceFn: (x: T) => T, list: T[]): T[]",
    "allTypings": "adjust<T>(index: number, replaceFn: (x: T) => T, list: T[]): T[];\nadjust<T>(index: number, replaceFn: (x: T) => T): (list: T[]) => T[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { curry } from './curry'\n\nfunction adjustFn(\n  index, replaceFn, list\n){\n  const actualIndex = index < 0 ? list.length + index : index\n  if (index >= list.length || actualIndex < 0) return list\n\n  const clone = list.slice()\n  clone[ actualIndex ] = replaceFn(clone[ actualIndex ])\n\n  return clone\n}\n\nexport const adjust = curry(adjustFn)",
    "rambdaSpecs": "import { add } from './add'\nimport { adjust } from './adjust'\nimport { pipe } from './pipe'\n\nconst list = [ 0, 1, 2 ]\nconst expected = [ 0, 11, 2 ]\n\ntest('happy', () => {})\n\ntest('happy', () => {\n  expect(adjust(\n    1, add(10), list\n  )).toEqual(expected)\n})\n\ntest('with curring type 1 1 1', () => {\n  expect(adjust(1)(add(10))(list)).toEqual(expected)\n})\n\ntest('with curring type 1 2', () => {\n  expect(adjust(1)(add(10), list)).toEqual(expected)\n})\n\ntest('with curring type 2 1', () => {\n  expect(adjust(1, add(10))(list)).toEqual(expected)\n})\n\ntest('with negative index', () => {\n  expect(adjust(\n    -2, add(10), list\n  )).toEqual(expected)\n})\n\ntest('when index is out of bounds', () => {\n  const list = [ 0, 1, 2, 3 ]\n  expect(adjust(\n    4, add(1), list\n  )).toEqual(list)\n  expect(adjust(\n    -5, add(1), list\n  )).toEqual(list)\n})",
    "explanation": "It replaces `index` in array `list` with the result of `replaceFn(list[i])`.",
    "example": "R.adjust(\n  0,\n  a => a + 1,\n  [0, 100]\n) // => [1, 100]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('adjust', function() {\n  it('accepts an array-like object', function() {\n    function args() {\n      return arguments;\n    }\n    eq(R.adjust(2, R.add(1), args(0, 1, 2, 3)), [0, 1, 3, 3]);\n  });\n});",
    "failedSpecsReasons": "Ramda method accepts an array-like object",
    "failedSpecsCount": 1
  },
  "all": {
    "typing": "\nall<T>(predicate: (x: T) => boolean, list: T[]): boolean",
    "allTypings": "all<T>(predicate: (x: T) => boolean, list: T[]): boolean;\nall<T>(predicate: (x: T) => boolean): (list: T[]) => boolean;",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function all(predicate, list){\n  if (arguments.length === 1) return _list => all(predicate, _list)\n\n  for (let i = 0; i < list.length; i++){\n    if (!predicate(list[ i ])) return false\n  }\n\n  return true\n}",
    "rambdaSpecs": "import { all } from './all'\n\nconst list = [ 0, 1, 2, 3, 4 ]\n\ntest('when true', () => {\n  const fn = x => x > -1\n\n  expect(all(fn)(list)).toBeTrue()\n})\n\ntest('when false', () => {\n  const fn = x => x > 2\n\n  expect(all(fn, list)).toBeFalse()\n})",
    "explanation": "It returns `true`, if all members of array `list` returns `true`, when applied as argument to `predicate` function.",
    "example": "const list = [ 0, 1, 2, 3, 4 ]\nconst predicate = x => x > -1\n\nconst result = R.all(predicate, list)\n// => true",
    "typescriptDefinitionTest": "import {all} from 'rambda'\n\ndescribe('all', () => {\n  it('happy', () => {\n    const result = all(\n      x => {\n        x // $ExpectType number\n        return x > 0\n      },\n      [1, 2, 3]\n    )\n    result // $ExpectType boolean\n  })\n  it('curried needs a type', () => {\n    const result = all<number>(x => {\n      x // $ExpectType number\n      return x > 0\n    })([1, 2, 3])\n    result // $ExpectType boolean\n  })\n})"
  },
  "allPass": {
    "typing": "\nallPass<T>(predicates: ((x: T) => boolean)[]): (input: T) => boolean",
    "allTypings": "allPass<T>(predicates: ((x: T) => boolean)[]): (input: T) => boolean;",
    "categories": [
      "Function"
    ],
    "rambdaSource": "export function allPass(predicates){\n  return input => {\n    let counter = 0\n    while (counter < predicates.length){\n      if (!predicates[ counter ](input)){\n        return false\n      }\n      counter++\n    }\n\n    return true\n  }\n}",
    "rambdaSpecs": "import { allPass } from './allPass'\n\ntest('happy', () => {\n  const rules = [ x => typeof x === 'number', x => x > 10, x => x * 7 < 100 ]\n\n  expect(allPass(rules)(11)).toBeTrue()\n\n  expect(allPass(rules)(undefined)).toBeFalse()\n})\n\ntest('when returns true', () => {\n  const conditionArr = [ val => val.a === 1, val => val.b === 2 ]\n\n  expect(allPass(conditionArr)({\n    a : 1,\n    b : 2,\n  })).toBeTrue()\n})\n\ntest('when returns false', () => {\n  const conditionArr = [ val => val.a === 1, val => val.b === 3 ]\n\n  expect(allPass(conditionArr)({\n    a : 1,\n    b : 2,\n  })).toBeFalse()\n})",
    "explanation": "It returns `true`, if all functions of `predicates` return `true`, when `input` is their argument.",
    "example": "const input = {\n  a : 1,\n  b : 2,\n}\nconst predicates = [\n  x => x.a === 1,\n  x => x.b === 2,\n]\nconst result = R.allPass(predicates)(input) // => true",
    "typescriptDefinitionTest": "import {allPass} from 'rambda'\n\ndescribe('allPass', () => {\n  it('happy', () => {\n    const x = allPass<number>([\n      y => {\n        y // $ExpectType number\n        return typeof y === 'number'\n      },\n      y => {\n        return y > 0\n      },\n    ])(11)\n\n    x // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('allPass', function() {\n  var odd = function(n) { return n % 2 !== 0; };\n  var lt20 = function(n) { return n < 20; };\n  var gt5 = function(n) { return n > 5; };\n  var plusEq = function(w, x, y, z) { return w + x === y + z; };\n  it('returns a curried function whose arity matches that of the highest-arity predicate', function() {\n    eq(R.allPass([odd, gt5, plusEq]).length, 4);\n    eq(R.allPass([odd, gt5, plusEq])(9, 9, 9, 9), true);\n    eq(R.allPass([odd, gt5, plusEq])(9)(9)(9)(9), true);\n  });\n});",
    "failedSpecsReasons": "Ramda method returns a curried function whose arity matches that of the highest-arity predicate",
    "failedSpecsCount": 1
  },
  "always": {
    "typing": "\nalways<T>(x: T): () => T",
    "allTypings": "always<T>(x: T): () => T;",
    "categories": [
      "Function"
    ],
    "rambdaSource": "export function always(x){\n  return () => x\n}",
    "rambdaSpecs": "import { always } from './always'\nimport { F } from './F'\n\ntest('happy', () => {\n  const fn = always(7)\n\n  expect(fn()).toEqual(7)\n  expect(fn()).toEqual(7)\n})\n\ntest('f', () => {\n  const fn = always(F())\n\n  expect(fn()).toBeFalse()\n  expect(fn()).toBeFalse()\n})",
    "explanation": "It returns function that always returns `x`.",
    "example": "const fn = R.always(7)\n\nconsole.log(fn())// => 7",
    "typescriptDefinitionTest": "import {always} from 'rambda'\n\ndescribe('R.always', () => {\n  it('happy', () => {\n    const fn = always('foo')\n    fn // $ExpectType () => string\n    const result = fn()\n    result // $ExpectType string\n  })\n})"
  },
  "and": {
    "typing": "\nand<T, U>(x: T, y: U): T | U",
    "allTypings": "and<T, U>(x: T, y: U): T | U;\nand<T>(x: T): <U>(y: U) => T | U;",
    "categories": [
      "Logic"
    ],
    "rambdaSource": "export function and(a, b){\n  if (arguments.length === 1) return _b => and(a, _b)\n\n  return a && b\n}",
    "rambdaSpecs": "import { and } from './and'\n\ntest('happy', () => {\n  expect(and(1, 'foo')).toBe('foo')\n  expect(and(true, true)).toBeTrue()\n  expect(and(true)(true)).toBeTrue()\n  expect(and(true, false)).toBeFalse()\n  expect(and(false, true)).toBeFalse()\n  expect(and(false, false)).toBeFalse()\n})",
    "explanation": "Logical AND",
    "example": "R.and(true, true); // => true\nR.and(false, true); // => false\nR.and(true, 'foo'); // => 'foo'",
    "typescriptDefinitionTest": "import {and} from 'rambda'\n\ndescribe('R.and', () => {\n  it('happy', () => {\n    const result = and(true, false)\n    result // $ExpectType boolean\n  })\n  it('curried', () => {\n    const result = and('foo')(1)\n    result // $ExpectType string | 1\n  })\n})"
  },
  "or": {
    "typing": "\nor<T, U>(a: T, b: U): T | U",
    "allTypings": "or<T, U>(a: T, b: U): T | U;\nor<T>(a: T): <U>(b: U) => T | U;",
    "categories": [
      "Logic"
    ],
    "rambdaSource": "export function or(a, b){\n  if (arguments.length === 1) return _b => or(a, _b)\n\n  return a || b\n}",
    "rambdaSpecs": "import { or } from './or'\n\ntest('happy', () => {\n  expect(or(0, 'foo')).toBe('foo')\n  expect(or(true, true)).toBeTrue()\n  expect(or(false)(true)).toBeTrue()\n  expect(or(false, false)).toBeFalse()\n})",
    "explanation": "Logical OR",
    "example": "R.or(false, true); // => true\nR.or(false, false); // => false\nR.or(false, 'foo'); // => 'foo'",
    "typescriptDefinitionTest": "import {or} from 'ramda'\n\ndescribe('R.or', () => {\n  it('happy', () => {\n    const result = or(true, false)\n    result // $ExpectType boolean\n  })\n  it('curried', () => {\n    const result = or(1)('foo')\n    result // $ExpectType number | \"foo\"\n  })\n})"
  },
  "any": {
    "typing": "\nany<T>(predicate: (x: T) => boolean, list: readonly T[]): boolean",
    "allTypings": "any<T>(predicate: (x: T) => boolean, list: readonly T[]): boolean;\nany<T>(predicate: (x: T) => boolean): (list: readonly T[]) => boolean;",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function any(predicate, list){\n  if (arguments.length === 1) return _list => any(predicate, _list)\n\n  let counter = 0\n  while (counter < list.length){\n    if (predicate(list[ counter ], counter)){\n      return true\n    }\n    counter++\n  }\n\n  return false\n}",
    "rambdaSpecs": "import { any } from './any'\n\nconst list = [ 1, 2, 3 ]\n\ntest('happy', () => {\n  expect(any(x => x < 0, list)).toBeFalse()\n})\n\ntest('with curry', () => {\n  expect(any(x => x > 2)(list)).toBeTrue()\n})",
    "explanation": "It returns `true`, if at least one member of `list` returns true, when passed to a `predicate` function.",
    "example": "const list = [1, 2, 3]\nconst predicate = x => x * x > 8\nR.any(fn, list)\n// => true",
    "typescriptDefinitionTest": "import {any} from 'rambda'\n\ndescribe('R.any', () => {\n  it('happy', () => {\n    const result = any(\n      x => {\n        x // $ExpectType number\n        return x > 2\n      },\n      [1, 2, 3]\n    )\n    result // $ExpectType boolean\n  })\n\n  it('when curried needs a type', () => {\n    const result = any<number>(x => {\n      x // $ExpectType number\n      return x > 2\n    })([1, 2, 3])\n    result // $ExpectType boolean\n  })\n})"
  },
  "anyPass": {
    "typing": "\nanyPass<T>(predicates: SafePred<T>[]): SafePred<T>",
    "allTypings": "anyPass<T>(predicates: SafePred<T>[]): SafePred<T>;",
    "categories": [
      "Function"
    ],
    "rambdaSource": "export function anyPass(predicates){\n  return input => {\n    let counter = 0\n    while (counter < predicates.length){\n      if (predicates[ counter ](input)){\n        return true\n      }\n      counter++\n    }\n\n    return false\n  }\n}",
    "rambdaSpecs": "import { anyPass } from './anyPass'\n\ntest('happy', () => {\n  const rules = [ x => typeof x === 'string', x => x > 10 ]\n  const predicate = anyPass(rules)\n  expect(predicate('foo')).toBeTrue()\n  expect(predicate(6)).toBeFalse()\n})\n\ntest('happy', () => {\n  const rules = [ x => typeof x === 'string', x => x > 10 ]\n\n  expect(anyPass(rules)(11)).toBeTrue()\n\n  expect(anyPass(rules)(undefined)).toBeFalse()\n})\n\nconst obj = {\n  a : 1,\n  b : 2,\n}\n\ntest('when returns true', () => {\n  const conditionArr = [ val => val.a === 1, val => val.a === 2 ]\n\n  expect(anyPass(conditionArr)(obj)).toBeTrue()\n})\n\ntest('when returns false + curry', () => {\n  const conditionArr = [ val => val.a === 2, val => val.b === 3 ]\n\n  expect(anyPass(conditionArr)(obj)).toBeFalse()\n})\n\ntest('happy', () => {\n  expect(anyPass([])(3)).toEqual(false)\n})",
    "explanation": "It accepts list of `predicates` and returns a function. This function with its `input` will return `true`, if any of `predicates` returns `true` for this `input`.",
    "example": "const isBig = x => x > 20\nconst isOdd = x => x % 2 === 1\nconst input = 11\n\nconst fn = R.anyPass(\n  [isBig, isOdd]\n)\n\nconst result = fn(input) \n// => true",
    "typescriptDefinitionTest": "import {anyPass} from 'rambda'\n\ndescribe('anyPass', () => {\n  it('happy', () => {\n    const x = anyPass<number>([\n      y => {\n        y // $ExpectType number\n        return typeof y === 'number'\n      },\n      y => {\n        return y > 0\n      },\n    ])(11)\n\n    x // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('anyPass', function() {\n  var odd = function(n) { return n % 2 !== 0; };\n  var gt20 = function(n) { return n > 20; };\n  var lt5 = function(n) { return n < 5; };\n  var plusEq = function(w, x, y, z) { return w + x === y + z; };\n  it('returns a curried function whose arity matches that of the highest-arity predicate', function() {\n    eq(R.anyPass([odd, lt5, plusEq]).length, 4);\n    eq(R.anyPass([odd, lt5, plusEq])(6, 7, 8, 9), false);\n    eq(R.anyPass([odd, lt5, plusEq])(6)(7)(8)(9), false);\n  });\n});",
    "failedSpecsReasons": "Ramda method returns a curried function whose arity matches that of the highest-arity predicate",
    "failedSpecsCount": 1
  },
  "append": {
    "typing": "\nappend<T>(x: T, list: readonly T[]): T[]",
    "allTypings": "append<T>(x: T, list: readonly T[]): T[];\nappend<T>(x: T): <T>(list: readonly T[]) => T[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function append(x, input){\n  if (arguments.length === 1) return _input => append(x, _input)\n\n  if (typeof input === 'string') return input.split('').concat(x)\n\n  const clone = input.slice()\n  clone.push(x)\n\n  return clone\n}",
    "rambdaSpecs": "import { append } from './append'\n\ntest('happy', () => {\n  expect(append('tests', [ 'write', 'more' ])).toEqual([\n    'write',\n    'more',\n    'tests',\n  ])\n})\n\ntest('append to empty array', () => {\n  expect(append('tests')([])).toEqual([ 'tests' ])\n})\n\ntest('with strings', () => {\n  expect(append('o', 'fo')).toEqual([ 'f', 'o', 'o' ])\n})",
    "explanation": "It adds element `x` at the end of `list`.",
    "example": "const x = 'foo'\n\nconst result = R.append(x, ['bar', 'baz'])\n// => ['bar', 'baz', 'foo']",
    "typescriptDefinitionTest": "import {append} from 'rambda'\n\nconst list = [1, 2, 3]\n\ndescribe('R.append', () => {\n  it('happy', () => {\n    const result = append(4, list)\n\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = append(4)(list)\n\n    result // $ExpectType number[]\n  })\n})"
  },
  "applySpec": {
    "typing": "\napplySpec<Spec extends Record<string, (...args: readonly any[]) => any>>(\n  spec: Spec\n): (\n  ...args: Parameters<ValueOfRecord<Spec>>\n) => { [Key in keyof Spec]: ReturnType<Spec[Key]> }",
    "allTypings": "applySpec<Spec extends Record<string, (...args: readonly any[]) => any>>(\n  spec: Spec\n): (\n  ...args: Parameters<ValueOfRecord<Spec>>\n) => { [Key in keyof Spec]: ReturnType<Spec[Key]> };\napplySpec<T>(spec: any): (...args: readonly any[]) => T;",
    "categories": [
      "Function"
    ],
    "notes": "The currying in this function works best with functions with 4 arguments or less. (arity of 4)",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\n// recursively traverse the given spec object to find the highest arity function\nfunction __findHighestArity(spec, max = 0){\n  for (const key in spec){\n    if (spec.hasOwnProperty(key) === false || key === 'constructor') continue\n\n    if (typeof spec[ key ] === 'object'){\n      max = Math.max(max, __findHighestArity(spec[ key ]))\n    }\n\n    if (typeof spec[ key ] === 'function'){\n      max = Math.max(max, spec[ key ].length)\n    }\n  }\n\n  return max\n}\n\nfunction __filterUndefined(){\n  const defined = []\n  let i = 0\n  const l = arguments.length\n  while (i < l){\n    if (typeof arguments[ i ] === 'undefined') break\n    defined[ i ] = arguments[ i ]\n    i++\n  }\n\n  return defined\n}\n\nfunction __applySpecWithArity(\n  spec, arity, cache\n){\n  const remaining = arity - cache.length\n\n  if (remaining === 1)\n    return x =>\n      __applySpecWithArity(\n        spec, arity, __filterUndefined(...cache, x)\n      )\n  if (remaining === 2)\n    return (x, y) =>\n      __applySpecWithArity(\n        spec, arity, __filterUndefined(\n          ...cache, x, y\n        )\n      )\n  if (remaining === 3)\n    return (\n      x, y, z\n    ) =>\n      __applySpecWithArity(\n        spec, arity, __filterUndefined(\n          ...cache, x, y, z\n        )\n      )\n  if (remaining === 4)\n    return (\n      x, y, z, a\n    ) =>\n      __applySpecWithArity(\n        spec,\n        arity,\n        __filterUndefined(\n          ...cache, x, y, z, a\n        )\n      )\n  if (remaining > 4)\n    return (...args) =>\n      __applySpecWithArity(\n        spec, arity, __filterUndefined(...cache, ...args)\n      )\n\n  // handle spec as Array\n  if (_isArray(spec)){\n    const ret = []\n    let i = 0\n    const l = spec.length\n    for (; i < l; i++){\n      // handle recursive spec inside array\n      if (typeof spec[ i ] === 'object' || _isArray(spec[ i ])){\n        ret[ i ] = __applySpecWithArity(\n          spec[ i ], arity, cache\n        )\n      }\n      // apply spec to the key\n      if (typeof spec[ i ] === 'function'){\n        ret[ i ] = spec[ i ](...cache)\n      }\n    }\n\n    return ret\n  }\n\n  // handle spec as Object\n  const ret = {}\n  // apply callbacks to each property in the spec object\n  for (const key in spec){\n    if (spec.hasOwnProperty(key) === false || key === 'constructor') continue\n\n    // apply the spec recursively\n    if (typeof spec[ key ] === 'object'){\n      ret[ key ] = __applySpecWithArity(\n        spec[ key ], arity, cache\n      )\n      continue\n    }\n\n    // apply spec to the key\n    if (typeof spec[ key ] === 'function'){\n      ret[ key ] = spec[ key ](...cache)\n    }\n  }\n\n  return ret\n}\n\nexport function applySpec(spec, ...args){\n  // get the highest arity spec function, cache the result and pass to __applySpecWithArity\n  const arity = __findHighestArity(spec)\n\n  if (arity === 0){\n    return () => ({})\n  }\n  const toReturn = __applySpecWithArity(\n    spec, arity, args\n  )\n\n  return toReturn\n}",
    "rambdaSpecs": "import { applySpec as applySpecRamda, nAry } from 'ramda'\n\nimport { add, always, compose, dec, inc, map, path, prop, T } from '../rambda'\nimport { applySpec } from './applySpec'\n\ntest('different than Ramda when bad spec', () => {\n  const result = applySpec({ sum : { a : 1 } })(1, 2)\n  const ramdaResult = applySpecRamda({ sum : { a : 1 } })(1, 2)\n  expect(result).toEqual({})\n  expect(ramdaResult).toEqual({ sum : { a : {} } })\n})\n\ntest('works with empty spec', () => {\n  expect(applySpec({})()).toEqual({})\n  expect(applySpec([])(1, 2)).toEqual({})\n  expect(applySpec(null)(1, 2)).toEqual({})\n})\n\ntest('works with unary functions', () => {\n  const result = applySpec({\n    v : inc,\n    u : dec,\n  })(1)\n  const expected = {\n    v : 2,\n    u : 0,\n  }\n  expect(result).toEqual(expected)\n})\n\ntest('works with binary functions', () => {\n  const result = applySpec({ sum : add })(1, 2)\n  expect(result).toEqual({ sum : 3 })\n})\n\ntest('works with nested specs', () => {\n  const result = applySpec({\n    unnested : always(0),\n    nested   : { sum : add },\n  })(1, 2)\n  const expected = {\n    unnested : 0,\n    nested   : { sum : 3 },\n  }\n  expect(result).toEqual(expected)\n})\n\ntest('works with arrays of nested specs', () => {\n  const result = applySpec({\n    unnested : always(0),\n    nested   : [ { sum : add } ],\n  })(1, 2)\n\n  expect(result).toEqual({\n    unnested : 0,\n    nested   : [ { sum : 3 } ],\n  })\n})\n\ntest('works with arrays of spec objects', () => {\n  const result = applySpec([ { sum : add } ])(1, 2)\n\n  expect(result).toEqual([ { sum : 3 } ])\n})\n\ntest('works with arrays of functions', () => {\n  const result = applySpec([ map(prop('a')), map(prop('b')) ])([\n    {\n      a : 'a1',\n      b : 'b1',\n    },\n    {\n      a : 'a2',\n      b : 'b2',\n    },\n  ])\n  const expected = [\n    [ 'a1', 'a2' ],\n    [ 'b1', 'b2' ],\n  ]\n  expect(result).toEqual(expected)\n})\n\ntest('works with a spec defining a map key', () => {\n  expect(applySpec({ map : prop('a') })({ a : 1 })).toEqual({ map : 1 })\n})\n\ntest('cannot retains the highest arity', () => {\n  const f = applySpec({\n    f1 : nAry(2, T),\n    f2 : nAry(5, T),\n  })\n  const fRamda = applySpecRamda({\n    f1 : nAry(2, T),\n    f2 : nAry(5, T),\n  })\n  expect(f.length).toBe(0)\n  expect(fRamda.length).toBe(5)\n})\n\ntest('returns a curried function', () => {\n  expect(applySpec({ sum : add })(1)(2)).toEqual({ sum : 3 })\n})\n\n// Additional tests\n// ============================================\ntest('arity', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n  }\n  expect(applySpec(\n    spec, 1, 2, 3\n  )).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n  })\n})\n\ntest('arity over 5 arguments', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n    four : (\n      x1, x2, x3, x4\n    ) => x1 + x2 + x3 + x4,\n    five : (\n      x1, x2, x3, x4, x5\n    ) => x1 + x2 + x3 + x4 + x5,\n  }\n  expect(applySpec(\n    spec, 1, 2, 3, 4, 5\n  )).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n    four  : 10,\n    five  : 15,\n  })\n})\n\ntest('curried', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n  }\n  expect(applySpec(spec)(1)(2)(3)).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n  })\n})\n\ntest('curried over 5 arguments', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n    four : (\n      x1, x2, x3, x4\n    ) => x1 + x2 + x3 + x4,\n    five : (\n      x1, x2, x3, x4, x5\n    ) => x1 + x2 + x3 + x4 + x5,\n  }\n  expect(applySpec(spec)(1)(2)(3)(4)(5)).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n    four  : 10,\n    five  : 15,\n  })\n})\n\ntest('undefined property', () => {\n  const spec = { prop : path([ 'property', 'doesnt', 'exist' ]) }\n  expect(applySpec(spec, {})).toEqual({ prop : undefined })\n})\n\ntest('restructure json object', () => {\n  const spec = {\n    id          : path('user.id'),\n    name        : path('user.firstname'),\n    profile     : path('user.profile'),\n    doesntExist : path('user.profile.doesntExist'),\n    info        : { views : compose(inc, prop('views')) },\n    type        : always('playa'),\n  }\n\n  const data = {\n    user : {\n      id        : 1337,\n      firstname : 'john',\n      lastname  : 'shaft',\n      profile   : 'shaft69',\n    },\n    views : 42,\n  }\n\n  expect(applySpec(spec, data)).toEqual({\n    id          : 1337,\n    name        : 'john',\n    profile     : 'shaft69',\n    doesntExist : undefined,\n    info        : { views : 43 },\n    type        : 'playa',\n  })\n})",
    "example": "const fn = R.applySpec({\n  sum: R.add,\n  nested: { mul: R.multiply }\n})\nconst result = fn(2, 4) \n// => { sum: 6, nested: { mul: 8 } }",
    "typescriptDefinitionTest": "import {multiply, applySpec, inc, dec, add} from 'rambda'\n\ndescribe('applySpec', () => {\n  it('ramda 1', () => {\n    const result = applySpec({\n      v: inc,\n      u: dec,\n    })(1)\n    result // $ExpectType { v: number; u: number; }\n  })\n  it('ramda 1', () => {\n    interface Output {\n      sum: number,\n      multiplied: number,\n    }\n    const result = applySpec<Output>({\n      sum: add,\n      multiplied: multiply,\n    })(1, 2)\n\n    result // $ExpectType Output\n  })\n})"
  },
  "assoc": {
    "typing": "\nassoc<T, U, K extends string>(prop: K, val: T, obj: U): Record<K, T> & U",
    "allTypings": "assoc<T, U, K extends string>(prop: K, val: T, obj: U): Record<K, T> & U;\nassoc<T, K extends string>(prop: K, val: T): <U>(obj: U) => Record<K, T> & U;\nassoc<K extends string>(prop: K): AssocPartialOne<K>;",
    "categories": [
      "Object"
    ],
    "notes": "This copies and flattens prototype properties\nonto the new object as well. All non-primitive properties are copied by\nreference.",
    "rambdaSource": "import { curry } from './curry'\n\nfunction assocFn(\n  prop, newValue, obj\n){\n  return Object.assign(\n    {}, obj, { [ prop ] : newValue }\n  )\n}\n\nexport const assoc = curry(assocFn)",
    "rambdaSpecs": "import { assoc } from './assoc'\n\ntest('adds a key to an empty object', () => {\n  expect(assoc(\n    'a', 1, {}\n  )).toEqual({ a : 1 })\n})\n\ntest('adds a key to a non-empty object', () => {\n  expect(assoc(\n    'b', 2, { a : 1 }\n  )).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 1', () => {\n  expect(assoc('b', 2)({ a : 1 })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 2', () => {\n  expect(assoc('b')(2, { a : 1 })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 3', () => {\n  const result = assoc('b')(2)({ a : 1 })\n\n  expect(result).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('changes an existing key', () => {\n  expect(assoc(\n    'a', 2, { a : 1 }\n  )).toEqual({ a : 2 })\n})\n\ntest('undefined is considered an empty object', () => {\n  expect(assoc(\n    'a', 1, undefined\n  )).toEqual({ a : 1 })\n})\n\ntest('null is considered an empty object', () => {\n  expect(assoc(\n    'a', 1, null\n  )).toEqual({ a : 1 })\n})\n\ntest('value can be null', () => {\n  expect(assoc(\n    'a', null, null\n  )).toEqual({ a : null })\n})\n\ntest('value can be undefined', () => {\n  expect(assoc(\n    'a', undefined, null\n  )).toEqual({ a : undefined })\n})\n\ntest('assignment is shallow', () => {\n  expect(assoc(\n    'a', { b : 2 }, { a : { c : 3 } }\n  )).toEqual({ a : { b : 2 } })\n})",
    "explanation": "It makes a shallow clone of `obj` with setting or overriding the property `prop` with `newValue`.",
    "example": "R.assoc('c', 3, {a: 1, b: 2})\n//=> {a: 1, b: 2, c: 3}",
    "typescriptDefinitionTest": "import {assoc} from 'rambda'\n\nconst obj = {a: 1}\nconst newValue = 2\nconst newProp = 'b'\n\ndescribe('R.assoc', () => {\n  it('happy', () => {\n    const result = assoc(newProp, newValue, obj)\n\n    result.a // $ExpectType number\n    result.b // $ExpectType number\n  })\n  it('curried 1', () => {\n    const result = assoc(newProp, newValue)(obj)\n\n    result.a // $ExpectType number\n    result.b // $ExpectType number\n  })\n  it('curried 2', () => {\n    const result = assoc(newProp)(newValue)(obj)\n\n    result.a // $ExpectType number\n    result.b // $ExpectType number\n  })\n})"
  },
  "assocPath": {
    "typing": "\nassocPath<Output>(path: Path, newValue: any, obj: object): Output",
    "allTypings": "assocPath<Output>(path: Path, newValue: any, obj: object): Output;\nassocPath<Output>(path: Path, newValue: any): (obj: object) => Output;\nassocPath<Output>(path: Path): FunctionToolbelt.Curry<(newValue: any, obj: object) => Output>;",
    "categories": [
      "Object"
    ],
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\nimport { _isInteger } from './_internals/_isInteger'\nimport { assoc } from './assoc'\nimport { curry } from './curry'\n\nfunction assocPathFn(\n  path, newValue, input\n){\n  const pathArrValue =\n    typeof path === 'string' ?\n      path.split('.').map(x => _isInteger(Number(x)) ? Number(x) : x) :\n      path\n  if (pathArrValue.length === 0){\n    return newValue\n  }\n\n  const index = pathArrValue[ 0 ]\n  if (pathArrValue.length > 1){\n    const condition =\n      typeof input !== 'object' ||\n      input === null ||\n      !input.hasOwnProperty(index)\n\n    const nextinput = condition ?\n      _isInteger(pathArrValue[ 1 ]) ?\n        [] :\n        {} :\n      input[ index ]\n\n    newValue = assocPathFn(\n      Array.prototype.slice.call(pathArrValue, 1),\n      newValue,\n      nextinput\n    )\n  }\n\n  if (_isInteger(index) && _isArray(input)){\n    const arr = input.slice()\n    arr[ index ] = newValue\n\n    return arr\n  }\n\n  return assoc(\n    index, newValue, input\n  )\n}\n\nexport const assocPath = curry(assocPathFn)",
    "rambdaSpecs": "import { assocPath } from './assocPath'\n\ntest('string can be used as path input', () => {\n  const testObj = {\n    a : [ { b : 1 }, { b : 2 } ],\n    d : 3,\n  }\n  const result = assocPath(\n    'a.0.b', 10, testObj\n  )\n  const expected = {\n    a : [ { b : 10 }, { b : 2 } ],\n    d : 3,\n  }\n  expect(result).toEqual(expected)\n})\n\ntest('bug', () => {\n  /*\n    https://github.com/selfrefactor/rambda/issues/524\n  */\n  const state = {}\n\n  const withDateLike = assocPath(\n    [ 'outerProp', '2020-03-10' ],\n    { prop : 2 },\n    state\n  )\n  const withNumber = assocPath(\n    [ 'outerProp', '5' ], { prop : 2 }, state\n  )\n\n  const withDateLikeExpected = { outerProp : { '2020-03-10' : { prop : 2 } } }\n  const withNumberExpected = { outerProp : { 5 : { prop : 2 } } }\n  expect(withDateLike).toEqual(withDateLikeExpected)\n  expect(withNumber).toEqual(withNumberExpected)\n})\n\ntest('adds a key to an empty object', () => {\n  expect(assocPath(\n    [ 'a' ], 1, {}\n  )).toEqual({ a : 1 })\n})\n\ntest('adds a key to a non-empty object', () => {\n  expect(assocPath(\n    'b', 2, { a : 1 }\n  )).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a nested key to a non-empty object', () => {\n  expect(assocPath(\n    'b.c', 2, { a : 1 }\n  )).toEqual({\n    a : 1,\n    b : { c : 2 },\n  })\n})\n\ntest('adds a nested key to a nested non-empty object - curry case 1', () => {\n  expect(assocPath('b.d',\n    3)({\n    a : 1,\n    b : { c : 2 },\n  })).toEqual({\n    a : 1,\n    b : {\n      c : 2,\n      d : 3,\n    },\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 1', () => {\n  expect(assocPath('b', 2)({ a : 1 })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a nested key to a non-empty object - curry case 1', () => {\n  expect(assocPath('b.c', 2)({ a : 1 })).toEqual({\n    a : 1,\n    b : { c : 2 },\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 2', () => {\n  expect(assocPath('b')(2, { a : 1 })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 3', () => {\n  const result = assocPath('b')(2)({ a : 1 })\n\n  expect(result).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('changes an existing key', () => {\n  expect(assocPath(\n    'a', 2, { a : 1 }\n  )).toEqual({ a : 2 })\n})\n\ntest('undefined is considered an empty object', () => {\n  expect(assocPath(\n    'a', 1, undefined\n  )).toEqual({ a : 1 })\n})\n\ntest('null is considered an empty object', () => {\n  expect(assocPath(\n    'a', 1, null\n  )).toEqual({ a : 1 })\n})\n\ntest('value can be null', () => {\n  expect(assocPath(\n    'a', null, null\n  )).toEqual({ a : null })\n})\n\ntest('value can be undefined', () => {\n  expect(assocPath(\n    'a', undefined, null\n  )).toEqual({ a : undefined })\n})\n\ntest('assignment is shallow', () => {\n  expect(assocPath(\n    'a', { b : 2 }, { a : { c : 3 } }\n  )).toEqual({ a : { b : 2 } })\n})\n\ntest('empty array as path', () => {\n  const result = assocPath(\n    [], 3, {\n      a : 1,\n      b : 2,\n    }\n  )\n  expect(result).toEqual(3)\n})\n\ntest('happy', () => {\n  const expected = { foo : { bar : { baz : 42 } } }\n  const result = assocPath(\n    [ 'foo', 'bar', 'baz' ], 42, { foo : null }\n  )\n  expect(result).toEqual(expected)\n})",
    "explanation": "It makes a shallow clone of `obj` with setting or overriding with `newValue` the property found with `path`.",
    "example": "const path = 'b.c'\nconst newValue = 2\nconst obj = { a: 1 }\n\nR.assocPath(path, newValue, obj)\n// => { a : 1, b : { c : 2 }}",
    "typescriptDefinitionTest": "import {assocPath} from 'rambda'\n\ninterface Output {\n  a: number,\n  foo: {bar: number},\n}\n\ndescribe('R.assocPath - user must explicitly set type of output', () => {\n  it('with array as path input', () => {\n    const result = assocPath<Output>(['foo', 'bar'], 2, {a: 1})\n\n    result // $ExpectType Output\n  })\n  it('with string as path input', () => {\n    const result = assocPath<Output>('foo.bar', 2, {a: 1})\n\n    result // $ExpectType Output\n  })\n})\n\ndescribe('R.assocPath - curried', () => {\n  it('with array as path input', () => {\n    const result = assocPath<Output>(['foo', 'bar'], 2)({a: 1})\n\n    result // $ExpectType Output\n  })\n  it('with string as path input', () => {\n    const result = assocPath<Output>('foo.bar', 2)({a: 1})\n\n    result // $ExpectType Output\n  })\n})"
  },
  "both": {
    "typing": "\nboth(pred1: Pred, pred2: Pred): Pred",
    "allTypings": "both(pred1: Pred, pred2: Pred): Pred;\nboth<T>(pred1: Predicate<T>, pred2: Predicate<T>): Predicate<T>;\nboth<T>(pred1: Predicate<T>): (pred2: Predicate<T>) => Predicate<T>;\nboth(pred1: Pred): (pred2: Pred) => Pred;",
    "categories": [
      "Function"
    ],
    "rambdaSource": "export function both(f, g){\n  if (arguments.length === 1) return _g => both(f, _g)\n\n  return (...input) => f(...input) && g(...input)\n}",
    "rambdaSpecs": "import { both } from './both'\n\nconst firstFn = val => val > 0\nconst secondFn = val => val < 10\n\ntest('with curry', () => {\n  expect(both(firstFn)(secondFn)(17)).toBeFalse()\n})\n\ntest('without curry', () => {\n  expect(both(firstFn, secondFn)(7)).toBeTrue()\n})\n\ntest('with multiple inputs', () => {\n  const between = function (\n    a, b, c\n  ){\n    return a < b && b < c\n  }\n  const total20 = function (\n    a, b, c\n  ){\n    return a + b + c === 20\n  }\n  const fn = both(between, total20)\n  expect(fn(\n    5, 7, 8\n  )).toBeTrue()\n})\n\ntest('skip evaluation of the second expression', () => {\n  let effect = 'not evaluated'\n  const F = function (){\n    return false\n  }\n  const Z = function (){\n    effect = 'Z got evaluated'\n  }\n  both(F, Z)()\n\n  expect(effect).toBe('not evaluated')\n})",
    "explanation": "It returns a function with `input` argument. \n\nThis function will return `true`, if both `firstCondition` and `secondCondition` return `true` when `input` is passed as their argument.",
    "example": "const firstCondition = x => x > 10\nconst secondCondition = x => x < 20\nconst fn = R.both(secondCondition)\n\nconst result = [fn(15), fn(30)]\n// => [true, false]",
    "typescriptDefinitionTest": "import {both} from 'rambda'\n\ndescribe('R.both', () => {\n  it('with passed type', () => {\n    const fn = both<number>(\n      x => x > 1,\n      x => x % 2 === 0\n    )\n    fn // $ExpectType Predicate<number>\n    const result = fn(2) // $ExpectType boolean\n    result // $ExpectType boolean\n  })\n  it('with passed type - curried', () => {\n    const fn = both<number>(x => x > 1)(x => x % 2 === 0)\n    fn // $ExpectType Predicate<number>\n    const result = fn(2)\n    result // $ExpectType boolean\n  })\n  it('no type passed', () => {\n    const fn = both(\n      x => {\n        x // $ExpectType any\n        return x > 1\n      },\n      x => {\n        x // $ExpectType any\n        return x % 2 === 0\n      }\n    )\n    const result = fn(2)\n    result // $ExpectType boolean\n  })\n  it('no type passed - curried', () => {\n    const fn = both((x: number) => {\n      x // $ExpectType number\n      return x > 1\n    })((x: number) => {\n      x // $ExpectType number\n      return x % 2 === 0\n    })\n    const result = fn(2)\n    result // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var S = require('sanctuary');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('both', function() {\n  it('accepts fantasy-land applicative functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.both(Just(true), Just(true)), Just(true));\n    eq(R.both(Just(true), Just(false)), Just(false));\n    eq(R.both(Just(true), Nothing()), Nothing());\n    eq(R.both(Nothing(), Just(false)), Nothing());\n    eq(R.both(Nothing(), Nothing()), Nothing());\n  });\n});",
    "failedSpecsReasons": "Ramda library supports fantasy-land",
    "failedSpecsCount": 1
  },
  "chain": {
    "typing": "\nchain<T, U>(fn: (n: T) => U[], list: readonly T[]): U[]",
    "allTypings": "chain<T, U>(fn: (n: T) => U[], list: readonly T[]): U[];\nchain<T, U>(fn: (n: T) => U[]): (list: readonly T[]) => U[];\nchain<X0, X1, R>(fn: (x0: X0, x1: X1) => R, fn1: (x1: X1) => X0): (x1: X1) => R;",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function chain(fn, list){\n  if (arguments.length === 1){\n    return _list => chain(fn, _list)\n  }\n\n  return [].concat(...list.map(fn))\n}",
    "rambdaSpecs": "import { chain } from './chain'\n\nconst duplicate = n => [ n, n ]\n\ntest('happy', () => {\n  const fn = x => [ x * 2 ]\n  const list = [ 1, 2, 3 ]\n\n  const result = chain(fn, list)\n\n  expect(result).toEqual([ 2, 4, 6 ])\n})\n\ntest('maps then flattens one level', () => {\n  expect(chain(duplicate, [ 1, 2, 3 ])).toEqual([ 1, 1, 2, 2, 3, 3 ])\n})\n\ntest('maps then flattens one level - curry', () => {\n  expect(chain(duplicate)([ 1, 2, 3 ])).toEqual([ 1, 1, 2, 2, 3, 3 ])\n})\n\ntest('flattens only one level', () => {\n  const nest = n => [ [ n ] ]\n  expect(chain(nest, [ 1, 2, 3 ])).toEqual([ [ 1 ], [ 2 ], [ 3 ] ])\n})",
    "explanation": "The method is also known as `flatMap`.",
    "example": "const duplicate = n => [ n, n ]\nconst list = [ 1, 2, 3 ]\n\nconst result = chain(duplicate, list)\n// => [ 1, 1, 2, 2, 3, 3 ]",
    "typescriptDefinitionTest": "import {chain} from 'rambda'\n\nconst list = [1, 2, 3]\nconst fn = (x: number) => [`${x}`, `${x}`]\n\ndescribe('R.chain', () => {\n  it('without passing type', () => {\n    const result = chain(fn, list)\n    result // $ExpectType string[]\n    const resultCurried = chain(fn)(list)\n    resultCurried // $ExpectType string[]\n  })\n})",
    "failedSpecsReasons": "Ramda method passes to `chain` property if available | Ramda library supports fantasy-land",
    "failedSpecsCount": 5
  },
  "clamp": {
    "typing": "\nclamp(min: number, max: number, input: number): number",
    "allTypings": "clamp(min: number, max: number, input: number): number;\nclamp(min: number, max: number): (input: number) => number;",
    "categories": [
      "Other"
    ],
    "rambdaSource": "import { curry } from './curry'\n\nfunction clampFn(\n  min, max, input\n){\n  if (min > max){\n    throw new Error('min must not be greater than max in clamp(min, max, value)')\n  }\n  if (input >= min && input <= max) return input\n\n  if (input > max) return max\n  if (input < min) return min\n}\n\nexport const clamp = curry(clampFn)",
    "rambdaSpecs": "import { clamp } from './clamp'\n\ntest('when min is greater than max', () => {\n  expect(() => clamp(\n    -5, -10, 5\n  )).toThrowWithMessage(Error,\n    'min must not be greater than max in clamp(min, max, value)')\n})\n\ntest('rambda specs', () => {\n  expect(clamp(\n    1, 10, 0\n  )).toEqual(1)\n  expect(clamp(\n    3, 12, 1\n  )).toEqual(3)\n  expect(clamp(\n    -15, 3, -100\n  )).toEqual(-15)\n  expect(clamp(\n    1, 10, 20\n  )).toEqual(10)\n  expect(clamp(\n    3, 12, 23\n  )).toEqual(12)\n  expect(clamp(\n    -15, 3, 16\n  )).toEqual(3)\n  expect(clamp(\n    1, 10, 4\n  )).toEqual(4)\n  expect(clamp(\n    3, 12, 6\n  )).toEqual(6)\n  expect(clamp(\n    -15, 3, 0\n  )).toEqual(0)\n})",
    "explanation": "Restrict a number `input` to be within `min` and `max` limits.\n\nIf `input` is bigger than `max`, then the result is `max`.\n\nIf `input` is smaller than `min`, then the result is `min`.",
    "example": "const result = [\n  R.clamp(0, 10, 5), \n  R.clamp(0, 10, -1),\n  R.clamp(0, 10, 11)\n]\n//=> [5, 0, 10]",
    "typescriptDefinitionTest": "import {clamp} from 'rambda'\n\ndescribe('R.clamp', () => {\n  it('happy', () => {\n    const result = clamp(1, 10, 20)\n    result // $ExpectType number\n  })\n})"
  },
  "clone": {
    "typing": "\nclone<T>(input: T): T",
    "allTypings": "clone<T>(input: T): T;\nclone<T>(input: readonly T[]): T[];",
    "categories": [
      "Object"
    ],
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nexport function clone(input){\n  const out = _isArray(input) ? Array(input.length) : {}\n  if (input && input.getTime) return new Date(input.getTime())\n\n  for (const key in input){\n    const v = input[ key ]\n    out[ key ] =\n      typeof v === 'object' && v !== null ?\n        v.getTime ?\n          new Date(v.getTime()) :\n          clone(v) :\n        v\n  }\n\n  return out\n}",
    "rambdaSpecs": "import assert from 'assert'\n\nimport { clone } from './clone'\nimport { equals } from './equals'\n\ntest('with array', () => {\n  const arr = [\n    {\n      b : 2,\n      c : 'foo',\n      d : [ 1, 2, 3 ],\n    },\n    1,\n    new Date(),\n    null,\n  ]\n  expect(clone(arr)).toEqual(arr)\n})\n\ntest('with object', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n    c : 3,\n    d : [ 1, 2, 3 ],\n    e : new Date(),\n  }\n  expect(clone(obj)).toEqual(obj)\n})\n\ntest('with date', () => {\n  const date = new Date(\n    2014, 10, 14, 23, 59, 59, 999\n  )\n\n  const cloned = clone(date)\n  assert.notStrictEqual(date, cloned)\n  expect(cloned).toEqual(new Date(\n    2014, 10, 14, 23, 59, 59, 999\n  ))\n\n  expect(cloned.getDay()).toEqual(5)\n})\n\ntest('with R.equals', () => {\n  const objects = [ { a : 1 }, { b : 2 } ]\n\n  const objectsClone = clone(objects)\n\n  const result = [\n    equals(objects, objectsClone),\n    equals(objects[ 0 ], objectsClone[ 0 ]),\n  ]\n  expect(result).toEqual([ true, true ])\n})",
    "explanation": "It creates a deep copy of the `input`, which may contain (nested) Arrays and Objects, Numbers, Strings, Booleans and Dates.",
    "example": "const objects = [{a: 1}, {b: 2}];\nconst objectsClone = R.clone(objects);\n\nconst result = [\n  R.equals(objects, objectsClone),\n  R.equals(objects[0], objectsClone[0]),\n] // => [ true, true ]",
    "typescriptDefinitionTest": "import {clone} from 'rambda'\n\ndescribe('R.clone', () => {\n  it('happy', () => {\n    const obj = {a: 1, b: 2}\n    const result = clone(obj)\n    result // $ExpectType { a: number; b: number; }\n  })\n})",
    "failedRamdaSpecs": "var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('deep clone integers, strings and booleans', function() {\n  it('clones integers', function() {\n    eq(R.clone(-4), -4);\n    eq(R.clone(9007199254740991), 9007199254740991);\n  });\n  it('clones floats', function() {\n    eq(R.clone(-4.5), -4.5);\n    eq(R.clone(0.0), 0.0);\n  });\n  it('clones strings', function() {\n    eq(R.clone('ramda'), 'ramda');\n  });\n  it('clones booleans', function() {\n    eq(R.clone(true), true);\n  });\n});\ndescribe('deep clone objects', function() {\n  it('clones objects with circular references', function() {\n    var x = {c: null};\n    var y = {a: x};\n    var z = {b: y};\n    x.c = z;\n    var clone = R.clone(x);\n    assert.notStrictEqual(x, clone);\n    assert.notStrictEqual(x.c, clone.c);\n    assert.notStrictEqual(x.c.b, clone.c.b);\n    assert.notStrictEqual(x.c.b.a, clone.c.b.a);\n    assert.notStrictEqual(x.c.b.a.c, clone.c.b.a.c);\n    eq(R.keys(clone), R.keys(x));\n    eq(R.keys(clone.c), R.keys(x.c));\n    eq(R.keys(clone.c.b), R.keys(x.c.b));\n    eq(R.keys(clone.c.b.a), R.keys(x.c.b.a));\n    eq(R.keys(clone.c.b.a.c), R.keys(x.c.b.a.c));\n    x.c.b = 1;\n    assert.notDeepEqual(clone.c.b, x.c.b);\n  });\n});\ndescribe('deep clone arrays', function() {\n});\ndescribe('deep clone functions', function() {\n});\ndescribe('built-in types', function() {\n  it('clones RegExp object', function() {\n    R.forEach(function(pattern) {\n      var clone = R.clone(pattern);\n      assert.notStrictEqual(clone, pattern);\n      eq(clone.constructor, RegExp);\n      eq(clone.source, pattern.source);\n      eq(clone.global, pattern.global);\n      eq(clone.ignoreCase, pattern.ignoreCase);\n      eq(clone.multiline, pattern.multiline);\n    }, [/x/, /x/g, /x/i, /x/m, /x/gi, /x/gm, /x/im, /x/gim]);\n  });\n});\ndescribe('deep clone deep nested mixed objects', function() {\n  it('clones array with mutual ref object', function() {\n    var obj = {a: 1};\n    var list = [{b: obj}, {b: obj}];\n    var clone = R.clone(list);\n    assert.strictEqual(list[0].b, list[1].b);\n    assert.strictEqual(clone[0].b, clone[1].b);\n    assert.notStrictEqual(clone[0].b, list[0].b);\n    assert.notStrictEqual(clone[1].b, list[1].b);\n    eq(clone[0].b, {a:1});\n    eq(clone[1].b, {a:1});\n    obj.a = 2;\n    eq(clone[0].b, {a:1});\n    eq(clone[1].b, {a:1});\n  });\n});\ndescribe('deep clone edge cases', function() {\n  it('nulls, undefineds and empty objects and arrays', function() {\n    eq(R.clone(null), null);\n    eq(R.clone(undefined), undefined);\n    assert.notStrictEqual(R.clone(undefined), null);\n    var obj = {};\n    assert.notStrictEqual(R.clone(obj), obj);\n    var list = [];\n    assert.notStrictEqual(R.clone(list), list);\n  });\n});\ndescribe('Let `R.clone` use an arbitrary user defined `clone` method', function() {\n  it('dispatches to `clone` method if present', function() {\n    function ArbitraryClone(x) { this.value = x; }\n    ArbitraryClone.prototype.clone = function() { return new ArbitraryClone(this.value); };\n    var obj = new ArbitraryClone(42);\n    var arbitraryClonedObj = R.clone(obj);\n    eq(arbitraryClonedObj, new ArbitraryClone(42));\n    eq(arbitraryClonedObj instanceof ArbitraryClone, true);\n  });\n});",
    "failedSpecsReasons": "Rambda method work only with objects and arrays",
    "failedSpecsCount": 9
  },
  "complement": {
    "typing": "\ncomplement<T extends any[]>(pred: (...args: T) => boolean): (...args: T) => boolean",
    "allTypings": "complement<T extends any[]>(pred: (...args: T) => boolean): (...args: T) => boolean;",
    "categories": [
      "Function"
    ],
    "rambdaSource": "export function complement(fn){\n  return (...input) => !fn(...input)\n}",
    "rambdaSpecs": "import { complement } from './complement'\n\ntest('happy', () => {\n  const fn = complement(x => x.length === 0)\n\n  expect(fn([ 1, 2, 3 ])).toBeTrue()\n})\n\ntest('with multiple parameters', () => {\n  const between = function (\n    a, b, c\n  ){\n    return a < b && b < c\n  }\n  const f = complement(between)\n  expect(f(\n    4, 5, 11\n  )).toEqual(false)\n  expect(f(\n    12, 2, 6\n  )).toEqual(true)\n})",
    "explanation": "It returns `inverted` version of `origin` function that accept `input` as argument.\n\nThe return value of `inverted` is the negative boolean value of `origin(input)`.",
    "example": "const origin = x => x > 5\nconst inverted = complement(origin)\n\nconst result = [\n  origin(7),\n  inverted(7)\n] => [ true, false ]",
    "typescriptDefinitionTest": "import {complement, isNil} from 'rambda'\n\ndescribe('R.complement', () => {\n  it('happy', () => {\n    const fn = complement(isNil)\n    const result = fn(null)\n    result // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var S = require('sanctuary');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('complement', function() {\n  it('accepts fantasy-land functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.complement(Just(true)), Just(false));\n    eq(R.complement(Just(false)), Just(true));\n    eq(R.complement(Nothing()), Nothing());\n  });\n});",
    "failedSpecsReasons": "Ramda library supports fantasy-land",
    "failedSpecsCount": 1
  },
  "compose": {
    "typing": "\ncompose<T1>(fn0: () => T1): () => T1",
    "allTypings": "compose<T1>(fn0: () => T1): () => T1;\ncompose<V0, T1>(fn0: (x0: V0) => T1): (x0: V0) => T1;\ncompose<V0, V1, T1>(fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T1;\ncompose<V0, V1, V2, T1>(fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T1;\n\ncompose<T1, T2>(fn1: (x: T1) => T2, fn0: () => T1): () => T2;\ncompose<V0, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0) => T1): (x0: V0) => T2;\ncompose<V0, V1, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T2;\ncompose<V0, V1, V2, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T2;\n\ncompose<T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: () => T1): () => T3;\ncompose<V0, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T3;\ncompose<V0, V1, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T3;\ncompose<V0, V1, V2, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T3;\n\ncompose<T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: () => T1): () => T4;\ncompose<V0, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T4;\ncompose<V0, V1, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T4;\ncompose<V0, V1, V2, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T4;\n\ncompose<T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: () => T1): () => T5;\ncompose<V0, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T5;\ncompose<V0, V1, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T5;\ncompose<V0, V1, V2, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T5;\n\ncompose<T1, T2, T3, T4, T5, T6>(fn5: (x: T5) => T6, fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: () => T1): () => T6;\ncompose<V0, T1, T2, T3, T4, T5, T6>(fn5: (x: T5) => T6, fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T6;\ncompose<V0, V1, T1, T2, T3, T4, T5, T6>(\n  fn5: (x: T5) => T6,\n  fn4: (x: T4) => T5,\n  fn3: (x: T3) => T4,\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T6;\ncompose<V0, V1, V2, T1, T2, T3, T4, T5, T6>(\n  fn5: (x: T5) => T6,\n  fn4: (x: T4) => T5,\n  fn3: (x: T3) => T4,\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T6;",
    "categories": [
      "Function"
    ],
    "rambdaSource": "export function compose(...fns){\n  if (fns.length === 0){\n    throw new Error('compose requires at least one argument')\n  }\n\n  return (...args) => {\n    const list = fns.slice()\n    if (list.length > 0){\n      const fn = list.pop()\n      let result = fn(...args)\n      while (list.length > 0){\n        result = list.pop()(result)\n      }\n\n      return result\n    }\n  }\n}",
    "rambdaSpecs": "import { add } from './add'\nimport { compose } from './compose'\nimport { filter } from './filter'\nimport { last } from './last'\nimport { map } from './map'\n\ntest('happy', () => {\n  const result = compose(\n    last, map(add(10)), map(add(1))\n  )([ 1, 2, 3 ])\n\n  expect(result).toEqual(14)\n})\n\ntest('can accepts initially two arguments', () => {\n  const result = compose(map(x => x * 2),\n    (list, limit) => filter(x => x > limit, list))([ 1, 2, 3, 4, false ], 2)\n\n  expect(result).toEqual([ 6, 8 ])\n})\n\ntest('when no arguments is passed', () => {\n  expect(() => compose()).toThrow('compose requires at least one argument')\n})\n\ntest('ramda spec', () => {\n  const f = function (\n    a, b, c\n  ){\n    return [ a, b, c ]\n  }\n  const g = compose(f)\n\n  expect(g(\n    1, 2, 3\n  )).toEqual([ 1, 2, 3 ])\n})",
    "explanation": "It performs right-to-left function composition.",
    "example": "const result = R.compose(\n  R.map(x => x * 2),\n  R.filter(x => x > 2)\n)([1, 2, 3, 4])\n\n// => [6, 8]",
    "typescriptDefinitionTest": "import {add, subtract, compose} from 'rambda'\n\ndescribe('R.compose', () => {\n  it('happy', () => {\n    const result = compose(subtract(11), add(1), add(1))(1)\n    result // $ExpectType number\n  })\n\n  it('with void', () => {\n    const result = compose(\n      () => {},\n      () => {}\n    )()\n    result // $ExpectType void\n  })\n})",
    "failedRamdaSpecs": "var assert = require('assert');\nvar jsv = require('jsverify');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('compose', function() {\n  it('performs right-to-left function composition', function() {\n    //  f :: (String, Number?) -> ([Number] -> [Number])\n    var f = R.compose(R.map, R.multiply, parseInt);\n    eq(f.length, 2);\n    eq(f('10')([1, 2, 3]), [10, 20, 30]);\n    eq(f('10', 2)([1, 2, 3]), [2, 4, 6]);\n  });\n  it('passes context to functions', function() {\n    function x(val) {\n      return this.x * val;\n    }\n    function y(val) {\n      return this.y * val;\n    }\n    function z(val) {\n      return this.z * val;\n    }\n    var context = {\n      a: R.compose(x, y, z),\n      x: 4,\n      y: 2,\n      z: 1\n    };\n    eq(context.a(5), 40);\n  });\n  it('can be applied to one argument', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.compose(f);\n    eq(g.length, 3);\n    eq(g(1, 2, 3), [1, 2, 3]);\n  });\n});\ndescribe('compose properties', function() {\n  jsv.property('composes two functions', jsv.fn(), jsv.fn(), jsv.nat, function(f, g, x) {\n    return R.equals(R.compose(f, g)(x), f(g(x)));\n  jsv.property('associative',  jsv.fn(), jsv.fn(), jsv.fn(), jsv.nat, function(f, g, h, x) {\n    var result = f(g(h(x)));\n    return R.all(R.equals(result), [\n      R.compose(f, g, h)(x),\n      R.compose(f, R.compose(g, h))(x),\n      R.compose(R.compose(f, g), h)(x)\n    ]);\n});",
    "failedSpecsReasons": "Ramda method passes context to functions | Rambda composed functions have no length",
    "failedSpecsCount": 3
  },
  "concat": {
    "typing": "\nconcat<T>(x: readonly T[], y: readonly T[]): T[]",
    "allTypings": "concat<T>(x: readonly T[], y: readonly T[]): T[];\nconcat<T>(x: readonly T[]): (y: readonly T[]) => T[];\nconcat(x: string, y: string): string;\nconcat(x: string): (y: string) => string;",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "export function concat(x, y){\n  if (arguments.length === 1) return _y => concat(x, _y)\n\n  return typeof x === 'string' ? `${ x }${ y }` : [ ...x, ...y ]\n}",
    "rambdaSpecs": "import { concat } from './concat'\n\ntest('happy', () => {\n  const arr1 = [ 'a', 'b', 'c' ]\n  const arr2 = [ 'd', 'e', 'f' ]\n\n  const a = concat(arr1, arr2)\n  const b = concat(arr1)(arr2)\n  const expectedResult = [ 'a', 'b', 'c', 'd', 'e', 'f' ]\n\n  expect(a).toEqual(expectedResult)\n  expect(b).toEqual(expectedResult)\n})\n\ntest('with strings', () => {\n  expect(concat('ABC', 'DEF')).toEqual('ABCDEF')\n})",
    "explanation": "It returns a new string or array, which is the result of merging `x` and `y`.",
    "example": "R.concat([1, 2])([3, 4]) // => [1, 2, 3, 4]\nR.concat('foo', 'bar') // => 'foobar'",
    "typescriptDefinitionTest": "import {concat} from 'rambda'\n\nconst list1 = [1, 2, 3]\nconst list2 = [4, 5, 6]\n\ndescribe('R.concat', () => {\n  it('happy', () => {\n    const result = concat(list1, list2)\n\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = concat(list1)(list2)\n\n    result // $ExpectType number[]\n  })\n})",
    "failedRamdaSpecs": "var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('concat', function() {\n  var z1 = {\n    x: 'z1',\n    concat: function(that) { return this.x + ' ' + that.x; }\n  };\n  var z2 = {\n    x: 'z2'\n  };\n  it('delegates to non-String object with a concat method, as second param', function() {\n    eq(R.concat(z1, z2), 'z1 z2');\n  });\n});",
    "failedSpecsReasons": "Ramda method pass to `concat` property if present",
    "failedSpecsCount": 1
  },
  "cond": {
    "typing": "\ncond(conditions: [Pred, (...a: readonly any[]) => any][]): (...x: readonly any[]) => any",
    "allTypings": "cond(conditions: [Pred, (...a: readonly any[]) => any][]): (...x: readonly any[]) => any;\ncond<A, B>(conditions: [SafePred<A>, (...a: readonly A[]) => B][]): (...x: readonly A[]) => B;",
    "categories": [
      "Function"
    ],
    "rambdaSource": "export function cond(conditions){\n  return input => {\n    let done = false\n    let toReturn\n    conditions.forEach(([ predicate, resultClosure ]) => {\n      if (!done && predicate(input)){\n        done = true\n        toReturn = resultClosure(input)\n      }\n    })\n\n    return toReturn\n  }\n}",
    "rambdaSpecs": "import { always } from './always'\nimport { cond } from './cond'\nimport { equals } from './equals'\nimport { T } from './T'\n\ntest('returns a function', () => {\n  expect(typeof cond([])).toEqual('function')\n})\n\ntest('returns a conditional function', () => {\n  const fn = cond([\n    [ equals(0), always('water freezes at 0C') ],\n    [ equals(100), always('water boils at 100C') ],\n    [\n      T,\n      function (temp){\n        return 'nothing special happens at ' + temp + 'C'\n      },\n    ],\n  ])\n  expect(fn(0)).toEqual('water freezes at 0C')\n  expect(fn(50)).toEqual('nothing special happens at 50C')\n  expect(fn(100)).toEqual('water boils at 100C')\n})\n\ntest('no winner', () => {\n  const fn = cond([\n    [ equals('foo'), always(1) ],\n    [ equals('bar'), always(2) ],\n  ])\n  expect(fn('quux')).toEqual(undefined)\n})\n\ntest('predicates are tested in order', () => {\n  const fn = cond([\n    [ T, always('foo') ],\n    [ T, always('bar') ],\n    [ T, always('baz') ],\n  ])\n  expect(fn()).toEqual('foo')\n})",
    "explanation": "It takes list with `conditions` and returns a new function `fn` that expects `input` as argument. \n\nThis function will start evaluating the `conditions` in order to find the first winner(order of conditions matter). \n\nThe winner is this condition, which left side returns `true` when `input` is its argument. Then the evaluation of the right side of the winner will be the final result.\n\nIf no winner is found, then `fn` returns `undefined`.",
    "example": "const fn = R.cond([\n  [ x => x > 25, R.always('more than 25') ],\n  [ x => x > 15, R.always('more than 15') ],\n  [ R.T, x => `${x} is nothing special` ],\n])\n\nconst result = [\n  fn(30),\n  fn(20),\n  fn(10),\n] \n// => ['more than 25', 'more than 15', '10 is nothing special']",
    "typescriptDefinitionTest": "import {cond, always, equals} from 'rambda'\n\ndescribe('R.cond', () => {\n  it('happy', () => {\n    const fn = cond<number, string>([\n      [equals(0), always('water freezes at 0C')],\n      [equals(100), always('water boils at 100C')],\n      [\n        () => true,\n        function(temp) {\n          return 'nothing special happens at ' + temp + 'C'\n        },\n      ],\n    ])\n\n    const result = fn(0)\n    result // $ExpectType string\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('cond', function() {\n  it('forwards all arguments to predicates and to transformers', function() {\n    var fn = R.cond([\n      [function(_, x) { return x === 42; }, function() { return arguments.length; }]\n    ]);\n    eq(fn(21, 42, 84), 3);\n  });\n  it('retains highest predicate arity', function() {\n    var fn = R.cond([\n      [R.nAry(2, R.T), R.T],\n      [R.nAry(3, R.T), R.T],\n      [R.nAry(1, R.T), R.T]\n    ]);\n    eq(fn.length, 3);\n  });\n});",
    "failedSpecsReasons": "pass to transformer is not applied in Rambda method",
    "failedSpecsCount": 2
  },
  "converge": {
    "typing": "\nconverge(after: ((...a: any[]) => any), fns: Array<((...x: any[]) => any)>): (...y: any[]) => any",
    "allTypings": "converge(after: ((...a: any[]) => any), fns: Array<((...x: any[]) => any)>): (...y: any[]) => any;",
    "categories": [
      "Function"
    ],
    "notes": "Explanation is taken from `Ramda` documentation",
    "rambdaSource": "import { curryN } from './curryN'\nimport { map } from './map'\nimport { max } from './max'\nimport { reduce } from './reduce'\n\nexport function converge(fn, transformers){\n  if (arguments.length === 1)\n    return _transformers => converge(fn, _transformers)\n\n  const highestArity = reduce(\n    (a, b) => max(a, b.length), 0, transformers\n  )\n\n  return curryN(highestArity, function (){\n    return fn.apply(this,\n      map(g => g.apply(this, arguments), transformers))\n  })\n}",
    "rambdaSpecs": "import { add } from './add'\nimport { converge } from './converge'\nimport { multiply } from './multiply'\n\nconst f1 = converge(multiply, [ a => a + 1, a => a + 10 ])\nconst f2 = converge(multiply, [ a => a + 1, (a, b) => a + b + 10 ])\nconst f3 = converge(multiply, [ a => a + 1, (\n  a, b, c\n) => a + b + c + 10 ])\n\ntest('happy', () => {\n  expect(f2(6, 7)).toEqual(161)\n})\n\ntest('passes the results of applying the arguments individually', () => {\n  const result = converge(multiply)([ add(1), add(3) ])(2)\n  expect(result).toEqual(15)\n})\n\ntest('returns a function with the length of the longest argument', () => {\n  expect(f1.length).toEqual(1)\n  expect(f2.length).toEqual(2)\n  expect(f3.length).toEqual(3)\n})\n\ntest('passes context to its functions', () => {\n  const a = function (x){\n    return this.f1(x)\n  }\n  const b = function (x){\n    return this.f2(x)\n  }\n  const c = function (x, y){\n    return this.f3(x, y)\n  }\n  const d = converge(c, [ a, b ])\n  const context = {\n    f1 : add(1),\n    f2 : add(2),\n    f3 : add,\n  }\n  expect(a.call(context, 1)).toEqual(2)\n  expect(b.call(context, 1)).toEqual(3)\n  expect(d.call(context, 1)).toEqual(5)\n})\n\ntest('works with empty functions list', () => {\n  const fn = converge(function (){\n    return arguments.length\n  }, [])\n  expect(fn.length).toEqual(0)\n  expect(fn()).toEqual(0)\n})",
    "explanation": "Accepts a converging function and a list of branching functions and returns a new function. When invoked, this new function is applied to some arguments, each branching function is applied to those same arguments. The results of each branching function are passed as arguments to the converging function to produce the return value.",
    "example": "const result = R.converge(R.multiply)([ R.add(1), R.add(3) ])(2)\n// => 15",
    "typescriptDefinitionTest": "import {converge} from 'ramda'\n\nconst mult = (a: number, b: number) => {\n  return a * b\n}\nconst fn = converge(mult, [\n  (a: number) => {\n    return a\n  },\n  (a: number, b: number) => {\n    return b\n  },\n])\n\ndescribe('R.converge', () => {\n  it('happy', () => {\n    const result = fn(2, 3)\n    const curriedResult = fn(2)(3)\n\n    result // $ExpectType any\n    curriedResult // $ExpectType any\n  })\n})"
  },
  "curry": {
    "typing": "\ncurry(fn: (...args: any[]) => any): (...a: any[]) => any",
    "allTypings": "curry(fn: (...args: any[]) => any): (...a: any[]) => any;",
    "categories": [
      "Function"
    ],
    "rambdaSource": "export function curry(fn, args = []){\n  return (..._args) =>\n    (rest => rest.length >= fn.length ? fn(...rest) : curry(fn, rest))([\n      ...args,\n      ..._args,\n    ])\n}",
    "rambdaSpecs": "import { curry } from './curry'\n\ntest('happy', () => {\n  const addFourNumbers = (\n    a, b, c, d\n  ) => a + b + c + d\n  const curriedAddFourNumbers = curry(addFourNumbers)\n  const f = curriedAddFourNumbers(1, 2)\n  const g = f(3)\n\n  expect(g(4)).toEqual(10)\n})\n\ntest('when called with more arguments', () => {\n  const add = curry((n, n2) => n + n2)\n\n  expect(add(\n    1, 2, 3\n  )).toEqual(3)\n})\n\ntest('when called with zero arguments', () => {\n  const sub = curry((a, b) => a - b)\n  const s0 = sub()\n\n  expect(s0(5, 2)).toEqual(3)\n})\n\ntest('when called via multiple curry stages', () => {\n  const join = curry((\n    a, b, c, d\n  ) => [ a, b, c, d ].join('-'))\n\n  const stage1 = join('A')\n  const stage2 = stage1('B', 'C')\n\n  expect(stage2('D')).toEqual('A-B-C-D')\n})",
    "explanation": "It expects a function as input and returns its curried version.",
    "example": "const fn = (a, b, c) => a + b + c\nconst curried = R.curry(fn)\nconst sum = curried(1,2)\n\nconst result = sum(3) // => 6",
    "typescriptDefinitionTest": "import {curry} from 'rambda'\n\nfunction source(a: number, b: number, c: number, d: number) {\n  void d\n\n  return a * b * c\n}\n\ndescribe('R.curry', () => {\n  it('happy', () => {\n    const curried = curry(source)\n\n    const result1 = curried(1)(2)(3)\n    const result2 = curried(1, 2)(3)\n    const result3 = curried(1)(2, 3)\n    const result4 = curried(1, 2, 3)\n\n    result1 // $ExpectType any\n    result2 // $ExpectType any\n    result3 // $ExpectType any\n    result4 // $ExpectType any\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar jsv = require('jsverify');\nvar funcN = require('./shared/funcN');\n\ndescribe('curry', function() {\n  it('properly reports the length of the curried function', function() {\n    var f = R.curry(function(a, b, c, d) {return (a + b * c) / d;});\n    eq(f.length, 4);\n    var g = f(12);\n    eq(g.length, 3);\n    var h = g(3);\n    eq(h.length, 2);\n    eq(g(3, 6).length, 1);\n  });\n  it('preserves context', function() {\n    var ctx = {x: 10};\n    var f = function(a, b) { return a + b * this.x; };\n    var g = R.curry(f);\n    eq(g.call(ctx, 2, 4), 42);\n    eq(g.call(ctx, 2).call(ctx, 4), 42);\n  });\n  it('supports R.__ placeholder', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.curry(f);\n    var _ = R.__;\n    eq(g(1)(2)(3), [1, 2, 3]);\n    eq(g(1)(2, 3), [1, 2, 3]);\n    eq(g(1, 2)(3), [1, 2, 3]);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(_, 2, 3)(1), [1, 2, 3]);\n    eq(g(1, _, 3)(2), [1, 2, 3]);\n    eq(g(1, 2, _)(3), [1, 2, 3]);\n    eq(g(1, _, _)(2)(3), [1, 2, 3]);\n    eq(g(_, 2, _)(1)(3), [1, 2, 3]);\n    eq(g(_, _, 3)(1)(2), [1, 2, 3]);\n    eq(g(1, _, _)(2, 3), [1, 2, 3]);\n    eq(g(_, 2, _)(1, 3), [1, 2, 3]);\n    eq(g(_, _, 3)(1, 2), [1, 2, 3]);\n    eq(g(1, _, _)(_, 3)(2), [1, 2, 3]);\n    eq(g(_, 2, _)(_, 3)(1), [1, 2, 3]);\n    eq(g(_, _, 3)(_, 2)(1), [1, 2, 3]);\n    eq(g(_, _, _)(_, _)(_)(1, 2, 3), [1, 2, 3]);\n    eq(g(_, _, _)(1, _, _)(_, _)(2, _)(_)(3), [1, 2, 3]);\n  });\n  it('supports @@functional/placeholder', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.curry(f);\n    var _ = {'@@functional/placeholder': true, x: Math.random()};\n    eq(g(1)(2)(3), [1, 2, 3]);\n    eq(g(1)(2, 3), [1, 2, 3]);\n    eq(g(1, 2)(3), [1, 2, 3]);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(_, 2, 3)(1), [1, 2, 3]);\n    eq(g(1, _, 3)(2), [1, 2, 3]);\n    eq(g(1, 2, _)(3), [1, 2, 3]);\n    eq(g(1, _, _)(2)(3), [1, 2, 3]);\n    eq(g(_, 2, _)(1)(3), [1, 2, 3]);\n    eq(g(_, _, 3)(1)(2), [1, 2, 3]);\n    eq(g(1, _, _)(2, 3), [1, 2, 3]);\n    eq(g(_, 2, _)(1, 3), [1, 2, 3]);\n    eq(g(_, _, 3)(1, 2), [1, 2, 3]);\n    eq(g(1, _, _)(_, 3)(2), [1, 2, 3]);\n    eq(g(_, 2, _)(_, 3)(1), [1, 2, 3]);\n    eq(g(_, _, 3)(_, 2)(1), [1, 2, 3]);\n    eq(g(_, _, _)(_, _)(_)(1, 2, 3), [1, 2, 3]);\n    eq(g(_, _, _)(1, _, _)(_, _)(2, _)(_)(3), [1, 2, 3]);\n  });\n});\ndescribe('curry properties', function() {\n  jsv.property('curries multiple values', funcN(4), jsv.json, jsv.json, jsv.json, jsv.json, function(f, a, b, c, d) {\n    var g = R.curry(f);\n    return R.all(R.equals(f(a, b, c, d)), [\n      g(a, b, c, d),\n      g(a)(b)(c)(d),\n      g(a)(b, c, d),\n      g(a, b)(c, d),\n      g(a, b, c)(d)\n    ]);\n  jsv.property('curries with placeholder', funcN(3), jsv.json, jsv.json, jsv.json, function(f, a, b, c) {\n    var _ = {'@@functional/placeholder': true, x: Math.random()};\n    var g = R.curry(f);\n    return R.all(R.equals(f(a, b, c)), [\n      g(_, _, c)(a, b),\n      g(a, _, c)(b),\n      g(_, b, c)(a),\n      g(a, _, _)(_, c)(b),\n      g(a, b, _)(c)\n    ]);\n});",
    "failedSpecsReasons": "Ramda library support placeholder(R.__)",
    "failedSpecsCount": 3
  },
  "curryN": {
    "typing": "\ncurryN(length: number, fn: (...args: readonly any[]) => any): (...a: readonly any[]) => any",
    "allTypings": "curryN(length: number, fn: (...args: readonly any[]) => any): (...a: readonly any[]) => any;",
    "categories": [
      "Function"
    ],
    "rambdaSource": "function _curryN(\n  n, cache, fn\n){\n  return function (){\n    let ci = 0\n    let ai = 0\n    const cl = cache.length\n    const al = arguments.length\n    const args = new Array(cl + al)\n    while (ci < cl){\n      args[ ci ] = cache[ ci ]\n      ci++\n    }\n    while (ai < al){\n      args[ cl + ai ] = arguments[ ai ]\n      ai++\n    }\n    const remaining = n - args.length\n\n    return args.length >= n ?\n      fn.apply(this, args) :\n      _arity(remaining, _curryN(\n        n, args, fn\n      ))\n  }\n}\n\nfunction _arity(n, fn){\n  switch (n){\n  case 0:\n    return function (){\n      return fn.apply(this, arguments)\n    }\n  case 1:\n    return function (_1){\n      return fn.apply(this, arguments)\n    }\n  case 2:\n    return function (_1, _2){\n      return fn.apply(this, arguments)\n    }\n  case 3:\n    return function (\n      _1, _2, _3\n    ){\n      return fn.apply(this, arguments)\n    }\n  case 4:\n    return function (\n      _1, _2, _3, _4\n    ){\n      return fn.apply(this, arguments)\n    }\n  case 5:\n    return function (\n      _1, _2, _3, _4, _5\n    ){\n      return fn.apply(this, arguments)\n    }\n  case 6:\n    return function (\n      _1, _2, _3, _4, _5, _6\n    ){\n      return fn.apply(this, arguments)\n    }\n  case 7:\n    return function (\n      _1, _2, _3, _4, _5, _6, _7\n    ){\n      return fn.apply(this, arguments)\n    }\n  case 8:\n    return function (\n      _1, _2, _3, _4, _5, _6, _7, _8\n    ){\n      return fn.apply(this, arguments)\n    }\n  case 9:\n    return function (\n      _1, _2, _3, _4, _5, _6, _7, _8, _9\n    ){\n      return fn.apply(this, arguments)\n    }\n  case 10:\n    return function (\n      _1, _2, _3, _4, _5, _6, _7, _8, _9, _10\n    ){\n      return fn.apply(this, arguments)\n    }\n  default:\n    throw new Error('First argument to _arity must be a non-negative integer no greater than ten')\n  }\n}\n\nexport function curryN(n, fn){\n  if (arguments.length === 1) return _fn => curryN(n, _fn)\n\n  return _arity(n, _curryN(\n    n, [], fn\n  ))\n}",
    "rambdaSpecs": "import { curryN } from './curryN'\n\nfunction source(\n  a, b, c, d\n){\n  void d\n\n  return a * b * c\n}\n\ntest('accepts an arity', () => {\n  const curried = curryN(3, source)\n  expect(curried(1)(2)(3)).toEqual(6)\n  expect(curried(1, 2)(3)).toEqual(6)\n  expect(curried(1)(2, 3)).toEqual(6)\n  expect(curried(\n    1, 2, 3\n  )).toEqual(6)\n})\n\ntest('can be partially applied', () => {\n  const curry3 = curryN(3)\n  const curried = curry3(source)\n  expect(curried.length).toEqual(3)\n  expect(curried(1)(2)(3)).toEqual(6)\n  expect(curried(1, 2)(3)).toEqual(6)\n  expect(curried(1)(2, 3)).toEqual(6)\n  expect(curried(\n    1, 2, 3\n  )).toEqual(6)\n})\n\ntest('preserves context', () => {\n  const ctx = { x : 10 }\n  const f = function (a, b){\n    return a + b * this.x\n  }\n  const g = curryN(2, f)\n\n  expect(g.call(\n    ctx, 2, 4\n  )).toEqual(42)\n  expect(g.call(ctx, 2).call(ctx, 4)).toEqual(42)\n})\n\ntest('forwards extra arguments', () => {\n  const f = function (){\n    return Array.prototype.slice.call(arguments)\n  }\n  const g = curryN(3, f)\n\n  expect(g(\n    1, 2, 3\n  )).toEqual([ 1, 2, 3 ])\n  expect(g(\n    1, 2, 3, 4\n  )).toEqual([ 1, 2, 3, 4 ])\n  expect(g(1, 2)(3, 4)).toEqual([ 1, 2, 3, 4 ])\n  expect(g(1)(\n    2, 3, 4\n  )).toEqual([ 1, 2, 3, 4 ])\n  expect(g(1)(2)(3, 4)).toEqual([ 1, 2, 3, 4 ])\n})",
    "explanation": "It returns a curried equivalent of the provided function, with the specified arity.",
    "typescriptDefinitionTest": "import {curryN} from 'ramda'\n\nfunction source(a: number, b: number, c: number, d: number) {\n  void d\n\n  return a * b * c\n}\n\ndescribe('R.curryN', () => {\n  it('happy', () => {\n    const curried = curryN(3, source)\n\n    const result1 = curried(1)(2)(3)\n    const result2 = curried(1, 2)(3)\n    const result3 = curried(1)(2, 3)\n    const result4 = curried(1, 2, 3)\n\n    result1 // $ExpectType any\n    result2 // $ExpectType any\n    result3 // $ExpectType any\n    result4 // $ExpectType any\n  })\n})"
  },
  "dec": {
    "typing": "\ndec(x: number): number",
    "allTypings": "dec(x: number): number;",
    "categories": [
      "Number"
    ],
    "rambdaSource": "export const dec = x => x - 1",
    "rambdaSpecs": "import { dec } from './dec'\n\ntest('happy', () => {\n  expect(dec(2)).toBe(1)\n})",
    "explanation": "It decrements a number."
  },
  "defaultTo": {
    "typing": "\ndefaultTo<T>(defaultValue: T): (...inputArguments: (T | null | undefined)[]) => T",
    "allTypings": "defaultTo<T>(defaultValue: T): (...inputArguments: (T | null | undefined)[]) => T;\ndefaultTo<T>(defaultValue: T, ...inputArguments: (T | null | undefined)[]): T;\ndefaultTo<T, U>(defaultValue: T | U, ...inputArguments: (T | U | null | undefined)[]): T | U;",
    "categories": [
      "Logic"
    ],
    "notes": "Rambda's **defaultTo** accept indefinite number of arguments when non curried, i.e. `R.defaultTo(2, foo, bar, baz)`.",
    "rambdaSource": "function flagIs(inputArguments){\n  return (\n    inputArguments === undefined ||\n    inputArguments === null ||\n    Number.isNaN(inputArguments) === true\n  )\n}\n\nexport function defaultTo(defaultArgument, ...inputArguments){\n  if (arguments.length === 1){\n    return (..._inputArguments) =>\n      defaultTo(defaultArgument, ..._inputArguments)\n  }\n\n  const limit = inputArguments.length - 1\n  let len = limit + 1\n  let ready = false\n  let holder\n\n  while (!ready){\n    const instance = inputArguments[ limit - len + 1 ]\n\n    if (len === 0){\n      ready = true\n    } else if (flagIs(instance)){\n      len -= 1\n    } else {\n      holder = instance\n      ready = true\n    }\n  }\n\n  return holder === undefined ? defaultArgument : holder\n}",
    "rambdaSpecs": "import { defaultTo } from './defaultTo'\n\ntest('with undefined', () => {\n  expect(defaultTo('foo')(undefined)).toEqual('foo')\n})\n\ntest('with null', () => {\n  expect(defaultTo('foo')(null)).toEqual('foo')\n})\n\ntest('with NaN', () => {\n  expect(defaultTo('foo')(NaN)).toEqual('foo')\n})\n\ntest('with empty string', () => {\n  expect(defaultTo('foo', '')).toEqual('')\n})\n\ntest('with false', () => {\n  expect(defaultTo('foo', false)).toEqual(false)\n})\n\ntest('when inputArgument passes initial check', () => {\n  expect(defaultTo('foo', 'bar')).toEqual('bar')\n})\n\ntest('default extends to indefinite input arguments - case 1', () => {\n  const result = defaultTo(\n    'foo', null, 'bar'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 2', () => {\n  const result = defaultTo(\n    'foo', null, NaN, 'bar'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 3', () => {\n  const result = defaultTo(\n    'foo', null, NaN, undefined\n  )\n  const expected = 'foo'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 4', () => {\n  const result = defaultTo(\n    'foo', null, NaN, undefined, 'bar'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 5', () => {\n  const result = defaultTo(\n    'foo', null, NaN, 'bar', 'baz'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 6', () => {\n  const result = defaultTo(\n    'foo', null, NaN, undefined, null, NaN\n  )\n  const expected = 'foo'\n\n  expect(result).toEqual(expected)\n})",
    "explanation": "It returns `defaultValue`, if all of `inputArguments` are `undefined`, `null` or `NaN`.\n\nElse, it returns the first truthy `inputArguments` instance(from left to right).",
    "example": "// With single input argument\nR.defaultTo('foo', 'bar') // => 'bar'\nR.defaultTo('foo', undefined) // => 'foo'\n\n// With multiple input arguments\nR.defaultTo('foo', undefined, null, NaN) // => 'foo'\nR.defaultTo('foo', undefined, 'bar', NaN, 'qux') // => 'bar'\nR.defaultTo('foo', undefined, null, NaN, 'quz') // => 'qux'",
    "typescriptDefinitionTest": "import {defaultTo} from 'rambda'\n\ndescribe('R.defaultTo with Ramda spec', () => {\n  it('input is falsy', () => {\n    const result = defaultTo('foo', undefined)\n    result // $ExpectType \"foo\"\n  })\n  it('input is truthy', () => {\n    const result = defaultTo('foo', 'bar')\n    result // $ExpectType \"foo\" | \"bar\"\n  })\n})\n\ndescribe('R.defaultTo can have many inputs', () => {\n  it('happy', () => {\n    const result = defaultTo('foo', undefined, 'bar')\n    result // $ExpectType \"foo\" | \"bar\"\n  })\n\n  it('curried', () => {\n    const result = defaultTo('foo')(undefined, 'bar')\n    result // $ExpectType string\n  })\n\n  it('with two possible types', () => {\n    const result = defaultTo<string, number>(\n      'foo',\n      undefined,\n      1,\n      null,\n      2,\n      'bar'\n    )\n    result // $ExpectType string | number\n  })\n})"
  },
  "difference": {
    "typing": "\ndifference<T>(a: readonly T[], b: readonly T[]): T[]",
    "allTypings": "difference<T>(a: readonly T[], b: readonly T[]): T[];\ndifference<T>(a: readonly T[]): (b: readonly T[]) => T[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { includes } from './includes'\nimport { uniq } from './uniq'\n\nexport function difference(a, b){\n  if (arguments.length === 1) return _b => difference(a, _b)\n\n  return uniq(a).filter(aInstance => !includes(aInstance, b))\n}",
    "rambdaSpecs": "import { difference } from './difference'\n\ntest('difference', () => {\n  const a = [ 1, 2, 3, 4 ]\n  const b = [ 3, 4, 5, 6 ]\n  expect(difference(a)(b)).toEqual([ 1, 2 ])\n\n  expect(difference([], [])).toEqual([])\n})\n\ntest('difference with objects', () => {\n  const a = [ { id : 1 }, { id : 2 }, { id : 3 }, { id : 4 } ]\n  const b = [ { id : 3 }, { id : 4 }, { id : 5 }, { id : 6 } ]\n  expect(difference(a, b)).toEqual([ { id : 1 }, { id : 2 } ])\n})\n\ntest('no duplicates in first list', () => {\n  const M2 = [ 1, 2, 3, 4, 1, 2, 3, 4 ]\n  const N2 = [ 3, 3, 4, 4, 5, 5, 6, 6 ]\n  expect(difference(M2, N2)).toEqual([ 1, 2 ])\n})\n\ntest('should use R.equals', () => {\n  expect(difference([ NaN ], [ NaN ]).length).toEqual(0)\n})",
    "explanation": "It returns the uniq set of all elements in the first list `a` not contained in the second list `b`.",
    "example": "const a = [ 1, 2, 3, 4 ]\nconst b = [ 3, 4, 5, 6 ]\n\nconst result = difference(a, b)\n// => [ 1, 2 ]",
    "typescriptDefinitionTest": "import {difference} from 'rambda'\n\nconst list1 = [1, 2, 3]\nconst list2 = [1, 2, 4]\n\ndescribe('R.difference', () => {\n  it('happy', () => {\n    const result = difference(list1, list2)\n\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = difference(list1)(list2)\n\n    result // $ExpectType number[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('difference', function() {\n  var M = [1, 2, 3, 4];\n  var M2 = [1, 2, 3, 4, 1, 2, 3, 4];\n  var N = [3, 4, 5, 6];\n  var N2 = [3, 3, 4, 4, 5, 5, 6, 6];\n  var Z = [3, 4, 5, 6, 10];\n  var Z2 = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8];\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.difference([0], [-0]).length, 1);\n    eq(R.difference([-0], [0]).length, 1);\n    eq(R.difference([NaN], [NaN]).length, 0);\n    eq(R.difference([new Just([42])], [new Just([42])]).length, 0);\n  });\n});"
  },
  "dissoc": {
    "typing": "\ndissoc<T>(prop: string, obj: any): T",
    "allTypings": "dissoc<T>(prop: string, obj: any): T;\ndissoc<T>(prop: string): (obj: any) => T;",
    "categories": [
      "Object"
    ],
    "rambdaSource": "export function dissoc(prop, obj){\n  if (arguments.length === 1) return _obj => dissoc(prop, _obj)\n\n  if (obj === null || obj === undefined) return {}\n\n  const willReturn = {}\n  for (const p in obj){\n    willReturn[ p ] = obj[ p ]\n  }\n  delete willReturn[ prop ]\n\n  return willReturn\n}",
    "rambdaSpecs": "import { dissoc } from './dissoc'\n\ntest('input is null or undefined', () => {\n  expect(dissoc('b', null)).toEqual({})\n  expect(dissoc('b', undefined)).toEqual({})\n})\n\ntest('property exists curried', () => {\n  expect(dissoc('b')({\n    a : 1,\n    b : 2,\n  })).toEqual({ a : 1 })\n})\n\ntest('property doesn\\'t exists', () => {\n  expect(dissoc('c', {\n    a : 1,\n    b : 2,\n  })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('works with non-string property', () => {\n  expect(dissoc(42, {\n    a  : 1,\n    42 : 2,\n  })).toEqual({ a : 1 })\n\n  expect(dissoc(null, {\n    a    : 1,\n    null : 2,\n  })).toEqual({ a : 1 })\n\n  expect(dissoc(undefined, {\n    a         : 1,\n    undefined : 2,\n  })).toEqual({ a : 1 })\n})\n\ntest('includes prototype properties', () => {\n  function Rectangle(width, height){\n    this.width = width\n    this.height = height\n  }\n  const area = Rectangle.prototype.area = function (){\n    return this.width * this.height\n  }\n  const rect = new Rectangle(7, 6)\n\n  expect(dissoc('area', rect)).toEqual({\n    width  : 7,\n    height : 6,\n  })\n\n  expect(dissoc('width', rect)).toEqual({\n    height : 6,\n    area   : area,\n  })\n\n  expect(dissoc('depth', rect)).toEqual({\n    width  : 7,\n    height : 6,\n    area   : area,\n  })\n})",
    "explanation": "It returns a new object that does not contain property `prop`.",
    "example": "R.dissoc('b', {a: 1, b: 2, c: 3})\n//=> {a: 1, c: 3}",
    "typescriptDefinitionTest": "import {dissoc, pipe, identity} from 'rambda'\n\nconst obj = {\n  a: 1,\n  b: 2,\n}\ninterface Output {\n  a: string,\n}\n\ndescribe('R.dissoc', () => {\n  it('happy', () => {\n    const result = dissoc<Output>('b', obj)\n\n    result // $ExpectType Output\n  })\n  it('curried', () => {\n    const result = dissoc<Output>('b')(obj)\n\n    result // $ExpectType Output\n  })\n  it('within R.pipe', () => {\n    const result = pipe<object, object, Output>(identity, dissoc('b'))(obj)\n\n    result // $ExpectType Output\n  })\n})"
  },
  "divide": {
    "typing": "\ndivide(x: number, y: number): number",
    "allTypings": "divide(x: number, y: number): number;\ndivide(x: number): (y: number) => number;",
    "categories": [
      "Number"
    ],
    "rambdaSource": "export function divide(a, b){\n  if (arguments.length === 1) return _b => divide(a, _b)\n\n  return a / b\n}",
    "rambdaSpecs": "import { divide } from './divide'\n\ntest('happy', () => {\n  expect(divide(71, 100)).toEqual(0.71)\n  expect(divide(71)(100)).toEqual(0.71)\n})",
    "example": "R.divide(71, 100) // => 0.71"
  },
  "drop": {
    "typing": "\ndrop<T>(howMany: number, input: readonly T[]): T[]",
    "allTypings": "drop<T>(howMany: number, input: readonly T[]): T[];\ndrop(howMany: number, input: string): string;\ndrop<T>(howMany: number): {\n  <T>(input: readonly T[]): T[];\n  (input: string): string;\n};",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "export function drop(howManyToDrop, listOrString){\n  if (arguments.length === 1) return _list => drop(howManyToDrop, _list)\n\n  return listOrString.slice(howManyToDrop > 0 ? howManyToDrop : 0)\n}",
    "rambdaSpecs": "import assert from 'assert'\n\nimport { drop } from './drop'\n\ntest('with array', () => {\n  expect(drop(2)([ 'foo', 'bar', 'baz' ])).toEqual([ 'baz' ])\n  expect(drop(3, [ 'foo', 'bar', 'baz' ])).toEqual([])\n  expect(drop(4, [ 'foo', 'bar', 'baz' ])).toEqual([])\n})\n\ntest('with string', () => {\n  expect(drop(3, 'rambda')).toEqual('bda')\n})\n\ntest('with non-positive count', () => {\n  expect(drop(0, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(drop(-1, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(drop(-Infinity, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('should return copy', () => {\n  const xs = [ 1, 2, 3 ]\n\n  assert.notStrictEqual(drop(0, xs), xs)\n  assert.notStrictEqual(drop(-1, xs), xs)\n})",
    "explanation": "It returns `howMany` items dropped from beginning of list or string `input`.",
    "example": "R.drop(2, ['foo', 'bar', 'baz']) // => ['baz']\nR.drop(2, 'foobar')  // => 'obar'",
    "typescriptDefinitionTest": "import {drop} from 'rambda'\n\nconst list = [1, 2, 3, 4]\nconst str = 'foobar'\nconst howMany = 2\n\ndescribe('R.drop - array', () => {\n  it('happy', () => {\n    const result = drop(howMany, list)\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = drop(howMany)(list)\n    result // $ExpectType number[]\n  })\n})\n\ndescribe('R.drop - string', () => {\n  it('happy', () => {\n    const result = drop(howMany, str)\n    result // $ExpectType string\n  })\n  it('curried', () => {\n    const result = drop(howMany)(str)\n    result // $ExpectType string\n  })\n})"
  },
  "dropLast": {
    "typing": "\ndropLast<T>(howMany: number, input: readonly T[]): T[]",
    "allTypings": "dropLast<T>(howMany: number, input: readonly T[]): T[];\ndropLast(howMany: number, input: string): string;\ndropLast<T>(howMany: number): {\n  <T>(input: readonly T[]): T[];\n  (input: string): string;\n};",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "export function dropLast(howManyToDrop, listOrString){\n  if (arguments.length === 1){\n    return _listOrString => dropLast(howManyToDrop, _listOrString)\n  }\n\n  return howManyToDrop > 0 ?\n    listOrString.slice(0, -howManyToDrop) :\n    listOrString.slice()\n}",
    "rambdaSpecs": "import assert from 'assert'\n\nimport { dropLast } from './dropLast'\n\ntest('with array', () => {\n  expect(dropLast(2)([ 'foo', 'bar', 'baz' ])).toEqual([ 'foo' ])\n  expect(dropLast(3, [ 'foo', 'bar', 'baz' ])).toEqual([])\n  expect(dropLast(4, [ 'foo', 'bar', 'baz' ])).toEqual([])\n})\n\ntest('with string', () => {\n  expect(dropLast(3, 'rambda')).toEqual('ram')\n})\n\ntest('with non-positive count', () => {\n  expect(dropLast(0, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(dropLast(-1, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(dropLast(-Infinity, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('should return copy', () => {\n  const xs = [ 1, 2, 3 ]\n\n  assert.notStrictEqual(dropLast(0, xs), xs)\n  assert.notStrictEqual(dropLast(-1, xs), xs)\n})",
    "explanation": "It returns `howMany` items dropped from the end of list or string `input`.",
    "example": "R.dropLast(2, ['foo', 'bar', 'baz']) // => ['foo']\nR.dropLast(2, 'foobar')  // => 'foob'",
    "typescriptDefinitionTest": "import {dropLast} from 'rambda'\n\nconst list = [1, 2, 3, 4]\nconst str = 'foobar'\nconst howMany = 2\n\ndescribe('R.dropLast - array', () => {\n  it('happy', () => {\n    const result = dropLast(howMany, list)\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = dropLast(howMany)(list)\n    result // $ExpectType number[]\n  })\n})\n\ndescribe('R.dropLast - string', () => {\n  it('happy', () => {\n    const result = dropLast(howMany, str)\n    result // $ExpectType string\n  })\n  it('curried', () => {\n    const result = dropLast(howMany)(str)\n    result // $ExpectType string\n  })\n})",
    "failedRamdaSpecs": "var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('dropLast', function() {\n  it('can act as a transducer', function() {\n    var dropLast2 = R.dropLast(2);\n    assert.deepEqual(R.into([], dropLast2, [1, 3, 5, 7, 9, 1, 2]), [1, 3, 5, 7, 9]);\n    assert.deepEqual(R.into([], dropLast2, [1]), []);\n  });\n});",
    "failedSpecsReasons": "Ramda method can act as a transducer",
    "failedSpecsCount": 5
  },
  "either": {
    "typing": "\neither(firstPredicate: Pred, secondPredicate: Pred): Pred",
    "allTypings": "either(firstPredicate: Pred, secondPredicate: Pred): Pred;\neither<T>(firstPredicate: Predicate<T>, secondPredicate: Predicate<T>): Predicate<T>;\neither<T>(firstPredicate: Predicate<T>): (secondPredicate: Predicate<T>) => Predicate<T>;\neither(firstPredicate: Pred): (secondPredicate: Pred) => Pred;",
    "categories": [
      "Function"
    ],
    "rambdaSource": "export function either(firstPredicate, secondPredicate){\n  if (arguments.length === 1){\n    return _secondPredicate => either(firstPredicate, _secondPredicate)\n  }\n\n  return (...input) =>\n    Boolean(firstPredicate(...input) || secondPredicate(...input))\n}",
    "rambdaSpecs": "import { either } from './either'\n\ntest('with multiple inputs', () => {\n  const between = function (\n    a, b, c\n  ){\n    return a < b && b < c\n  }\n  const total20 = function (\n    a, b, c\n  ){\n    return a + b + c === 20\n  }\n  const fn = either(between, total20)\n  expect(fn(\n    7, 8, 5\n  )).toBeTrue()\n})\n\ntest('skip evaluation of the second expression', () => {\n  let effect = 'not evaluated'\n  const F = function (){\n    return true\n  }\n  const Z = function (){\n    effect = 'Z got evaluated'\n  }\n  either(F, Z)()\n\n  expect(effect).toBe('not evaluated')\n})\n\ntest('case 1', () => {\n  const firstFn = val => val > 0\n  const secondFn = val => val * 5 > 10\n\n  expect(either(firstFn, secondFn)(1)).toBeTrue()\n})\n\ntest('case 2', () => {\n  const firstFn = val => val > 0\n  const secondFn = val => val === -10\n  const fn = either(firstFn)(secondFn)\n\n  expect(fn(-10)).toBeTrue()\n})",
    "explanation": "It returns a new `predicate` function from `firstPredicate` and `secondPredicate` inputs.\n\nThis `predicate` function will return `true`, if any of the two input predicates return `true`.",
    "example": "const firstPredicate = x => x > 10\nconst secondPredicate = x => x % 2 === 0\nconst predicate = R.either(firstPredicate, secondPredicate)\n\nconst result = [\n  predicate(15),\n  predicate(8),\n  predicate(7),\n]\n//=> [true, true, false]",
    "typescriptDefinitionTest": "import {either} from 'rambda'\n\ndescribe('R.either', () => {\n  it('with passed type', () => {\n    const fn = either<number>(\n      x => x > 1,\n      x => x % 2 === 0\n    )\n    fn // $ExpectType Predicate<number>\n    const result = fn(2) // $ExpectType boolean\n    result // $ExpectType boolean\n  })\n  it('with passed type - curried', () => {\n    const fn = either<number>(x => x > 1)(x => x % 2 === 0)\n    fn // $ExpectType Predicate<number>\n    const result = fn(2)\n    result // $ExpectType boolean\n  })\n  it('no type passed', () => {\n    const fn = either(\n      x => {\n        x // $ExpectType any\n        return x > 1\n      },\n      x => {\n        x // $ExpectType any\n        return x % 2 === 0\n      }\n    )\n    const result = fn(2)\n    result // $ExpectType boolean\n  })\n  it('no type passed - curried', () => {\n    const fn = either((x: number) => {\n      x // $ExpectType number\n      return x > 1\n    })((x: number) => {\n      x // $ExpectType number\n      return x % 2 === 0\n    })\n    const result = fn(2)\n    result // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var S = require('sanctuary');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('either', function() {\n  it('accepts fantasy-land applicative functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.either(Just(true), Just(true)), Just(true));\n    eq(R.either(Just(true), Just(false)), Just(true));\n    eq(R.either(Just(false), Just(false)), Just(false));\n    eq(R.either(Just(true), Nothing()), Nothing());\n    eq(R.either(Nothing(), Just(false)), Nothing());\n    eq(R.either(Nothing(), Nothing()), Nothing());\n  });\n});",
    "failedSpecsReasons": "Ramda library supports fantasy-land",
    "failedSpecsCount": 1
  },
  "endsWith": {
    "typing": "\nendsWith(target: string, str: string): boolean",
    "allTypings": "endsWith(target: string, str: string): boolean;\nendsWith(target: string): (str: string) => boolean;",
    "categories": [
      "String"
    ],
    "notes": "It doesn't work with arrays unlike its corresponding **Ramda** method.",
    "rambdaSource": "export function endsWith(target, str){\n  if (arguments.length === 1) return _str => endsWith(target, _str)\n\n  return str.endsWith(target)\n}",
    "rambdaSpecs": "import { endsWith } from './endsWith'\n\ntest('happy', () => {\n  expect(endsWith('bar', 'foo-bar')).toBeTrue()\n  expect(endsWith('baz')('foo-bar')).toBeFalse()\n})\n\ntest('does not work with arrays', () => {\n  expect(() => endsWith([ 'c' ], [ 'a', 'b', 'c' ])).toThrowWithMessage(Error,\n    'str.endsWith is not a function')\n})",
    "explanation": "Curried version of `String.prototype.endsWith`",
    "example": "const str = 'foo-bar'\nconst target = '-bar'\n\nconst result = R.endsWith(target, str)\n// => true",
    "typescriptDefinitionTest": "import {endsWith} from 'rambda'\n\nconst target = 'foo'\nconst input = 'foo bar'\n\ndescribe('R.endsWith', () => {\n  it('happy', () => {\n    const result = endsWith(target, input)\n\n    result // $ExpectType boolean\n  })\n  it('curried', () => {\n    const result = endsWith(target)(input)\n\n    result // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('startsWith', function() {\n  it('should return true when an array ends with the provided value', function() {\n    eq(R.endsWith(['c'], ['a', 'b', 'c']), true);\n  });\n  it('should return true when an array ends with the provided values', function() {\n    eq(R.endsWith(['b', 'c'], ['a', 'b', 'c']), true);\n  });\n  it('should return false when an array does not end with the provided value', function() {\n    eq(R.endsWith(['b'], ['a', 'b', 'c']), false);\n  });\n  it('should return false when an array does not end with the provided values', function() {\n    eq(R.endsWith(['a', 'b'], ['a', 'b', 'c']), false);\n  });\n});",
    "failedSpecsReasons": "Rambda method doesn't support arrays",
    "failedSpecsCount": 4
  },
  "equals": {
    "typing": "\nequals<T>(x: T, y: T): boolean",
    "allTypings": "equals<T>(x: T, y: T): boolean;\nequals<T>(x: T): (y: T) => boolean;",
    "categories": [
      "Logic"
    ],
    "notes": "It doesn't handle cyclical data structures and functions",
    "rambdaSource": "import { type } from './type'\n\nfunction parseError(maybeError){\n  const typeofError = maybeError.__proto__.toString()\n  if (![ 'Error', 'TypeError' ].includes(typeofError)) return []\n\n  return [ typeofError, maybeError.message ]\n}\n\nfunction parseDate(maybeDate){\n  if (!maybeDate.toDateString) return [ false ]\n\n  return [ true, maybeDate.getTime() ]\n}\n\nfunction parseRegex(maybeRegex){\n  if (maybeRegex.constructor !== RegExp) return [ false ]\n\n  return [ true, maybeRegex.toString() ]\n}\n\nexport function equals(a, b){\n  if (arguments.length === 1) return _b => equals(a, _b)\n\n  const aType = type(a)\n  if (aType !== type(b)) return false\n  if ([ 'NaN', 'Undefined', 'Null' ].includes(aType)) return true\n\n  if (aType === 'Number'){\n    if (Object.is(-0, a) !== Object.is(-0, b)) return false\n\n    return a.toString() === b.toString()\n  }\n\n  if ([ 'String', 'Boolean' ].includes(aType)){\n    return a.toString() === b.toString()\n  }\n\n  if (aType === 'Array'){\n    const aClone = Array.from(a)\n    const bClone = Array.from(b)\n\n    if (aClone.toString() !== bClone.toString()){\n      return false\n    }\n\n    let loopArrayFlag = true\n    aClone.forEach((aCloneInstance, aCloneIndex) => {\n      if (loopArrayFlag){\n        if (\n          aCloneInstance !== bClone[ aCloneIndex ] &&\n          !equals(aCloneInstance, bClone[ aCloneIndex ])\n        ){\n          loopArrayFlag = false\n        }\n      }\n    })\n\n    return loopArrayFlag\n  }\n\n  const aRegex = parseRegex(a)\n  const bRegex = parseRegex(b)\n\n  if (aRegex[ 0 ]){\n    return bRegex[ 0 ] ? aRegex[ 1 ] === bRegex[ 1 ] : false\n  } else if (bRegex[ 0 ]) return false\n\n  const aDate = parseDate(a)\n  const bDate = parseDate(b)\n\n  if (aDate[ 0 ]){\n    return bDate[ 0 ] ? aDate[ 1 ] === bDate[ 1 ] : false\n  } else if (bDate[ 0 ]) return false\n\n  const aError = parseError(a)\n  const bError = parseError(b)\n\n  if (aError[ 0 ]){\n    return bError[ 0 ] ?\n      aError[ 0 ] === bError[ 0 ] && aError[ 1 ] === bError[ 1 ] :\n      false\n  }\n\n  if (aType === 'Object'){\n    const aKeys = Object.keys(a)\n\n    if (aKeys.length !== Object.keys(b).length){\n      return false\n    }\n\n    let loopObjectFlag = true\n    aKeys.forEach(aKeyInstance => {\n      if (loopObjectFlag){\n        const aValue = a[ aKeyInstance ]\n        const bValue = b[ aKeyInstance ]\n\n        if (aValue !== bValue && !equals(aValue, bValue)){\n          loopObjectFlag = false\n        }\n      }\n    })\n\n    return loopObjectFlag\n  }\n\n  return false\n}",
    "rambdaSpecs": "// import { equals } from 'ramda'\nimport { equals } from './equals'\n\ntest('with array of objects', () => {\n  const list1 = [ { a : 1 }, [ { b : 2 } ] ]\n  const list2 = [ { a : 1 }, [ { b : 2 } ] ]\n  const list3 = [ { a : 1 }, [ { b : 3 } ] ]\n\n  expect(equals(list1, list2)).toBeTrue()\n  expect(equals(list1, list3)).toBeFalse()\n})\n\ntest('with regex', () => {\n  expect(equals(/s/, /s/)).toEqual(true)\n  expect(equals(/s/, /d/)).toEqual(false)\n  expect(equals(/a/gi, /a/gi)).toEqual(true)\n  expect(equals(/a/gim, /a/gim)).toEqual(true)\n  expect(equals(/a/gi, /a/i)).toEqual(false)\n})\n\ntest('not a number', () => {\n  expect(equals([ NaN ], [ NaN ])).toBeTrue()\n})\n\ntest('new number', () => {\n  expect(equals(new Number(0), new Number(0))).toEqual(true)\n  expect(equals(new Number(0), new Number(1))).toEqual(false)\n  expect(equals(new Number(1), new Number(0))).toEqual(false)\n})\n\ntest('new string', () => {\n  expect(equals(new String(''), new String(''))).toEqual(true)\n  expect(equals(new String(''), new String('x'))).toEqual(false)\n  expect(equals(new String('x'), new String(''))).toEqual(false)\n  expect(equals(new String('foo'), new String('foo'))).toEqual(true)\n  expect(equals(new String('foo'), new String('bar'))).toEqual(false)\n  expect(equals(new String('bar'), new String('foo'))).toEqual(false)\n})\n\ntest('new Boolean', () => {\n  expect(equals(new Boolean(true), new Boolean(true))).toEqual(true)\n  expect(equals(new Boolean(false), new Boolean(false))).toEqual(true)\n  expect(equals(new Boolean(true), new Boolean(false))).toEqual(false)\n  expect(equals(new Boolean(false), new Boolean(true))).toEqual(false)\n})\n\ntest('new Error', () => {\n  expect(equals(new Error('XXX'), {})).toEqual(false)\n  expect(equals(new Error('XXX'), new TypeError('XXX'))).toEqual(false)\n  expect(equals(new Error('XXX'), new Error('YYY'))).toEqual(false)\n  expect(equals(new Error('XXX'), new Error('XXX'))).toEqual(true)\n  expect(equals(new Error('XXX'), new TypeError('YYY'))).toEqual(false)\n})\n\ntest('with dates', () => {\n  expect(equals(new Date(0), new Date(0))).toEqual(true)\n  expect(equals(new Date(1), new Date(1))).toEqual(true)\n  expect(equals(new Date(0), new Date(1))).toEqual(false)\n  expect(equals(new Date(1), new Date(0))).toEqual(false)\n  expect(equals(new Date(0), {})).toEqual(false)\n  expect(equals({}, new Date(0))).toEqual(false)\n})\n\ntest('ramda spec', () => {\n  expect(equals({}, {})).toEqual(true)\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    a : 1,\n    b : 2,\n  })).toEqual(true)\n\n  expect(equals({\n    a : 2,\n    b : 3,\n  },\n  {\n    b : 3,\n    a : 2,\n  })).toEqual(true)\n\n  expect(equals({\n    a : 2,\n    b : 3,\n  },\n  {\n    a : 3,\n    b : 3,\n  })).toEqual(false)\n\n  expect(equals({\n    a : 2,\n    b : 3,\n    c : 1,\n  },\n  {\n    a : 2,\n    b : 3,\n  })).toEqual(false)\n})\n\ntest('works with boolean tuple', () => {\n  expect(equals([ true, false ], [ true, false ])).toBeTrue()\n  expect(equals([ true, false ], [ true, true ])).toBeFalse()\n})\n\ntest('works with equal objects within array', () => {\n  const objFirst = {\n    a : {\n      b : 1,\n      c : 2,\n      d : [ 1 ],\n    },\n  }\n  const objSecond = {\n    a : {\n      b : 1,\n      c : 2,\n      d : [ 1 ],\n    },\n  }\n\n  const x = [ 1, 2, objFirst, null, '', [] ]\n  const y = [ 1, 2, objSecond, null, '', [] ]\n  expect(equals(x, y)).toBeTrue()\n})\n\ntest('works with different objects within array', () => {\n  const objFirst = { a : { b : 1 } }\n  const objSecond = { a : { b : 2 } }\n\n  const x = [ 1, 2, objFirst, null, '', [] ]\n  const y = [ 1, 2, objSecond, null, '', [] ]\n  expect(equals(x, y)).toBeFalse()\n})\n\ntest('works with undefined as second argument', () => {\n  expect(equals(1, undefined)).toBeFalse()\n\n  expect(equals(undefined, undefined)).toBeTrue()\n})\n\ntest('various examples', () => {\n  expect(equals([ 1, 2, 3 ])([ 1, 2, 3 ])).toBeTrue()\n\n  expect(equals([ 1, 2, 3 ], [ 1, 2 ])).toBeFalse()\n\n  expect(equals(1, 1)).toBeTrue()\n\n  expect(equals(1, '1')).toBeFalse()\n\n  expect(equals({}, {})).toBeTrue()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    b : 2,\n    a : 1,\n  })).toBeTrue()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    a : 1,\n    b : 1,\n  })).toBeFalse()\n\n  expect(equals({\n    a : 1,\n    b : false,\n  },\n  {\n    a : 1,\n    b : 1,\n  })).toBeFalse()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    b : 2,\n    a : 1,\n    c : 3,\n  })).toBeFalse()\n\n  expect(equals({\n    x : {\n      a : 1,\n      b : 2,\n    },\n  },\n  {\n    x : {\n      b : 2,\n      a : 1,\n      c : 3,\n    },\n  })).toBeFalse()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    b : 3,\n    a : 1,\n  })).toBeFalse()\n\n  expect(equals({ a : { b : { c : 1 } } }, { a : { b : { c : 1 } } })).toBeTrue()\n\n  expect(equals({ a : { b : { c : 1 } } }, { a : { b : { c : 2 } } })).toBeFalse()\n\n  expect(equals({ a : {} }, { a : {} })).toBeTrue()\n\n  expect(equals('', '')).toBeTrue()\n\n  expect(equals('foo', 'foo')).toBeTrue()\n\n  expect(equals('foo', 'bar')).toBeFalse()\n\n  expect(equals(0, false)).toBeFalse()\n\n  expect(equals(/\\s/g, null)).toBeFalse()\n\n  expect(equals(null, null)).toBeTrue()\n\n  expect(equals(false)(null)).toBeFalse()\n})\n\ntest('with custom functions', () => {\n  function foo(){\n    return 1\n  }\n  foo.prototype.toString = () => ''\n  const result = equals(foo, foo)\n\n  expect(result).toBeFalse()\n})\n\ntest('with classes', () => {\n  class Foo{}\n  const foo = new Foo()\n  const result = equals(foo, foo)\n\n  expect(result).toBeTrue()\n})\n\ntest('with negative zero', () => {\n  expect(equals(-0, -0)).toBeTrue()\n  expect(equals(-0, 0)).toBeFalse()\n  expect(equals(0, 0)).toBeTrue()\n  expect(equals(-0, 1)).toBeFalse()\n})",
    "explanation": "It deeply compares `x` and `y` and returns `true` if they are equal.",
    "example": "R.equals(\n  [1, {a:2}, [{b: 3}]],\n  [1, {a:2}, [{b: 3}]]\n) // => true",
    "typescriptDefinitionTest": "import {equals} from 'rambda'\n\ndescribe('R.equals', () => {\n  it('happy', () => {\n    const result = equals(4, 1)\n    result // $ExpectType boolean\n  })\n  it('with object', () => {\n    const foo = {a: 1}\n    const bar = {a: 2}\n    const result = equals(foo, bar)\n    result // $ExpectType boolean\n  })\n  it('curried', () => {\n    const result = equals(4)(1)\n\n    result // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "/* global Map, Set, WeakMap, WeakSet */\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('equals', function() {\n  var a = [];\n  var b = a;\n  it('never considers Boolean primitive equal to Boolean object', function() {\n    eq(R.equals(true, new Boolean(true)), false);\n    eq(R.equals(new Boolean(true), true), false);\n    eq(R.equals(false, new Boolean(false)), false);\n    eq(R.equals(new Boolean(false), false), false);\n  });\n  it('never considers number primitive equal to Number object', function() {\n    eq(R.equals(0, new Number(0)), false);\n    eq(R.equals(new Number(0), 0), false);\n  });\n  it('never considers string primitive equal to String object', function() {\n    eq(R.equals('', new String('')), false);\n    eq(R.equals(new String(''), ''), false);\n    eq(R.equals('x', new String('x')), false);\n    eq(R.equals(new String('x'), 'x'), false);\n  });\n  var supportsSticky = false;\n  try { RegExp('', 'y'); supportsSticky = true; } catch (e) {}\n  var supportsUnicode = false;\n  try { RegExp('', 'u'); supportsUnicode = true; } catch (e) {}\n  var listA = [1, 2, 3];\n  var listB = [1, 3, 2];\n  var c = {}; c.v = c;\n  var d = {}; d.v = d;\n  var e = []; e.push(e);\n  var f = []; f.push(f);\n  var nestA = {a:[1, 2, {c:1}], b:1};\n  var nestB = {a:[1, 2, {c:1}], b:1};\n  var nestC = {a:[1, 2, {c:2}], b:1};\n  it('handles recursive data structures', function() {\n    eq(R.equals(c, d), true);\n    eq(R.equals(e, f), true);\n    eq(R.equals(nestA, nestB), true);\n    eq(R.equals(nestA, nestC), false);\n  });\n  it('requires that both objects have the same enumerable properties with the same values', function() {\n    var a1 = [];\n    var a2 = [];\n    a2.x = 0;\n    var b1 = new Boolean(false);\n    var b2 = new Boolean(false);\n    b2.x = 0;\n    var d1 = new Date(0);\n    var d2 = new Date(0);\n    d2.x = 0;\n    var n1 = new Number(0);\n    var n2 = new Number(0);\n    n2.x = 0;\n    var r1 = /(?:)/;\n    var r2 = /(?:)/;\n    r2.x = 0;\n    var s1 = new String('');\n    var s2 = new String('');\n    s2.x = 0;\n    eq(R.equals(a1, a2), false);\n    eq(R.equals(b1, b2), false);\n    eq(R.equals(d1, d2), false);\n    eq(R.equals(n1, n2), false);\n    eq(R.equals(r1, r2), false);\n    eq(R.equals(s1, s2), false);\n  });\n  if (typeof ArrayBuffer !== 'undefined' && typeof Int8Array !== 'undefined') {\n    var typArr1 = new ArrayBuffer(10);\n    typArr1[0] = 1;\n    var typArr2 = new ArrayBuffer(10);\n    typArr2[0] = 1;\n    var typArr3 = new ArrayBuffer(10);\n    var intTypArr = new Int8Array(typArr1);\n    typArr3[0] = 0;\n    it('handles typed arrays', function() {\n      eq(R.equals(typArr1, typArr2), true);\n      eq(R.equals(typArr1, typArr3), false);\n      eq(R.equals(typArr1, intTypArr), false);\n    });\n  }\n  if (typeof Promise !== 'undefined') {\n    it('compares Promise objects by identity', function() {\n      var p = Promise.resolve(42);\n      var q = Promise.resolve(42);\n      eq(R.equals(p, p), true);\n      eq(R.equals(p, q), false);\n    });\n  }\n  if (typeof Map !== 'undefined') {\n    it('compares Map objects by value', function() {\n      eq(R.equals(new Map([]), new Map([])), true);\n      eq(R.equals(new Map([]), new Map([[1, 'a']])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[1, 'a']])), true);\n      eq(R.equals(new Map([[1, 'a'], [2, 'b']]), new Map([[2, 'b'], [1, 'a']])), true);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[2, 'a']])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[1, 'b']])), false);\n      eq(R.equals(new Map([[1, 'a'], [2, new Map([[3, 'c']])]]), new Map([[1, 'a'], [2, new Map([[3, 'c']])]])), true);\n      eq(R.equals(new Map([[1, 'a'], [2, new Map([[3, 'c']])]]), new Map([[1, 'a'], [2, new Map([[3, 'd']])]])), false);\n      eq(R.equals(new Map([[[1, 2, 3], [4, 5, 6]]]), new Map([[[1, 2, 3], [4, 5, 6]]])), true);\n      eq(R.equals(new Map([[[1, 2, 3], [4, 5, 6]]]), new Map([[[1, 2, 3], [7, 8, 9]]])), false);\n    });\n    it('dispatches to `equals` method recursively in Set', function() {\n      var a = new Map();\n      var b = new Map();\n      a.set(a, a);\n      eq(R.equals(a, b), false);\n      a.set(b, b);\n      b.set(b, b);\n      b.set(a, a);\n      eq(R.equals(a, b), true);\n    });\n  }\n  if (typeof Set !== 'undefined') {\n    it('compares Set objects by value', function() {\n      eq(R.equals(new Set([]), new Set([])), true);\n      eq(R.equals(new Set([]), new Set([1])), false);\n      eq(R.equals(new Set([1]), new Set([])), false);\n      eq(R.equals(new Set([1, 2]), new Set([2, 1])), true);\n      eq(R.equals(new Set([1, new Set([2, new Set([3])])]), new Set([1, new Set([2, new Set([3])])])), true);\n      eq(R.equals(new Set([1, new Set([2, new Set([3])])]), new Set([1, new Set([2, new Set([4])])])), false);\n      eq(R.equals(new Set([[1, 2, 3], [4, 5, 6]]), new Set([[1, 2, 3], [4, 5, 6]])), true);\n      eq(R.equals(new Set([[1, 2, 3], [4, 5, 6]]), new Set([[1, 2, 3], [7, 8, 9]])), false);\n    });\n    it('dispatches to `equals` method recursively in Set', function() {\n      var a = new Set();\n      var b = new Set();\n      a.add(a);\n      eq(R.equals(a, b), false);\n      a.add(b);\n      b.add(b);\n      b.add(a);\n      eq(R.equals(a, b), true);\n    });\n  }\n  if (typeof WeakMap !== 'undefined') {\n    it('compares WeakMap objects by identity', function() {\n      var m = new WeakMap([]);\n      eq(R.equals(m, m), true);\n      eq(R.equals(m, new WeakMap([])), false);\n    });\n  }\n  if (typeof WeakSet !== 'undefined') {\n    it('compares WeakSet objects by identity', function() {\n      var s = new WeakSet([]);\n      eq(R.equals(s, s), true);\n      eq(R.equals(s, new WeakSet([])), false);\n    });\n  }\n  it('dispatches to `equals` method recursively', function() {\n    function Left(x) { this.value = x; }\n    Left.prototype.equals = function(x) {\n      return x instanceof Left && R.equals(x.value, this.value);\n    };\n    function Right(x) { this.value = x; }\n    Right.prototype.equals = function(x) {\n      return x instanceof Right && R.equals(x.value, this.value);\n    };\n    eq(R.equals(new Left([42]), new Left([42])), true);\n    eq(R.equals(new Left([42]), new Left([43])), false);\n    eq(R.equals(new Left(42), {value: 42}), false);\n    eq(R.equals({value: 42}, new Left(42)), false);\n    eq(R.equals(new Left(42), new Right(42)), false);\n    eq(R.equals(new Right(42), new Left(42)), false);\n    eq(R.equals([new Left(42)], [new Left(42)]), true);\n    eq(R.equals([new Left(42)], [new Right(42)]), false);\n    eq(R.equals([new Right(42)], [new Left(42)]), false);\n    eq(R.equals([new Right(42)], [new Right(42)]), true);\n  });\n});",
    "failedSpecsReasons": "Rambda method doesn't support recursive data structures, objects with same enumerable properties, map/weakmap type of variables | Ramda dispatches to `equals` method recursively | Rambda method doesn't support equality of functions",
    "failedSpecsCount": 14
  },
  "F": {
    "typing": "\nF(): boolean",
    "allTypings": "F(): boolean;",
    "rambdaSource": "export function F(){\n  return false\n}",
    "example": "F() // => false"
  },
  "filter": {
    "typing": "\nfilter<T>(predicate: Predicate<T>): (input: readonly T[]) => T[]",
    "allTypings": "filter<T>(predicate: Predicate<T>): (input: readonly T[]) => T[];\nfilter<T>(predicate: Predicate<T>, input: readonly T[]): T[];\nfilter<T, U>(predicate: ObjectPredicate<T>): (x: Dictionary<T>) => Dictionary<T>;\nfilter<T>(predicate: ObjectPredicate<T>, x: Dictionary<T>): Dictionary<T>;",
    "categories": [
      "List",
      "Object"
    ],
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nexport function filterObject(fn, obj){\n  const willReturn = {}\n\n  for (const prop in obj){\n    if (fn(\n      obj[ prop ], prop, obj\n    )){\n      willReturn[ prop ] = obj[ prop ]\n    }\n  }\n\n  return willReturn\n}\n\nexport function filterArray(\n  predicate, list, indexed = false\n){\n  let index = 0\n  const len = list.length\n  const willReturn = []\n\n  while (index < len){\n    const predicateResult = indexed ?\n      predicate(list[ index ], index) :\n      predicate(list[ index ])\n    if (predicateResult){\n      willReturn.push(list[ index ])\n    }\n\n    index++\n  }\n\n  return willReturn\n}\n\nexport function filter(predicate, iterable){\n  if (arguments.length === 1){\n    return _iterable => filter(predicate, _iterable)\n  }\n  if (!iterable) return []\n  if (_isArray(iterable)) return filterArray(predicate, iterable)\n\n  return filterObject(predicate, iterable)\n}",
    "rambdaSpecs": "import Ramda from 'ramda'\n\nimport { F } from './F'\nimport { filter } from './filter'\nimport { T } from './T'\n\nconst sampleObject = {\n  a : 1,\n  b : 2,\n  c : 3,\n  d : 4,\n}\n\ntest('happy', () => {\n  const isEven = n => n % 2 === 0\n\n  expect(filter(isEven, [ 1, 2, 3, 4 ])).toEqual([ 2, 4 ])\n  expect(filter(isEven, {\n    a : 1,\n    b : 2,\n    d : 3,\n  })).toEqual({ b : 2 })\n})\n\ntest('bad inputs difference between Ramda and Rambda', () => {\n  expect(filter(T)(undefined)).toEqual([])\n  expect(filter(F, null)).toEqual([])\n  expect(() => Ramda.filter(T, null)).toThrowWithMessage(TypeError,\n    'Cannot read property \\'filter\\' of null')\n  expect(() => Ramda.filter(T, undefined)).toThrowWithMessage(TypeError,\n    'Cannot read property \\'filter\\' of undefined')\n})\n\ntest('predicate when input is object', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n  }\n  const predicate = (\n    val, prop, inputObject\n  ) => {\n    expect(inputObject).toEqual(obj)\n    expect(typeof prop).toEqual('string')\n\n    return val < 2\n  }\n  expect(filter(predicate, obj)).toEqual({ a : 1 })\n})\n\ntest('with object', () => {\n  const isEven = n => n % 2 === 0\n  const result = filter(isEven, sampleObject)\n  const expectedResult = {\n    b : 2,\n    d : 4,\n  }\n\n  expect(result).toEqual(expectedResult)\n})",
    "explanation": "It filters list or object `input` using a `predicate` function.",
    "example": "const list = [3, 4, 3, 2]\nconst listPredicate = x => x > 2\n\nconst object = {abc: 'fo', xyz: 'bar', baz: 'foo'}\nconst objectPredicate = (x, prop) => x.length + prop.length > 5\n\nconst result = [\n  R.filter(listPredicate, list),\n  R.filter(objectPredicate, object)\n]\n// => [ [3, 4], { xyz: 'bar', baz: 'foo'} ]",
    "typescriptDefinitionTest": "import {filter} from 'rambda'\n\nconst list = [1, 2, 3]\nconst obj = {a: 1, b: 2}\n\ndescribe('R.filter with array', () => {\n  it('happy', () => {\n    const result = filter<number>(x => {\n      x // $ExpectType number\n      return x > 1\n    }, list)\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = filter<number>(x => {\n      x // $ExpectType number\n      return x > 1\n    })(list)\n    result // $ExpectType number[]\n  })\n})\n\ndescribe('R.filter with objects', () => {\n  it('happy', () => {\n    const result = filter<number>((val, prop, origin) => {\n      val // $ExpectType number\n      prop // $ExpectType string\n      origin // $ExpectType Dictionary<number>\n\n      return val > 1\n    }, obj)\n    result // $ExpectType Dictionary<number>\n  })\n  it('curried version requires second dummy type', () => {\n    const result = filter<number, any>((val, prop, origin) => {\n      val // $ExpectType number\n      prop // $ExpectType string\n      origin // $ExpectType Dictionary<number>\n\n      return val > 1\n    })(obj)\n    result // $ExpectType Dictionary<number>\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar Maybe = require('./shared/Maybe');\n\ndescribe('filter', function() {\n  var even = function(x) {return x % 2 === 0;};\n  it('dispatches to passed-in non-Array object with a `filter` method', function() {\n    var f = {filter: function(f) { return f('called f.filter'); }};\n    eq(R.filter(function(s) { return s; }, f), 'called f.filter');\n  });\n  it('correctly uses fantasy-land implementations', function() {\n    var m1 = Maybe.Just(-1);\n    var m2 = R.filter(function(x) { return x > 0; } , m1);\n    eq(m2.isNothing, true);\n  });\n});",
    "failedSpecsReasons": "Ramda method dispatches to `filter` method of object",
    "failedSpecsCount": 1
  },
  "find": {
    "typing": "\nfind<T>(predicate: (x: T) => boolean, list: readonly T[]): T | undefined",
    "allTypings": "find<T>(predicate: (x: T) => boolean, list: readonly T[]): T | undefined;\nfind<T>(predicate: (x: T) => boolean): (list: readonly T[]) => T | undefined;",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function find(predicate, list){\n  if (arguments.length === 1) return _list => find(predicate, _list)\n\n  let index = 0\n  const len = list.length\n\n  while (index < len){\n    const x = list[ index ]\n    if (predicate(x)){\n      return x\n    }\n\n    index++\n  }\n}",
    "rambdaSpecs": "import { find } from './find'\nimport { propEq } from './propEq'\n\nconst list = [ { a : 1 }, { a : 2 }, { a : 3 } ]\n\ntest('happy', () => {\n  const fn = propEq('a', 2)\n  expect(find(fn, list)).toEqual({ a : 2 })\n})\n\ntest('with curry', () => {\n  const fn = propEq('a', 4)\n  expect(find(fn)(list)).toBeUndefined()\n})\n\ntest('with empty list', () => {\n  expect(find(() => true, [])).toBeUndefined()\n})",
    "explanation": "It returns the first element of `list` that satisfy the `predicate`.\n\nIf there is no such element, it returns `undefined`.",
    "example": "const predicate = x => R.type(x.foo) === 'Number'\nconst list = [{foo: 'bar'}, {foo: 1}]\n\nconst result = R.find(predicate, list)\n// => {foo: 1}",
    "typescriptDefinitionTest": "import {find} from 'rambda'\n\nconst list = [1, 2, 3]\n\ndescribe('R.find', () => {\n  it('happy', () => {\n    const predicate = (x: number) => x > 2\n    const result = find(predicate, list)\n    result // $ExpectType number | undefined\n  })\n  it('curried', () => {\n    const predicate = (x: number) => x > 2\n    const result = find(predicate)(list)\n    result // $ExpectType number | undefined\n  })\n})"
  },
  "findIndex": {
    "typing": "\nfindIndex<T>(predicate: (x: T) => boolean, list: readonly T[]): number",
    "allTypings": "findIndex<T>(predicate: (x: T) => boolean, list: readonly T[]): number;\nfindIndex<T>(predicate: (x: T) => boolean): (list: readonly T[]) => number;",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function findIndex(predicate, list){\n  if (arguments.length === 1) return _list => findIndex(predicate, _list)\n\n  const len = list.length\n  let index = -1\n\n  while (++index < len){\n    if (predicate(list[ index ])){\n      return index\n    }\n  }\n\n  return -1\n}",
    "rambdaSpecs": "import { findIndex } from './findIndex'\nimport { propEq } from './propEq'\n\nconst list = [ { a : 1 }, { a : 2 }, { a : 3 } ]\n\ntest('happy', () => {\n  expect(findIndex(propEq('a', 2), list)).toEqual(1)\n\n  expect(findIndex(propEq('a', 1))(list)).toEqual(0)\n\n  expect(findIndex(propEq('a', 4))(list)).toEqual(-1)\n})",
    "explanation": "It returns the index of the first element of `list` satisfying the `predicate` function.\n\nIf there is no such element, then `-1` is returned.",
    "example": "const predicate = x => R.type(x.foo) === 'Number'\nconst list = [{foo: 'bar'}, {foo: 1}]\n\nconst result = R.findIndex(predicate, list)\n// => 1",
    "typescriptDefinitionTest": "import {findIndex} from 'rambda'\n\nconst list = [1, 2, 3]\n\ndescribe('R.findIndex', () => {\n  it('happy', () => {\n    const predicate = (x: number) => x > 2\n    const result = findIndex(predicate, list)\n    result // $ExpectType number\n  })\n  it('curried', () => {\n    const predicate = (x: number) => x > 2\n    const result = findIndex(predicate)(list)\n    result // $ExpectType number\n  })\n})"
  },
  "findLast": {
    "typing": "\nfindLast<T>(fn: (x: T) => boolean, list: readonly T[]): T | undefined",
    "allTypings": "findLast<T>(fn: (x: T) => boolean, list: readonly T[]): T | undefined;\nfindLast<T>(fn: (x: T) => boolean): (list: readonly T[]) => T | undefined;",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function findLast(predicate, list){\n  if (arguments.length === 1) return _list => findLast(predicate, _list)\n\n  let index = list.length\n\n  while (--index >= 0){\n    if (predicate(list[ index ])){\n      return list[ index ]\n    }\n  }\n\n  return undefined\n}",
    "rambdaSpecs": "import { findLast } from './findLast'\n\ntest('happy', () => {\n  const result = findLast(x => {\n    return x > 1\n  },\n  [ 1, 1, 1, 2, 3, 4, 1 ]\n  )\n  expect(result).toEqual(4)\n\n  expect(findLast(x => x === 0, [ 0, 1, 1, 2, 3, 4, 1 ])).toEqual(0)\n})\n\ntest('with curry', () => {\n  expect(findLast(x => x > 1)([ 1, 1, 1, 2, 3, 4, 1 ])).toEqual(4)\n})\n\nconst obj1 = { x : 100 }\nconst obj2 = { x : 200 }\nconst a = [ 11, 10, 9, 'cow', obj1, 8, 7, 100, 200, 300, obj2, 4, 3, 2, 1, 0 ]\nconst even = function (x){\n  return x % 2 === 0\n}\nconst gt100 = function (x){\n  return x > 100\n}\nconst isStr = function (x){\n  return typeof x === 'string'\n}\nconst xGt100 = function (o){\n  return o && o.x > 100\n}\n\ntest('ramda 1', () => {\n  expect(findLast(even, a)).toEqual(0)\n  expect(findLast(gt100, a)).toEqual(300)\n  expect(findLast(isStr, a)).toEqual('cow')\n  expect(findLast(xGt100, a)).toEqual(obj2)\n})\n\ntest('ramda 2', () => {\n  expect(findLast(even, [ 'zing' ])).toEqual(undefined)\n})\n\ntest('ramda 3', () => {\n  expect(findLast(even, [ 2, 3, 5 ])).toEqual(2)\n})\n\ntest('ramda 4', () => {\n  expect(findLast(even, [])).toEqual(undefined)\n})",
    "explanation": "It returns the last element of `list` satisfying the `predicate` function.\n\nIf there is no such element, then `undefined` is returned.",
    "example": "const predicate = x => R.type(x.foo) === 'Number'\nconst list = [{foo: 0}, {foo: 1}]\n\nconst result = R.findLast(predicate, list)\n// => {foo: 1}",
    "typescriptDefinitionTest": "import {findLast} from 'rambda'\n\nconst list = [1, 2, 3]\n\ndescribe('R.findLast', () => {\n  it('happy', () => {\n    const predicate = (x: number) => x > 2\n    const result = findLast(predicate, list)\n    result // $ExpectType number | undefined\n  })\n  it('curried', () => {\n    const predicate = (x: number) => x > 2\n    const result = findLast(predicate)(list)\n    result // $ExpectType number | undefined\n  })\n})"
  },
  "findLastIndex": {
    "typing": "\nfindLastIndex<T>(predicate: (x: T) => boolean, list: readonly T[]): number",
    "allTypings": "findLastIndex<T>(predicate: (x: T) => boolean, list: readonly T[]): number;\nfindLastIndex<T>(predicate: (x: T) => boolean): (list: readonly T[]) => number;",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function findLastIndex(fn, list){\n  if (arguments.length === 1) return _list => findLastIndex(fn, _list)\n\n  let index = list.length\n\n  while (--index >= 0){\n    if (fn(list[ index ])){\n      return index\n    }\n  }\n\n  return -1\n}",
    "rambdaSpecs": "import { findLastIndex } from './findLastIndex'\n\ntest('happy', () => {\n  const result = findLastIndex((x) => {\n\n    return x > 1\n  },\n  [ 1, 1, 1, 2, 3, 4, 1 ])\n\n  expect(result).toEqual(5)\n\n  expect(findLastIndex(x => x === 0, [ 0, 1, 1, 2, 3, 4, 1 ])).toEqual(0)\n})\n\ntest('with curry', () => {\n  expect(findLastIndex(x => x > 1)([ 1, 1, 1, 2, 3, 4, 1 ])).toEqual(5)\n})\n\nconst obj1 = { x : 100 }\nconst obj2 = { x : 200 }\nconst a = [ 11, 10, 9, 'cow', obj1, 8, 7, 100, 200, 300, obj2, 4, 3, 2, 1, 0 ]\nconst even = function (x){\n  return x % 2 === 0\n}\nconst gt100 = function (x){\n  return x > 100\n}\nconst isStr = function (x){\n  return typeof x === 'string'\n}\nconst xGt100 = function (o){\n  return o && o.x > 100\n}\n\ntest('ramda 1', () => {\n  expect(findLastIndex(even, a)).toEqual(15)\n  expect(findLastIndex(gt100, a)).toEqual(9)\n  expect(findLastIndex(isStr, a)).toEqual(3)\n  expect(findLastIndex(xGt100, a)).toEqual(10)\n})\n\ntest('ramda 2', () => {\n  expect(findLastIndex(even, [ 'zing' ])).toEqual(-1)\n})\n\ntest('ramda 3', () => {\n  expect(findLastIndex(even, [ 2, 3, 5 ])).toEqual(0)\n})\n\ntest('ramda 4', () => {\n  expect(findLastIndex(even, [])).toEqual(-1)\n})",
    "explanation": "It returns the index of the last element of `list` satisfying the `predicate` function.\n\nIf there is no such element, then `-1` is returned.",
    "example": "const predicate = x => R.type(x.foo) === 'Number'\nconst list = [{foo: 0}, {foo: 1}]\n\nconst result = R.findLastIndex(predicate, list)\n// => 1",
    "typescriptDefinitionTest": "import {findLastIndex} from 'rambda'\n\nconst list = [1, 2, 3]\n\ndescribe('R.findLastIndex', () => {\n  it('happy', () => {\n    const predicate = (x: number) => x > 2\n    const result = findLastIndex(predicate, list)\n    result // $ExpectType number\n  })\n  it('curried', () => {\n    const predicate = (x: number) => x > 2\n    const result = findLastIndex(predicate)(list)\n    result // $ExpectType number\n  })\n})"
  },
  "flatten": {
    "typing": "\nflatten<T>(list: readonly any[]): T[]",
    "allTypings": "flatten<T>(list: readonly any[]): T[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nexport function flatten(list, input){\n  const willReturn = input === undefined ? [] : input\n\n  for (let i = 0; i < list.length; i++){\n    if (_isArray(list[ i ])){\n      flatten(list[ i ], willReturn)\n    } else {\n      willReturn.push(list[ i ])\n    }\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { flatten } from './flatten'\n\ntest('happy', () => {\n  expect(flatten([ 1, 2, 3, [ [ [ [ [ 4 ] ] ] ] ] ])).toEqual([ 1, 2, 3, 4 ])\n\n  expect(flatten([ 1, [ 2, [ [ 3 ] ] ], [ 4 ] ])).toEqual([ 1, 2, 3, 4 ])\n\n  expect(flatten([ 1, [ 2, [ [ [ 3 ] ] ] ], [ 4 ] ])).toEqual([ 1, 2, 3, 4 ])\n\n  expect(flatten([ 1, 2, [ 3, 4 ], 5, [ 6, [ 7, 8, [ 9, [ 10, 11 ], 12 ] ] ] ])).toEqual([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ])\n})\n\ntest('readme example', () => {\n  const result = flatten([ 1, 2, [ 3, 30, [ 300 ] ], [ 4 ] ])\n  expect(result).toEqual([ 1, 2, 3, 30, 300, 4 ])\n})",
    "explanation": "It deeply flattens an array.",
    "example": "const result = R.flatten([\n  1, \n  2, \n  [3, 30, [300]], \n  [4]\n])\n// => [ 1, 2, 3, 30, 300, 4 ]",
    "typescriptDefinitionTest": "import {flatten} from 'rambda'\n\ndescribe('flatten', () => {\n  it('happy', () => {\n    const result = flatten<number>([1, 2, [3, [4]]])\n    result // $ExpectType number[]\n  })\n})"
  },
  "flip": {
    "typing": "\nflip<T, U, TResult>(fn: (arg0: T, arg1: U) => TResult): (arg1: U, arg0?: T) => TResult",
    "allTypings": "flip<T, U, TResult>(fn: (arg0: T, arg1: U) => TResult): (arg1: U, arg0?: T) => TResult;\nflip<F extends (...args: any) => any, P extends FunctionToolbelt.Parameters<F>>(fn: F): FunctionToolbelt.Curry<(...args: ListToolbelt.Merge<[P[1], P[0]], P>) => FunctionToolbelt.Return<F>>;",
    "categories": [
      "Function"
    ],
    "notes": "Rambda's **flip** will throw if the arity of the input function is greater or equal to 5.",
    "rambdaSource": "function flipFn(fn){\n  return (...input) => {\n    if (input.length === 1){\n      return holder => fn(holder, input[ 0 ])\n    } else if (input.length === 2){\n      return fn(input[ 1 ], input[ 0 ])\n    } else if (input.length === 3){\n      return fn(\n        input[ 1 ], input[ 0 ], input[ 2 ]\n      )\n    } else if (input.length === 4){\n      return fn(\n        input[ 1 ], input[ 0 ], input[ 2 ], input[ 3 ]\n      )\n    }\n\n    throw new Error('R.flip doesn\\'t work with arity > 4')\n  }\n}\n\nexport function flip(fn){\n  return flipFn(fn)\n}",
    "rambdaSpecs": "import { flip } from './flip'\nimport { subtract } from './subtract'\nimport { update } from './update'\n\ntest('function with arity of 2', () => {\n  const subtractFlipped = flip(subtract)\n\n  expect(subtractFlipped(1)(7)).toEqual(6)\n  expect(subtractFlipped(1, 7)).toEqual(6)\n  expect(subtractFlipped(\n    1, 7, 9\n  )).toEqual(6)\n})\n\ntest('function with arity of 3', () => {\n  const updateFlipped = flip(update)\n\n  const result = updateFlipped(\n    88, 0, [ 1, 2, 3 ]\n  )\n  const curriedResult = updateFlipped(88, 0)([ 1, 2, 3 ])\n  const tripleCurriedResult = updateFlipped(88)(0)([ 1, 2, 3 ])\n  expect(result).toEqual([ 88, 2, 3 ])\n  expect(curriedResult).toEqual([ 88, 2, 3 ])\n  expect(tripleCurriedResult).toEqual([ 88, 2, 3 ])\n})\n\ntest('function with arity of 4', () => {\n  const testFunction = (\n    a, b, c, d\n  ) => `${ a - b }==${ c - d }`\n  const testFunctionFlipped = flip(testFunction)\n\n  const result = testFunction(\n    1, 2, 3, 4\n  )\n  const flippedResult = testFunctionFlipped(\n    2, 1, 3, 4\n  )\n  expect(result).toEqual(flippedResult)\n  expect(result).toEqual('-1==-1')\n})\n\ntest('function with arity of 5', () => {\n  const testFunction = (\n    a, b, c, d, e\n  ) => `${ a - b }==${ c - d - e }`\n  const testFunctionFlipped = flip(testFunction)\n\n  expect(() => testFunctionFlipped(\n    1, 2, 3, 4, 5\n  )).toThrowWithMessage(Error,\n    'R.flip doesn\\'t work with arity > 4')\n})",
    "explanation": "It returns function which calls `fn` with exchanged first and second argument.",
    "example": "const subtractFlip = R.flip(R.subtract)\n\nconst result = [\n  subtractFlip(1,7),\n  R.flip(1, 6)\n]  \n// => [6, -6]",
    "typescriptDefinitionTest": "import * as R from 'ramda'\nimport {flip, subtract} from 'rambda'\n\ndescribe('R.flip', () => {\n  it('function with arity of 2', () => {\n    const subtractFlipped = flip(subtract)\n    const result = subtractFlipped(1, 7)\n    const curriedResult = subtractFlipped(1)(7)\n    curriedResult // $ExpectType number\n\n    // This is wrong\n    // ============================================\n    result // $ExpectType (y: number) => number\n  })\n\n  it('function with arity of 3', () => {\n    function testFunction(a: number, b: string, c: number): string {\n      return `${b}==${a + c}`\n    }\n    const flippedTestFunction = flip(testFunction)\n\n    const result = flippedTestFunction('foo', 1, 2)\n    result // $ExpectType string\n  })\n})\n\ndescribe('Ramda.flip', () => {\n  it('function with arity of 2', () => {\n    const subtractFlipped = R.flip(R.subtract)\n    const result = subtractFlipped(1, 7)\n    const curriedResult = subtractFlipped(1)(7)\n    curriedResult // $ExpectType number\n\n    // This is wrong\n    // ============================================\n    result // $ExpectType (b: number) => number\n  })\n})",
    "failedRamdaSpecs": "var jsv = require('jsverify');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar funcN = require('./shared/funcN');\ndescribe('flip', function() {\n  it('returns a function which inverts the first two arguments to the supplied function', function() {\n    var f = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    var g = R.flip(f);\n    eq(f('a', 'b', 'c'), 'a b c');\n    eq(g('a', 'b', 'c'), 'b a c');\n  });\n  it('returns a curried function', function() {\n    var f = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    var g = R.flip(f)('a');\n    eq(g('b', 'c'), 'b a c');\n  });\n  it('returns a function with the correct arity', function() {\n    var f2 = function(a, b) {return a + ' ' + b;};\n    var f3 = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    eq(R.flip(f2).length, 2);\n    eq(R.flip(f3).length, 3);\n  });\n});\ndescribe('flip properties', function() {\n  jsv.property('inverts first two arguments', funcN(3), jsv.json, jsv.json, jsv.json, function(f, a, b, c) {\n    var g = R.flip(f);\n    return R.equals(f(a, b, c), g(b, a, c));\n  });\n});",
    "failedSpecsReasons": "Ramda.flip returns a curried function | Rambda.flip work only for functions with arity below 5",
    "failedSpecsCount": 4
  },
  "forEach": {
    "typing": "\nforEach<T>(fn: Iterator<T, void>, list: readonly T[]): T[]",
    "allTypings": "forEach<T>(fn: Iterator<T, void>, list: readonly T[]): T[];\nforEach<T>(fn: Iterator<T, void>): (list: readonly T[]) => T[];\nforEach<T>(fn: ObjectIterator<T, void>, list: Dictionary<T>): Dictionary<T>;\nforEach<T, U>(fn: ObjectIterator<T, void>): (list: Dictionary<T>) => Dictionary<T>;",
    "categories": [
      "List",
      "Object"
    ],
    "notes": "It works with objects, unlike `Ramda`.",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\nimport { _keys } from './_internals/_keys'\n\nexport function forEach(fn, list){\n  if (arguments.length === 1) return _list => forEach(fn, _list)\n\n  if (list === undefined){\n    return\n  }\n\n  if (_isArray(list)){\n    let index = 0\n    const len = list.length\n\n    while (index < len){\n      fn(list[ index ])\n      index++\n    }\n  } else {\n    let index = 0\n    const keys = _keys(list)\n    const len = keys.length\n\n    while (index < len){\n      const key = keys[ index ]\n      fn(\n        list[ key ], key, list\n      )\n      index++\n    }\n  }\n\n  return list\n}",
    "rambdaSpecs": "import { forEach } from './forEach'\nimport { type } from './type'\n\ntest('iterate over object', () => {\n  const obj = {\n    a : 1,\n    b : [ 1, 2 ],\n    c : { d : 7 },\n    f : 'foo',\n  }\n  const result = {}\n  const returned = forEach((\n    val, prop, inputObj\n  ) => {\n    expect(type(inputObj)).toBe('Object')\n    result[ prop ] = `${ prop }-${ type(val) }`\n  })(obj)\n\n  const expected = {\n    a : 'a-Number',\n    b : 'b-Array',\n    c : 'c-Object',\n    f : 'f-String',\n  }\n\n  expect(result).toEqual(expected)\n  expect(returned).toEqual(obj)\n})\n\ntest('happy', () => {\n  const sideEffect = {}\n  forEach(x => sideEffect[ `foo${ x }` ] = x + 10)([ 1, 2 ])\n\n  expect(sideEffect).toEqual({\n    foo1 : 11,\n    foo2 : 12,\n  })\n})\n\ntest('with empty list', () => {\n  const list = []\n  const result = forEach(x => x * x)(list)\n\n  expect(result).toEqual(list)\n})\n\ntest('with wrong input', () => {\n  const list = undefined\n  const result = forEach(x => x * x)(list)\n\n  expect(result).toBeUndefined()\n})\n\ntest('returns the input', () => {\n  const list = [ 1, 2, 3 ]\n  const result = forEach(x => x * x)(list)\n\n  expect(result).toEqual(list)\n})",
    "explanation": "It applies `iterable` function over all members of `list` and returns `list`.",
    "example": "const sideEffect = {}\nconst result = R.forEach(\n  x => sideEffect[`foo${x}`] = x\n)([1, 2])\n\nsideEffect //=> {foo1: 1, foo2: 2}\nresult //=> [1, 2]",
    "typescriptDefinitionTest": "import {forEach} from 'rambda'\n\nconst list = [1, 2, 3]\nconst obj = {a: 1, b: 2}\n\ndescribe('R.forEach with arrays', () => {\n  it('happy', () => {\n    const result = forEach(a => {\n      a // $ExpectType number\n    }, list)\n    result // $ExpectType number[]\n  })\n  it('curried require an explicit typing', () => {\n    const result = forEach<number>(a => {\n      a // $ExpectType number\n    })(list)\n    result // $ExpectType number[]\n  })\n})\n\ndescribe('R.forEach with objects', () => {\n  it('happy', () => {\n    const result = forEach((a, b, c) => {\n      a // $ExpectType number\n      b // $ExpectType string\n      c // $ExpectType Dictionary<number>\n      return `${a}`\n    }, obj)\n    result // $ExpectType Dictionary<number>\n  })\n  it('curried require an input typing and a dummy third typing', () => {\n    // Required in order all typings to work\n    const result = forEach<number, any>((a, b, c) => {\n      a // $ExpectType number\n      b // $ExpectType string\n      c // $ExpectType Dictionary<number>\n    })(obj)\n    result // $ExpectType Dictionary<number>\n  })\n  it('iterator without property', () => {\n    const result = forEach(a => {\n      a // $ExpectType number\n    }, obj)\n    result // $ExpectType Dictionary<number>\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('forEach', function() {\n  var list = [{x: 1, y: 2}, {x: 100, y: 200}, {x: 300, y: 400}, {x: 234, y: 345}];\n  it('dispatches to `forEach` method', function() {\n    var dispatched = false;\n    var fn = function() {};\n    function DummyList() {}\n    DummyList.prototype.forEach = function(callback) {\n      dispatched = true;\n      eq(callback, fn);\n    };\n    R.forEach(fn, new DummyList());\n    eq(dispatched, true);\n  });\n});",
    "failedSpecsReasons": "Ramda method dispatches to `forEach` method",
    "failedSpecsCount": 1
  },
  "fromPairs": {
    "typing": "\nfromPairs<V>(listOfPairs: KeyValuePair<string, V>[]): { [index: string]: V }",
    "allTypings": "fromPairs<V>(listOfPairs: KeyValuePair<string, V>[]): { [index: string]: V };\nfromPairs<V>(listOfPairs: KeyValuePair<number, V>[]): { [index: number]: V };",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function fromPairs(listOfPairs){\n  const toReturn = {}\n  listOfPairs.forEach(([ prop, value ]) => toReturn[ prop ] = value)\n\n  return toReturn\n}",
    "rambdaSpecs": "import { fromPairs } from './fromPairs'\n\nconst list = [\n  [ 'a', 1 ],\n  [ 'b', 2 ],\n  [ 'c', [ 3, 4 ] ],\n]\nconst expected = {\n  a : 1,\n  b : 2,\n  c : [ 3, 4 ],\n}\n\ntest('happy', () => {\n  expect(fromPairs(list)).toEqual(expected)\n})",
    "explanation": "It transforms a `listOfPairs` to an object.",
    "example": "const listOfPairs = [ [ 'a', 1 ], [ 'b', 2 ], [ 'c', [ 3, 4 ] ] ]\nconst expected = {\n  a : 1,\n  b : 2,\n  c : [ 3, 4 ],\n}\n\nconst result = R.fromPairs(listOfPairs)\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {fromPairs} from 'rambda'\n\ndescribe('R.fromPairs - require explicit type for input list', () => {\n  it('with string index', () => {\n    const list: [string, number][] = [\n      ['a', 1],\n      ['b', 2],\n      ['c', 3],\n    ]\n    const result = fromPairs(list)\n\n    result // $ExpectType { [index: string]: number; }\n  })\n  it('with number index', () => {\n    const list: [number, string][] = [\n      [10, 'foo'],\n      [20, 'bar'],\n      [30, 'baz'],\n    ]\n    const result = fromPairs(list)\n\n    result // $ExpectType { [index: number]: string; }\n  })\n})"
  },
  "groupBy": {
    "typing": "\ngroupBy<T>(groupFn: (x: T) => string, list: readonly T[]): { [index: string]: T[] }",
    "allTypings": "groupBy<T>(groupFn: (x: T) => string, list: readonly T[]): { [index: string]: T[] };\ngroupBy<T>(groupFn: (x: T) => string): (list: readonly T[]) => { [index: string]: T[] };",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function groupBy(groupFn, list){\n  if (arguments.length === 1) return _list => groupBy(groupFn, _list)\n\n  const result = {}\n  for (let i = 0; i < list.length; i++){\n    const item = list[ i ]\n    const key = groupFn(item)\n\n    if (!result[ key ]){\n      result[ key ] = []\n    }\n\n    result[ key ].push(item)\n  }\n\n  return result\n}",
    "rambdaSpecs": "import { groupBy } from './groupBy'\nimport { prop } from './prop'\n\ntest('groupBy', () => {\n  const list = [\n    {\n      age  : 12,\n      name : 'john',\n    },\n    {\n      age  : 12,\n      name : 'jack',\n    },\n    {\n      age  : 24,\n      name : 'mary',\n    },\n    {\n      age  : 24,\n      name : 'steve',\n    },\n  ]\n  const expectedResult = {\n    12 : [\n      {\n        age  : 12,\n        name : 'john',\n      },\n      {\n        age  : 12,\n        name : 'jack',\n      },\n    ],\n    24 : [\n      {\n        age  : 24,\n        name : 'mary',\n      },\n      {\n        age  : 24,\n        name : 'steve',\n      },\n    ],\n  }\n\n  expect(groupBy(prop('age'))(list)).toEqual(expectedResult)\n  expect(groupBy(prop('age'), list)).toEqual(expectedResult)\n})",
    "explanation": "It splits `list` according to a provided `groupFn` function and returns an object.",
    "example": "const list = [ 'a', 'b', 'aa', 'bb' ]\nconst groupFn = x => x.length\n\nconst result = R.groupBy(groupFn, list)\n// => { '1': ['a', 'b'], '2': ['aa', 'bb'] }",
    "typescriptDefinitionTest": "import {groupBy} from 'rambda'\n\ndescribe('R.groupBy', () => {\n  it('happy', () => {\n    const groupByFn = (x: string) => String(x.length)\n    const list = ['foo', 'barr', 'bazzz']\n\n    const result = groupBy(groupByFn, list)\n    result // $ExpectType { [index: string]: string[]; }\n\n    const curriedResult = groupBy(groupByFn)(list)\n    curriedResult // $ExpectType { [index: string]: string[]; }\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar _isTransformer = require('rambda/internal/_isTransformer');\n\ndescribe('groupBy', function() {\n  it('dispatches on transformer objects in list position', function() {\n    var byType = R.prop('type');\n    var xf = {\n      '@@transducer/init': function() { return {}; },\n      '@@transducer/result': function(x) { return x; },\n      '@@transducer/step': R.mergeRight\n    };\n    eq(_isTransformer(R.groupBy(byType, xf)), true);\n  });\n});",
    "failedSpecsReasons": "Ramda method support transforms",
    "failedSpecsCount": 1
  },
  "groupWith": {
    "typing": "\ngroupWith<T>(compareFn: (x: T, y: T) => boolean): (input: readonly T[]) => T[][]",
    "allTypings": "groupWith<T>(compareFn: (x: T, y: T) => boolean): (input: readonly T[]) => T[][];\ngroupWith<T>(compareFn: (x: T, y: T) => boolean, input: readonly T[]): T[][];\ngroupWith<T>(compareFn: (x: T, y: T) => boolean, input: string): string[];",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nexport function groupWith(compareFn, list){\n  if (!_isArray(list)) throw new TypeError('list.reduce is not a function')\n\n  const clone = list.slice()\n\n  if (list.length === 1) return [ clone ]\n\n  const toReturn = []\n  let holder = []\n\n  clone.reduce((\n    prev, current, i\n  ) => {\n    if (i === 0) return current\n\n    const okCompare = compareFn(prev, current)\n    const holderIsEmpty = holder.length === 0\n    const lastCall = i === list.length - 1\n\n    if (okCompare){\n      if (holderIsEmpty) holder.push(prev)\n      holder.push(current)\n      if (lastCall) toReturn.push(holder)\n\n      return current\n    }\n\n    if (holderIsEmpty){\n      toReturn.push([ prev ])\n      if (lastCall) toReturn.push([ current ])\n\n      return current\n    }\n\n    toReturn.push(holder)\n    if (lastCall) toReturn.push([ current ])\n    holder = []\n\n    return current\n  }, undefined)\n\n  return toReturn\n}",
    "rambdaSpecs": "import { equals } from './equals'\nimport { groupWith } from './groupWith'\n\ntest('issue is fixed', () => {\n  const result = groupWith(equals, [ 1, 2, 2, 3 ])\n  const expected = [ [ 1 ], [ 2, 2 ], [ 3 ] ]\n  expect(result).toEqual(expected)\n})\n\ntest('long list', () => {\n  const result = groupWith(equals, [\n    0,\n    1,\n    1,\n    2,\n    3,\n    5,\n    8,\n    13,\n    21,\n    21,\n    21,\n    1,\n    2,\n  ])\n\n  const expected = [\n    [ 0 ],\n    [ 1, 1 ],\n    [ 2 ],\n    [ 3 ],\n    [ 5 ],\n    [ 8 ],\n    [ 13 ],\n    [ 21, 21, 21 ],\n    [ 1 ],\n    [ 2 ],\n  ]\n  expect(result).toEqual(expected)\n})\n\ntest('readme example', () => {\n  const list = [ 4, 3, 6, 2, 2, 1 ]\n\n  const result = groupWith((a, b) => a - b === 1, list)\n  const expected = [ [ 4, 3 ], [ 6 ], [ 2 ], [ 2, 1 ] ]\n  expect(result).toEqual(expected)\n})\n\ntest('throw with string as input', () => {\n  expect(() => groupWith(equals, 'Mississippi')).toThrowWithMessage(TypeError,\n    'list.reduce is not a function')\n})\n\nconst isConsecutive = function (a, b){\n  return a + 1 === b\n}\n\ntest('fix coverage', () => {\n  expect(groupWith(isConsecutive, [ 1, 2, 3, 0 ])).toEqual([ [ 1, 2, 3 ], [ 0 ] ])\n})\n\ntest('from ramda 0', () => {\n  expect(groupWith(equals, [])).toEqual([])\n  expect(groupWith(isConsecutive, [])).toEqual([])\n})\n\ntest('from ramda 1', () => {\n  expect(groupWith(isConsecutive, [ 4, 3, 2, 1 ])).toEqual([\n    [ 4 ],\n    [ 3 ],\n    [ 2 ],\n    [ 1 ],\n  ])\n})\n\ntest('from ramda 2', () => {\n  expect(groupWith(isConsecutive, [ 1, 2, 3, 4 ])).toEqual([ [ 1, 2, 3, 4 ] ])\n})\n\ntest('from ramda 3', () => {\n  expect(groupWith(isConsecutive, [ 1, 2, 2, 3 ])).toEqual([\n    [ 1, 2 ],\n    [ 2, 3 ],\n  ])\n  expect(groupWith(isConsecutive, [ 1, 2, 9, 3, 4 ])).toEqual([\n    [ 1, 2 ],\n    [ 9 ],\n    [ 3, 4 ],\n  ])\n})\n\ntest('list with single item', () => {\n  const result = groupWith(equals, [ 0 ])\n\n  const expected = [ [ 0 ] ]\n  expect(result).toEqual(expected)\n})",
    "explanation": "It returns separated version of list or string `input`, where separation is done with equality `compareFn` function.",
    "example": "const compareFn = (x, y) => x === y\nconst list = [1, 2, 2, 1, 1, 2]\n\nconst result = R.groupWith(isConsecutive, list)\n// => [[1], [2,2], [1,1], [2]]",
    "typescriptDefinitionTest": "import {groupWith} from 'rambda'\n\ndescribe('R.groupWith', () => {\n  it('happy', () => {\n    const groupWithFn = (x: string, y: string) => x.length === y.length\n    const list = ['foo', 'bar', 'bazzz']\n\n    const result = groupWith(groupWithFn, list)\n    const curriedResult = groupWith(groupWithFn)(list)\n    result // $ExpectType string[][]\n    curriedResult // $ExpectType string[][]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('groupWith', function() {\n  it('can be turned into the original list through concatenation', function() {\n    var list = [1, 1, 2, 3, 4, 4, 5, 5];\n    eq(R.unnest(R.groupWith(R.equals, list)), list);\n    eq(R.unnest(R.groupWith(R.complement(R.equals), list)), list);\n    eq(R.unnest(R.groupWith(R.T, list)), list);\n    eq(R.unnest(R.groupWith(R.F, list)), list);\n  });\n  it('also works on strings', function() {\n    eq(R.groupWith(R.equals)('Mississippi'), ['M','i','ss','i','ss','i','pp','i']);\n  });\n});",
    "failedSpecsReasons": "Ramda method support string",
    "failedSpecsCount": 2
  },
  "has": {
    "typing": "\nhas<T>(prop: string, obj: T): boolean",
    "allTypings": "has<T>(prop: string, obj: T): boolean;\nhas(prop: string): <T>(obj: T) => boolean;",
    "categories": [
      "Object"
    ],
    "rambdaSource": "export function has(prop, obj){\n  if (arguments.length === 1) return _obj => has(prop, _obj)\n\n  if (!obj) return false\n\n  return obj[ prop ] !== undefined\n}",
    "rambdaSpecs": "import { has } from './has'\n\ntest('happy', () => {\n  expect(has('a')({ a : 1 })).toBeTrue()\n  expect(has('b', { a : 1 })).toBeFalse()\n})\n\ntest('with non-object', () => {\n  expect(has('a', undefined)).toEqual(false)\n  expect(has('a', null)).toEqual(false)\n  expect(has('a', true)).toEqual(false)\n  expect(has('a', '')).toEqual(false)\n  expect(has('a', /a/)).toEqual(false)\n})",
    "explanation": "It returns `true` if `obj` has property `prop`.",
    "example": "const obj = {a: 1}\n\nconst result = [\n  R.has('a', obj),\n  R.has('b', obj)\n]\n// => [true, false]",
    "typescriptDefinitionTest": "import {has} from 'rambda'\n\ndescribe('R.has', () => {\n  it('happy', () => {\n    const result = has('foo', {a: 1})\n    const curriedResult = has('bar')({a: 1})\n    result // $ExpectType boolean\n    curriedResult // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('has', function() {\n  var fred = {name: 'Fred', age: 23};\n  var anon = {age: 99};\n  it('does not check properties from the prototype chain', function() {\n    var Person = function() {};\n    Person.prototype.age = function() {};\n    var bob = new Person();\n    eq(R.has('age', bob), false);\n  });\n});",
    "failedSpecsReasons": "Rambda method does check properties from the prototype chain",
    "failedSpecsCount": 1
  },
  "hasPath": {
    "typing": "\nhasPath<T>(\n  path: string | readonly string[],\n  input: object\n): boolean",
    "allTypings": "hasPath<T>(\n  path: string | readonly string[],\n  input: object\n): boolean;\nhasPath<T>(\n  path: string | readonly string[]\n): (input: object) => boolean;",
    "categories": [
      "Object"
    ],
    "rambdaSource": "import { path } from './path'\n\nexport function hasPath(maybePath, obj){\n  if (arguments.length === 1){\n    return objHolder => hasPath(maybePath, objHolder)\n  }\n\n  return path(maybePath, obj) !== undefined\n}",
    "rambdaSpecs": "import { hasPath } from './hasPath'\n\ntest('when true', () => {\n  const path = 'a.b'\n  const obj = { a : { b : [] } }\n\n  const result = hasPath(path)(obj)\n  const expectedResult = true\n\n  expect(result).toEqual(expectedResult)\n})\n\ntest('when false', () => {\n  const path = 'a.b'\n  const obj = {}\n\n  const result = hasPath(path, obj)\n  const expectedResult = false\n\n  expect(result).toEqual(expectedResult)\n})",
    "explanation": "It will return true, if `input` object has truthy `path`(calculated with `R.path`).",
    "example": "const path = 'a.b'\nconst pathAsArray = ['a', 'b']\nconst obj = {a: {b: []}}\n\nconst result = [\n  R.hasPath(path, obj),\n  R.hasPath(pathAsArray, obj),\n  R.hasPath('a.c', obj),\n]\n// => [true, true, false]",
    "typescriptDefinitionTest": "import {hasPath} from 'rambda'\n\ndescribe('R.hasPath', () => {\n  it('string path', () => {\n    const obj = {a: {b: 1}}\n    const result = hasPath('a.b', obj)\n    const curriedResult = hasPath('a.c')(obj)\n    result // $ExpectType boolean\n    curriedResult // $ExpectType boolean\n  })\n  it('array path', () => {\n    const obj = {a: {b: 1}}\n    const result = hasPath(['a', 'b'], obj)\n    const curriedResult = hasPath(['a', 'c'])(obj)\n    result // $ExpectType boolean\n    curriedResult // $ExpectType boolean\n  })\n})"
  },
  "head": {
    "typing": "\nhead<T>(input: readonly T[]): T | undefined",
    "allTypings": "head<T>(input: readonly T[]): T | undefined;\nhead(input: string): string;",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "export function head(listOrString){\n  if (typeof listOrString === 'string') return listOrString[ 0 ] || ''\n\n  return listOrString[ 0 ]\n}",
    "rambdaSpecs": "import { head } from './head'\n\ntest('head', () => {\n  expect(head([ 'fi', 'fo', 'fum' ])).toEqual('fi')\n  expect(head([])).toEqual(undefined)\n  expect(head('foo')).toEqual('f')\n  expect(head('')).toEqual('')\n})",
    "explanation": "It returns the first element of list or string `input`.",
    "example": "const result = [\n  R.head([1, 2, 3]),\n  R.head('foo') \n]\n// => [1, 'f']",
    "typescriptDefinitionTest": "import {head} from 'rambda'\n\ndescribe('R.head', () => {\n  it('string', () => {\n    const result = head('foo')\n    result // $ExpectType string\n  })\n  it('array', () => {\n    const result = head([1, 2, 3])\n    result // $ExpectType number | undefined\n  })\n})"
  },
  "identical": {
    "typing": "\nidentical<T>(x: T, y: T): boolean",
    "allTypings": "identical<T>(x: T, y: T): boolean;\nidentical<T>(x: T): (y: T) => boolean;",
    "categories": [
      "Logic"
    ],
    "notes": "Values are identical if they reference the same memory. `NaN` is identical to `NaN`; `0` and `-0` are not identical.",
    "rambdaSource": "import _objectIs from './_internals/_objectIs'\n\nexport function identical(a, b){\n  if (arguments.length === 1) return _b => identical(a, _b)\n\n  return _objectIs(a, b)\n}",
    "rambdaSpecs": "import { F, T } from '../rambda'\nimport { _isInteger } from './_internals/_isInteger'\nimport { _objectIs } from './_internals/_objectIs'\nimport { identical } from './identical'\n\ntest('with boolean', () => {\n  expect(F()).toBeFalse()\n  expect(T()).toBeTrue()\n})\n\ntest('internal isInteger', () => {\n  expect(_isInteger(1)).toBeTrue()\n  expect(_isInteger(0.3)).toBeFalse()\n})\n\ntest('internal objectIs', () => {\n  expect(_objectIs(1, 1)).toBeTrue()\n  expect(_objectIs(NaN, NaN)).toBeTrue()\n})\n\ntest('identical', () => {\n  const a = {}\n\n  expect(identical(100)(100)).toEqual(true)\n  expect(identical(100, '100')).toEqual(false)\n  expect(identical('string', 'string')).toEqual(true)\n  expect(identical([], [])).toEqual(false)\n  expect(identical(a, a)).toEqual(true)\n  expect(identical(undefined, undefined)).toEqual(true)\n  expect(identical(null, undefined)).toEqual(false)\n})",
    "explanation": "It returns `true` if its arguments `a` and `b` are identical.\n\nOtherwise, it returns `false`.",
    "example": "const obj = {a: 1};\nR.identical(obj, obj); //=> true\nR.identical(1, 1); //=> true\nR.identical(1, '1'); //=> false\nR.identical([], []); //=> false\nR.identical(0, -0); //=> false\nR.identical(NaN, NaN); //=> true",
    "typescriptDefinitionTest": "import {identical} from 'rambda'\n\ndescribe('R.identical', () => {\n  it('happy', () => {\n    const result = identical(4, 1)\n    const curriedResult = identical(4)(1)\n    result // $ExpectType boolean\n    curriedResult // $ExpectType boolean\n  })\n  it('with object', () => {\n    const result = identical({a: 1}, {b: 2})\n    result // $ExpectType boolean\n  })\n})\n\n/*\n    in curried version Typescript correctly catch errors\n    but it doesn't do so in the standart definition\n    \n    identical({a:1},{b:2})\n    identical({a:1})({b:2})\n*/"
  },
  "identity": {
    "typing": "\nidentity<T>(input: T): T",
    "allTypings": "identity<T>(input: T): T;",
    "notes": "Logic",
    "rambdaSource": "export function identity(input){\n  return input\n}",
    "rambdaSpecs": "import { identity } from './identity'\n\ntest('happy', () => {\n  expect(identity(7)).toEqual(7)\n  expect(identity(true)).toEqual(true)\n  expect(identity({ a : 1 })).toEqual({ a : 1 })\n})",
    "explanation": "It just passes back the supplied `input` argument.",
    "example": "R.identity(7) // => 7",
    "typescriptDefinitionTest": "import {identity} from 'rambda'\n\ndescribe('R.identity', () => {\n  it('happy', () => {\n    const result = identity(4)\n    result // $ExpectType 4\n  })\n})"
  },
  "ifElse": {
    "typing": "\nifElse<T, U>(\n  condition: (x: T) => boolean, \n  onTrue: (x: T) => U, \n  onFalse: (x: T) => U, \n): (x: T) => U",
    "allTypings": "ifElse<T, U>(\n  condition: (x: T) => boolean, \n  onTrue: (x: T) => U, \n  onFalse: (x: T) => U, \n): (x: T) => U;\nifElse<T, K, U>(\n  condition: (x: T, y: K) => boolean, \n  onTrue: (x: T, y: K) => U, \n  onFalse: (x: T, y: K) => U, \n): (x: T, y: K) => U;",
    "categories": [
      "Function"
    ],
    "rambdaSource": "import { curry } from './curry'\n\nfunction ifElseFn(\n  condition, onTrue, onFalse\n){\n  return (...input) => {\n    const conditionResult =\n      typeof condition === 'boolean' ? condition : condition(...input)\n\n    if (conditionResult === true){\n      return onTrue(...input)\n    }\n\n    return onFalse(...input)\n  }\n}\n\nexport const ifElse = curry(ifElseFn)",
    "rambdaSpecs": "import { always } from './always'\nimport { has } from './has'\nimport { identity } from './identity'\nimport { ifElse } from './ifElse'\nimport { prop } from './prop'\n\nconst condition = has('foo')\nconst v = function (a){\n  return typeof a === 'number'\n}\nconst t = function (a){\n  return a + 1\n}\nconst ifFn = x => prop('foo', x).length\nconst elseFn = () => false\n\ntest('happy', () => {\n  const fn = ifElse(condition, ifFn)(elseFn)\n\n  expect(fn({ foo : 'bar' })).toEqual(3)\n  expect(fn({ fo : 'bar' })).toEqual(false)\n})\n\ntest('ramda spec', () => {\n  const ifIsNumber = ifElse(v)\n  expect(ifIsNumber(t, identity)(15)).toEqual(16)\n  expect(ifIsNumber(t, identity)('hello')).toEqual('hello')\n})\n\ntest('pass all arguments', () => {\n  const identity = function (a){\n    return a\n  }\n  const v = function (){\n    return true\n  }\n  const onTrue = function (a, b){\n    expect(a).toEqual(123)\n    expect(b).toEqual('abc')\n  }\n  ifElse(\n    v, onTrue, identity\n  )(123, 'abc')\n})\n\ntest('accept constant as condition', () => {\n  const fn = ifElse(true)(always(true))(always(false))\n\n  expect(fn()).toEqual(true)\n})\n\ntest('accept constant as condition - case 2', () => {\n  const fn = ifElse(\n    false, always(true), always(false)\n  )\n\n  expect(fn()).toEqual(false)\n})\n\ntest('curry 1', () => {\n  const fn = ifElse(condition, ifFn)(elseFn)\n\n  expect(fn({ foo : 'bar' })).toEqual(3)\n  expect(fn({ fo : 'bar' })).toEqual(false)\n})\n\ntest('curry 2', () => {\n  const fn = ifElse(condition)(ifFn)(elseFn)\n\n  expect(fn({ foo : 'bar' })).toEqual(3)\n  expect(fn({ fo : 'bar' })).toEqual(false)\n})\n\ntest('simple arity of 1', () => {\n  const condition = x => x > 5\n  const onTrue = x => x + 1\n  const onFalse = x => x + 10\n  const result = ifElse(\n    condition, onTrue, onFalse\n  )(1)\n  expect(result).toBe(11)\n})\n\ntest('simple arity of 2', () => {\n  const condition = (x, y) => x + y > 5\n  const onTrue = (x, y) => x + y + 1\n  const onFalse = (x, y) => x + y + 10\n  const result = ifElse(\n    condition, onTrue, onFalse\n  )(1, 10)\n  expect(result).toBe(12)\n})",
    "explanation": "It expects `condition`, `onTrue` and `onFalse` functions as inputs and it returns a new function with example name of `fn`. \n\nWhen `fn`` is called with `input` argument, it will return either `onTrue(input)` or `onFalse(input)` depending on `condition(input)` evaluation.",
    "example": "const fn = R.ifElse(\n x => x>10,\n x => x*2,\n x => x*10\n)\n\nconst result = [ fn(8), fn(18) ]\n// => [80, 36]",
    "typescriptDefinitionTest": "import {ifElse} from 'rambda'\n\ndescribe('R.ifElse', () => {\n  it('happy', () => {\n    const condition = (x: number) => x > 5\n    const onTrue = (x: number) => `foo${x}`\n    const onFalse = (x: number) => `bar${x}`\n    const fn = ifElse(condition, onTrue, onFalse)\n    fn // $ExpectType (x: number) => string\n    const result = fn(3)\n    result // $ExpectType string\n  })\n  it('arity of 2', () => {\n    const condition = (x: number, y: string) => x + y.length > 5\n    const onTrue = (x: number, y: string) => `foo${x}-${y}`\n    const onFalse = (x: number, y: string) => `bar${x}-${y}`\n    const fn = ifElse(condition, onTrue, onFalse)\n    fn // $ExpectType (x: number, y: string) => string\n    const result = fn(3, 'hello')\n    result // $ExpectType string\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('ifElse', function() {\n  var t = function(a) { return a + 1; };\n  var identity = function(a) { return a; };\n  var isArray = function(a) { return Object.prototype.toString.call(a) === '[object Array]'; };\n  it('returns a function whose arity equals the max arity of the three arguments to `ifElse`', function() {\n    function a0() { return 0; }\n    function a1(x) { return x; }\n    function a2(x, y) { return x + y; }\n    eq(R.ifElse(a0, a1, a2).length, 2);\n    eq(R.ifElse(a0, a2, a1).length, 2);\n    eq(R.ifElse(a1, a0, a2).length, 2);\n    eq(R.ifElse(a1, a2, a0).length, 2);\n    eq(R.ifElse(a2, a0, a1).length, 2);\n    eq(R.ifElse(a2, a1, a0).length, 2);\n  });\n  it('returns a curried function', function() {\n    var v = function(a) { return typeof a === 'number'; };\n    var ifIsNumber = R.ifElse(v);\n    eq(ifIsNumber(t, identity)(15), 16);\n    eq(ifIsNumber(t, identity)('hello'), 'hello');\n    var fn = R.ifElse(R.gt, R.subtract, R.add);\n    eq(fn(2)(7), 9);\n    eq(fn(2, 7), 9);\n    eq(fn(7)(2), 5);\n    eq(fn(7, 2), 5);\n  });\n});",
    "failedSpecsReasons": "Rambda method doesn't return a curried function",
    "failedSpecsCount": 2
  },
  "inc": {
    "typing": "\ninc(x: number): number",
    "allTypings": "inc(x: number): number;",
    "categories": [
      "Number"
    ],
    "rambdaSource": "export const inc = x => x + 1",
    "rambdaSpecs": "import { inc } from './inc'\n\ntest('happy', () => {\n  expect(inc(1)).toBe(2)\n})",
    "explanation": "It increments a number.",
    "example": "R.inc(1) // => 2"
  },
  "includes": {
    "typing": "\nincludes(valueToFind: string, input: readonly string[] | string): boolean",
    "allTypings": "includes(valueToFind: string, input: readonly string[] | string): boolean;\nincludes(valueToFind: string): (input: readonly string[] | string) => boolean;\nincludes<T>(valueToFind: T, input: readonly T[]): boolean;\nincludes<T>(valueToFind: T): (input: readonly T[]) => boolean;",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\nimport { equals } from './equals'\n\nexport function includes(valueToFind, input){\n  if (arguments.length === 1) return _input => includes(valueToFind, _input)\n  if (typeof input === 'string'){\n    return input.includes(valueToFind)\n  }\n  if (!input){\n    throw new TypeError(`Cannot read property \\'indexOf\\' of ${ input }`)\n  }\n  if (!_isArray(input)) return false\n\n  let index = -1\n\n  while (++index < input.length){\n    if (equals(input[ index ], valueToFind)){\n      return true\n    }\n  }\n\n  return false\n}",
    "rambdaSpecs": "import R from 'ramda'\n\nimport { includes } from './includes'\n\ntest('includes with string', () => {\n  const str = 'foo bar'\n\n  expect(includes('bar')(str)).toBeTrue()\n  expect(R.includes('bar')(str)).toBeTrue()\n  expect(includes('never', str)).toBeFalse()\n  expect(R.includes('never', str)).toBeFalse()\n})\n\ntest('includes with array', () => {\n  const arr = [ 1, 2, 3 ]\n\n  expect(includes(2)(arr)).toBeTrue()\n  expect(R.includes(2)(arr)).toBeTrue()\n\n  expect(includes(4, arr)).toBeFalse()\n  expect(R.includes(4, arr)).toBeFalse()\n})\n\ntest('with wrong input that does not throw', () => {\n  const result = includes(1, /foo/g)\n  const ramdaResult = R.includes(1, /foo/g)\n  expect(result).toBeFalse()\n  expect(ramdaResult).toBeFalse()\n})\n\ntest('throws on wrong input - match ramda behaviour', () => {\n  expect(() => includes(2, null)).toThrowWithMessage(TypeError,\n    'Cannot read property \\'indexOf\\' of null')\n  expect(() => R.includes(2, null)).toThrowWithMessage(TypeError,\n    'Cannot read property \\'indexOf\\' of null')\n  expect(() => includes(2, undefined)).toThrowWithMessage(TypeError,\n    'Cannot read property \\'indexOf\\' of undefined')\n  expect(() => R.includes(2, undefined)).toThrowWithMessage(TypeError,\n    'Cannot read property \\'indexOf\\' of undefined')\n})",
    "explanation": "If `input` is string, then this method work as native `String.includes`.\n\nIf `input` is array, then `R.equals` is used to define if `valueToFind` belongs to the list.",
    "example": "const result = [\n  R.includes('oo', 'foo'),\n  R.includes({a: 1}, [{a: 1}])\n]\n// => [true, true ]",
    "typescriptDefinitionTest": "import {includes} from 'rambda'\n\nconst list = [{a: {b: '1'}}, {a: {c: '2'}}, {a: {b: '3'}}]\n\ndescribe('R.includes', () => {\n  it('happy', () => {\n    const result = includes({a: {b: '1'}}, list)\n    result // $ExpectType boolean\n  })\n  it('with string', () => {\n    const result = includes('oo', 'foo')\n    const resultCurried = includes('oo')('foo')\n\n    result // $ExpectType boolean\n    resultCurried // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('includes', function() {\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.includes(0, [-0]), false);\n    eq(R.includes(-0, [0]), false);\n    eq(R.includes(NaN, [NaN]), true);\n    eq(R.includes(new Just([42]), [new Just([42])]), true);\n  });\n});",
    "failedSpecsReasons": "Ramda method pass to `equals` method if available",
    "failedSpecsCount": 1
  },
  "indexBy": {
    "typing": "\nindexBy<T, K extends string | number = string>(condition: (key: T) => K, list: readonly T[]): { [key in K]: T }",
    "allTypings": "indexBy<T, K extends string | number = string>(condition: (key: T) => K, list: readonly T[]): { [key in K]: T };\nindexBy<T, K extends string | number | undefined = string>(condition: (key: T) => K, list: readonly T[]): { [key in NonNullable<K>]?: T };\nindexBy<T, K extends string | number = string>(condition: (key: T) => K): (list: readonly T[]) => { [key in K]: T };\nindexBy<T, K extends string | number | undefined = string>(condition: (key: T) => K | undefined): (list: readonly T[]) => { [key in NonNullable<K>]?: T };\nindexBy<T>(condition: string, list: readonly T[]): { [key: string]: T };\nindexBy<T>(condition: string): (list: readonly T[]) => { [key: string]: T };",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { path } from './path'\n\nfunction indexByPath(pathInput, list){\n  const toReturn = {}\n  for (let i = 0; i < list.length; i++){\n    const item = list[ i ]\n    toReturn[ path(pathInput, item) ] = item\n  }\n\n  return toReturn\n}\n\nexport function indexBy(condition, list){\n  if (arguments.length === 1){\n    return _list => indexBy(condition, _list)\n  }\n\n  if (typeof condition === 'string'){\n    return indexByPath(condition, list)\n  }\n\n  const toReturn = {}\n  for (let i = 0; i < list.length; i++){\n    const item = list[ i ]\n    toReturn[ condition(item) ] = item\n  }\n\n  return toReturn\n}",
    "rambdaSpecs": "import { indexBy } from './indexBy'\nimport { prop } from './prop'\n\ntest('happy', () => {\n  const list = [\n    { id : 1 },\n    {\n      id : 1,\n      a  : 2,\n    },\n    { id : 2 },\n    { id : 10 },\n    { id : 'a' },\n  ]\n\n  expect(indexBy(prop('id'))(list)).toEqual({\n    1 : {\n      id : 1,\n      a  : 2,\n    },\n    2  : { id : 2 },\n    10 : { id : 10 },\n    a  : { id : 'a' },\n  })\n})\n\ntest('with string as condition', () => {\n  const list = [ { id : 1 }, { id : 2 }, { id : 10 }, { id : 'a' } ]\n  const standardResult = indexBy(obj => obj.id, list)\n  const suggestionResult = indexBy('id', list)\n\n  expect(standardResult).toEqual(suggestionResult)\n})\n\ntest('with string - bad path', () => {\n  const list = [\n    {\n      a : {\n        b : 1,\n        c : 2,\n      },\n    },\n    { a : { c : 4 } },\n    {},\n    {\n      a : {\n        b : 10,\n        c : 20,\n      },\n    },\n  ]\n\n  const result = indexBy('a.b', list)\n  const expected = {\n    1 : {\n      a : {\n        b : 1,\n        c : 2,\n      },\n    },\n    10 : {\n      a : {\n        b : 10,\n        c : 20,\n      },\n    },\n    undefined : {},\n  }\n\n  expect(result).toEqual(expected)\n})",
    "explanation": "It generates object with properties provided by `condition` and values provided by `list` array.\n\nIf `condition` is a function, then all list members are passed through it.\n\nIf `condition` is a string, then all list members are passed through `R.path(condition)`.",
    "example": "const list = [ {id: 10}, {id: 20} ]\n\nconst withFunction = R.indexBy(\n  x => x.id,\n  list\n)\nconst withString = R.indexBy(\n  'id',\n  list\n)\nconst result = [\n  withFunction, \n  R.equals(withFunction, withString)\n]\n// => [ { 10: {id: 10}, 20: {id: 20} }, true ]",
    "typescriptDefinitionTest": "import {indexBy} from 'rambda'\n\nconst list = [{a: {b: '1'}}, {a: {c: '2'}}, {a: {b: '3'}}]\n\ndescribe('indexBy', () => {\n  it('happy', () => {\n    const result = indexBy(x => x.a.b, list)\n    const resultCurried = indexBy<any>(x => x.a.b)(list)\n    result.foo?.a.b // $ExpectType string | undefined\n    resultCurried // $ExpectType { [x: string]: any; }\n  })\n\n  it('with string', () => {\n    const result = indexBy('a.b', list)\n    const resultCurried = indexBy<any>('a.b')(list)\n    result.foo?.a.b // $ExpectType string | undefined\n    resultCurried // $ExpectType { [key: string]: any; }\n  })\n\n  it('with interface', () => {\n    interface Foo {\n      a: string,\n    }\n    const interfaceList = [{a: 'foo'}, {a: 'bar'}]\n    const result = indexBy<Foo>(x => {\n      x.a // $ExpectType string\n      return x.a\n    }, interfaceList)\n    const resultCurried = indexBy<Foo>(x => {\n      x.a // $ExpectType string\n      return x.a\n    })(interfaceList)\n    result // $ExpectType { [x: string]: Foo; }\n    resultCurried // $ExpectType { [x: string]: Foo; }\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('indexBy', function() {\n  it('can act as a transducer', function() {\n    var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];\n    var transducer = R.compose(\n      R.indexBy(R.prop('id')),\n      R.map(R.pipe(\n        R.adjust(0, R.toUpper),\n        R.adjust(1, R.omit(['id']))\n      )));\n    var result = R.into({}, transducer, list);\n    eq(result, {ABC: {title: 'B'}, XYZ: {title: 'A'}});\n  });\n});",
    "failedSpecsReasons": "Ramda method can act as a transducer",
    "failedSpecsCount": 1
  },
  "indexOf": {
    "typing": "\nindexOf<T>(valueToFind: T, list: readonly T[]): number",
    "allTypings": "indexOf<T>(valueToFind: T, list: readonly T[]): number;\nindexOf<T>(valueToFind: T): (list: readonly T[]) => number;",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function indexOf(valueToFind, list){\n  if (arguments.length === 1){\n    return _list => indexOf(valueToFind, _list)\n  }\n\n  let index = -1\n  const { length } = list\n\n  while (++index < length){\n    if (list[ index ] === valueToFind){\n      return index\n    }\n  }\n\n  return -1\n}",
    "rambdaSpecs": "import { indexOf } from './indexOf'\n\ntest('happy', () => {\n  expect(indexOf(3, [ 1, 2, 3, 4 ])).toEqual(2)\n\n  expect(indexOf(10)([ 1, 2, 3, 4 ])).toEqual(-1)\n})",
    "explanation": "It returns the index of the first element of `list` equals to `valueToFind`.\n\nIf there is no such element, it returns `-1`.",
    "example": "const list = [0, 1, 2, 3]\n\nconst result = [\n  R.indexOf(2, list),\n  R.indexOf(0, list)\n]\n// => [2, -1]",
    "typescriptDefinitionTest": "import {indexOf} from 'rambda'\n\ndescribe('R.indexOf', () => {\n  it('happy', () => {\n    const list = [1, 2, 3]\n    const result = indexOf(1, list)\n    const curriedResult = indexOf(1)(list)\n\n    result // $ExpectType number\n    curriedResult // $ExpectType number\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('indexOf', function() {\n  var input = [1, 2, 3, 4, 5];\n  var list = [1, 2, 3];\n  list[-2] = 4; // Throw a wrench in the gears by assigning a non-valid array index as object property.\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.indexOf(0, [-0]), -1);\n    eq(R.indexOf(-0, [0]), -1);\n    eq(R.indexOf(NaN, [NaN]), 0);\n    eq(R.indexOf(new Just([42]), [new Just([42])]), 0);\n  });\n  it('dispatches to `indexOf` method', function() {\n    function Empty() {}\n    Empty.prototype.indexOf = R.always(-1);\n    function List(head, tail) {\n      this.head = head;\n      this.tail = tail;\n    }\n    List.prototype.indexOf = function(x) {\n      var idx = this.tail.indexOf(x);\n      return this.head === x ? 0 : idx >= 0 ? 1 + idx : -1;\n    };\n    var list = new List('b',\n      new List('a',\n        new List('n',\n          new List('a',\n            new List('n',\n              new List('a',\n                new Empty()\n              )\n            )\n          )\n        )\n      )\n    );\n    eq(R.indexOf('a', 'banana'), 1);\n    eq(R.indexOf('x', 'banana'), -1);\n    eq(R.indexOf('a', list), 1);\n    eq(R.indexOf('x', list), -1);\n  });\n});",
    "failedSpecsReasons": "Ramda method dispatches to `indexOf` method",
    "failedSpecsCount": 2
  },
  "init": {
    "typing": "\ninit<T>(input: readonly T[]): T[]",
    "allTypings": "init<T>(input: readonly T[]): T[];\ninit(input: string): string;",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "import baseSlice from './_internals/baseSlice'\n\nexport function init(listOrString){\n  if (typeof listOrString === 'string') return listOrString.slice(0, -1)\n\n  return listOrString.length ? baseSlice(\n    listOrString, 0, -1\n  ) : []\n}",
    "rambdaSpecs": "import { init } from './init'\n\ntest('with array', () => {\n  expect(init([ 1, 2, 3 ])).toEqual([ 1, 2 ])\n  expect(init([ 1, 2 ])).toEqual([ 1 ])\n  expect(init([ 1 ])).toEqual([])\n  expect(init([])).toEqual([])\n  expect(init([])).toEqual([])\n  expect(init([ 1 ])).toEqual([])\n})\n\ntest('with string', () => {\n  expect(init('foo')).toEqual('fo')\n  expect(init('f')).toEqual('')\n  expect(init('')).toEqual('')\n})",
    "explanation": "It returns all but the last element of list or string `input`.",
    "example": "const result = [\n  R.init([1, 2, 3]) , \n  R.init('foo')  // => 'fo'\n]\n// => [[1, 2], 'fo']",
    "typescriptDefinitionTest": "import {init} from 'rambda'\n\ndescribe('R.init', () => {\n  it('with string', () => {\n    const result = init('foo')\n\n    result // $ExpectType string\n  })\n  it('with list', () => {\n    const result = init([1, 2, 3])\n\n    result // $ExpectType number[]\n  })\n})"
  },
  "intersection": {
    "typing": "\nintersection<T>(listA: readonly T[], listB: readonly T[]): T[]",
    "allTypings": "intersection<T>(listA: readonly T[], listB: readonly T[]): T[];\nintersection<T>(listA: readonly T[]): (listB: readonly T[]) => T[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { filter } from './filter'\nimport { includes } from './includes'\n\nexport function intersection(listA, listB){\n  if (arguments.length === 1) return _list => intersection(listA, _list)\n\n  return filter(value => includes(value, listB), listA)\n}",
    "rambdaSpecs": "import { intersection } from './intersection'\n\ntest('intersection', () => {\n  const list1 = [ 1, 2, 3, 4 ]\n  const list2 = [ 3, 4, 5, 6 ]\n  expect(intersection(list1)(list2)).toEqual([ 3, 4 ])\n\n  expect(intersection([], [])).toEqual([])\n})\n\ntest('intersection with objects', () => {\n  const list1 = [ { id : 1 }, { id : 2 }, { id : 3 }, { id : 4 } ]\n  const list2 = [ { id : 3 }, { id : 4 }, { id : 5 }, { id : 6 } ]\n  expect(intersection(list1)(list2)).toEqual([ { id : 3 }, { id : 4 } ])\n})",
    "explanation": "It loops throw `listA` and `listB` and returns the intersection of the two according to `R.equals`.",
    "example": "const listA = [ { id : 1 }, { id : 2 }, { id : 3 }, { id : 4 } ]\nconst listB = [ { id : 3 }, { id : 4 }, { id : 5 }, { id : 6 } ]\n\nconst result = intersection(listA, listB)\n// => [{ id : 3 }, { id : 4 }]",
    "typescriptDefinitionTest": "import {intersection} from 'rambda'\n\nconst list1 = [1, 2, 3]\nconst list2 = [1, 3, 5]\n\ndescribe('R.intersection', () => {\n  it('happy', () => {\n    const result = intersection(list1, list2)\n    result // $ExpectType number[]\n\n    const curriedResult = intersection(list1)(list2)\n    curriedResult // $ExpectType number[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('intersection', function() {\n  var M = [1, 2, 3, 4];\n  var M2 = [1, 2, 3, 4, 1, 2, 3, 4];\n  var N = [3, 4, 5, 6];\n  var N2 = [3, 3, 4, 4, 5, 5, 6, 6];\n  it('does not allow duplicates in the output even if the input lists had duplicates', function() {\n    eq(R.intersection(M2, N2), [3, 4]);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.intersection([0], [-0]).length, 0);\n    eq(R.intersection([-0], [0]).length, 0);\n    eq(R.intersection([NaN], [NaN]).length, 1);\n    eq(R.intersection([new Just([42])], [new Just([42])]).length, 1);\n  });\n});"
  },
  "intersperse": {
    "typing": "\nintersperse<T>(separator: T, list: readonly T[]): T[]",
    "allTypings": "intersperse<T>(separator: T, list: readonly T[]): T[];\nintersperse<T>(separator: T): (list: readonly T[]) => T[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function intersperse(separator, list){\n  if (arguments.length === 1) return _list => intersperse(separator, _list)\n\n  let index = -1\n  const len = list.length\n  const willReturn = []\n\n  while (++index < len){\n    if (index === len - 1){\n      willReturn.push(list[ index ])\n    } else {\n      willReturn.push(list[ index ], separator)\n    }\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { intersperse } from './intersperse'\n\ntest('intersperse', () => {\n  const list = [ { id : 1 }, { id : 2 }, { id : 10 }, { id : 'a' } ]\n  expect(intersperse('!', list)).toEqual([\n    { id : 1 },\n    '!',\n    { id : 2 },\n    '!',\n    { id : 10 },\n    '!',\n    { id : 'a' },\n  ])\n\n  expect(intersperse('!')([])).toEqual([])\n})",
    "explanation": "It adds a `separator` between members of `list`.",
    "example": "const list = [ 0, 1, 2, 3 ]\nconst separator = '|'\nconst result = intersperse(separator, list)\n// => [0, '|', 1, '|', 2, '|', 3]",
    "typescriptDefinitionTest": "import {intersperse} from 'rambda'\n\ndescribe('R.intersperse', () => {\n  it('happy', () => {\n    const result = intersperse(1, [1, 2, 3])\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = intersperse('|')(['foo', 'bar'])\n    result // $ExpectType string[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('intersperse', function() {\n  it('dispatches', function() {\n    var obj = {intersperse: function(x) { return 'override ' + x; }};\n    eq(R.intersperse('x', obj), 'override x');\n  });\n});"
  },
  "is": {
    "typing": "\nis(targetPrototype: any, x: any): boolean",
    "allTypings": "is(targetPrototype: any, x: any): boolean;\nis(targetPrototype: any): (x: any) => boolean;",
    "categories": [
      "Logic"
    ],
    "rambdaSource": "export function is(targetPrototype, x){\n  if (arguments.length === 1) return _x => is(targetPrototype, _x)\n\n  return (\n    x != null && x.constructor === targetPrototype ||\n    x instanceof targetPrototype\n  )\n}",
    "rambdaSpecs": "import { is } from './is'\n\ntest('works with built-in types', () => {\n  expect(is(Array, undefined)).toBeFalse()\n  expect(is(Array)([])).toBeTrue()\n  expect(is(Boolean, new Boolean(false))).toBeTrue()\n  expect(is(Date, new Date())).toBeTrue()\n  expect(is(Function, () => {})).toBeTrue()\n  expect(is(Number, new Number(0))).toBeTrue()\n  expect(is(Object, {})).toBeTrue()\n  expect(is(RegExp, /(?:)/)).toBeTrue()\n  expect(is(String, new String(''))).toBeTrue()\n})\n\ntest('works with user-defined types', () => {\n  function Foo(){}\n  function Bar(){}\n  Bar.prototype = new Foo()\n\n  const foo = new Foo()\n  const bar = new Bar()\n\n  expect(is(Foo, foo)).toBeTrue()\n  expect(is(Bar, bar)).toBeTrue()\n  expect(is(Foo, bar)).toBeTrue()\n  expect(is(Bar, foo)).toBeFalse()\n})\n\ntest('does not coerce', () => {\n  expect(is(Boolean, 1)).toBeFalse()\n  expect(is(Number, '1')).toBeFalse()\n  expect(is(Number, false)).toBeFalse()\n})\n\ntest('recognizes primitives as their object equivalents', () => {\n  expect(is(Boolean, false)).toBeTrue()\n  expect(is(Number, 0)).toBeTrue()\n  expect(is(String, '')).toBeTrue()\n})\n\ntest('does not consider primitives to be instances of Object', () => {\n  expect(is(Object, false)).toBeFalse()\n  expect(is(Object, 0)).toBeFalse()\n  expect(is(Object, '')).toBeFalse()\n})",
    "explanation": "It returns `true` if `x` is instance of `targetPrototype`.",
    "example": "const result = [\n  R.is(String, 'foo'),  \n  R.is(Array, 1)\n]\n// => [true, false]",
    "typescriptDefinitionTest": "import {is} from 'rambda'\n\ndescribe('R.is', () => {\n  it('happy', () => {\n    const result = is(String, 'foo')\n    result // $ExpectType boolean\n  })\n  it('curried', () => {\n    const result = is(Number)(1)\n    result // $ExpectType boolean\n  })\n})"
  },
  "isEmpty": {
    "typing": "\nisEmpty<T>(x: T): boolean",
    "allTypings": "isEmpty<T>(x: T): boolean;",
    "categories": [
      "Logic"
    ],
    "rambdaSource": "import { type } from './type'\n\nexport function isEmpty(input){\n  const inputType = type(input)\n  if ([ 'Undefined', 'NaN', 'Number', 'Null' ].includes(inputType))\n    return false\n  if (!input) return true\n\n  if (inputType === 'Object'){\n    return Object.keys(input).length === 0\n  }\n\n  if (inputType === 'Array'){\n    return input.length === 0\n  }\n\n  return false\n}",
    "rambdaSpecs": "import { isEmpty } from './isEmpty'\n\ntest('happy', () => {\n  expect(isEmpty(undefined)).toEqual(false)\n  expect(isEmpty('')).toEqual(true)\n  expect(isEmpty(null)).toEqual(false)\n  expect(isEmpty(' ')).toEqual(false)\n  expect(isEmpty(new RegExp(''))).toEqual(false)\n  expect(isEmpty([])).toEqual(true)\n  expect(isEmpty([ [] ])).toEqual(false)\n  expect(isEmpty({})).toEqual(true)\n  expect(isEmpty({ x : 0 })).toEqual(false)\n  expect(isEmpty(0)).toEqual(false)\n  expect(isEmpty(NaN)).toEqual(false)\n  expect(isEmpty([ '' ])).toEqual(false)\n})",
    "explanation": "It returns `true` if `x` is `empty`.",
    "example": "const result = [\n  R.isEmpty(''),\n  R.isEmpty({ x : 0 })\n]\n// => [true, false]",
    "typescriptDefinitionTest": "import {isEmpty} from 'rambda'\n\ndescribe('R.isEmpty', () => {\n  it('happy', () => {\n    const result = isEmpty('foo')\n    result // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('isEmpty', function() {\n  it('returns true for empty typed array', function() {\n    eq(R.isEmpty(Uint8Array.from('')), true);\n    eq(R.isEmpty(Float32Array.from('')), true);\n    eq(R.isEmpty(new Float32Array([])), true);\n    eq(R.isEmpty(Uint8Array.from('1')), false);\n    eq(R.isEmpty(Float32Array.from('1')), false);\n    eq(R.isEmpty(new Float32Array([1])), false);\n  });\n});",
    "failedSpecsReasons": "Ramda method supports typed arrays",
    "failedSpecsCount": 1
  },
  "isNil": {
    "typing": "\nisNil(x: any): x is null | undefined",
    "allTypings": "isNil(x: any): x is null | undefined;",
    "categories": [
      "Logic"
    ],
    "rambdaSource": "export function isNil(x){\n  return x === undefined || x === null\n}",
    "rambdaSpecs": "import { isNil } from './isNil'\n\ntest('happy', () => {\n  expect(isNil(null)).toBeTrue()\n\n  expect(isNil(undefined)).toBeTrue()\n\n  expect(isNil([])).toBeFalse()\n})",
    "explanation": "It returns `true` if `x` is either `null` or `undefined`.",
    "example": "const result = [\n  R.isNil(null),\n  R.isNil(1),\n]\n// => [true, false]"
  },
  "join": {
    "typing": "\njoin<T>(glue: string, list: readonly T[]): string",
    "allTypings": "join<T>(glue: string, list: readonly T[]): string;\njoin<T>(glue: string): (list: readonly T[]) => string;",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function join(glue, list){\n  if (arguments.length === 1) return _list => join(glue, _list)\n\n  return list.join(glue)\n}",
    "rambdaSpecs": "import { join } from './join'\n\ntest('curry', () => {\n  expect(join('|')([ 'foo', 'bar', 'baz' ])).toEqual('foo|bar|baz')\n\n  expect(join('|', [ 1, 2, 3 ])).toEqual('1|2|3')\n\n  const spacer = join(' ')\n\n  expect(spacer([ 'a', 2, 3.4 ])).toEqual('a 2 3.4')\n})",
    "explanation": "It returns a string of all `list` instances joined with a `glue`.",
    "example": "R.join('-', [1, 2, 3])  // => '1-2-3'",
    "typescriptDefinitionTest": "import {join} from 'rambda'\n\ndescribe('R.join', () => {\n  it('happy', () => {\n    const result = join('|', [1, 2, 3])\n    result // $ExpectType string\n  })\n})"
  },
  "keys": {
    "typing": "\nkeys<T extends object>(x: T): (keyof T)[]",
    "allTypings": "keys<T extends object>(x: T): (keyof T)[];\nkeys<T>(x: T): string[];",
    "categories": [
      "Object"
    ],
    "rambdaSource": "export function keys(x){\n  return Object.keys(x)\n}",
    "rambdaSpecs": "import { keys } from './keys'\n\ntest('happy', () => {\n  expect(keys({ a : 1 })).toEqual([ 'a' ])\n})",
    "explanation": "It applies `Object.keys` over `x` and returns its keys.",
    "example": "R.keys({a:1, b:2})  // => ['a', 'b']",
    "typescriptDefinitionTest": "import {keys} from 'rambda'\n\nconst obj = {a: 1, b: 2}\n\ndescribe('R.keys', () => {\n  it('happy', () => {\n    const result = keys(obj)\n    result // $ExpectType (\"b\" | \"a\")[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('keys', function() {\n  var obj = {a: 100, b: [1, 2, 3], c: {x: 200, y: 300}, d: 'D', e: null, f: undefined};\n  function C() { this.a = 100; this.b = 200; }\n  C.prototype.x = function() { return 'x'; };\n  C.prototype.y = 'y';\n  var cobj = new C();\n  it('works for primitives', function() {\n    eq(R.keys(null), []);\n    eq(R.keys(undefined), []);\n    eq(R.keys(55), []);\n    eq(R.keys('foo'), []);\n    eq(R.keys(true), []);\n    eq(R.keys(false), []);\n    eq(R.keys(NaN), []);\n    eq(R.keys(Infinity), []);\n    eq(R.keys([]), []);\n  });\n});",
    "failedSpecsReasons": "Ramda method works for primitives",
    "failedSpecsCount": 1
  },
  "last": {
    "typing": "\nlast(str: string): string",
    "allTypings": "last(str: string): string;\nlast(emptyList: []): undefined;\nlast<T extends any>(list: readonly T[]): T | undefined;",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "export function last(listOrString){\n  if (typeof listOrString === 'string'){\n    return listOrString[ listOrString.length - 1 ] || ''\n  }\n\n  return listOrString[ listOrString.length - 1 ]\n}",
    "rambdaSpecs": "import { last } from './last'\n\ntest('happy', () => {\n  expect(last([ 'foo', 'bar', 'baz' ])).toEqual('baz')\n  expect(last([])).toEqual(undefined)\n  expect(last('abc')).toEqual('c')\n  expect(last('')).toEqual('')\n})",
    "explanation": "It returns the last element of `input`, as the `input` can be either a string or an array.",
    "example": "const result = [\n  R.last([1, 2, 3]),\n  R.last('foo'),\n]\n// => [3, 'o']",
    "typescriptDefinitionTest": "import {last} from 'rambda'\n\ndescribe('R.last', () => {\n  it('string', () => {\n    const result = last('foo')\n    result // $ExpectType string\n  })\n\n  it('array', () => {\n    const result = last([1, 2, 3])\n    result // $ExpectType number | undefined\n  })\n\n  it('empty array', () => {\n    const result = last([])\n    result // $ExpectType undefined\n  })\n})"
  },
  "lastIndexOf": {
    "typing": "\nlastIndexOf<T>(target: T, list: readonly T[]): number",
    "allTypings": "lastIndexOf<T>(target: T, list: readonly T[]): number;\nlastIndexOf<T>(target: T): (list: readonly T[]) => number;",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { equals } from './equals'\n\nexport function lastIndexOf(target, list){\n  if (arguments.length === 1) return _list => lastIndexOf(target, _list)\n\n  let index = list.length\n\n  while (--index > 0){\n    if (equals(list[ index ], target)){\n      return index\n    }\n  }\n\n  return -1\n}",
    "rambdaSpecs": "import { lastIndexOf } from './lastIndexOf'\n\ntest('happy', () => {\n  const a = lastIndexOf(1, [ 1, 2, 3, 1, 2 ])\n  const b = lastIndexOf(1)([ 1, 2, 3, 1, 2 ])\n\n  expect(a).toEqual(3)\n  expect(b).toEqual(3)\n})\n\ntest('false', () => {\n  const a = lastIndexOf(10, [ 1, 2, 3, 1, 2 ])\n\n  expect(a).toEqual(-1)\n})",
    "explanation": "It returns the last index of `target` in `list` array.\n\n`R.equals` is used to determine equality between `target` and members of `list`.\n\nIf there is no such index, then `-1` is returned.",
    "example": "const list = [1, 2, 3, 1, 2, 3]\nconst result = [\n  R.lastIndexOf(2, list),\n  R.lastIndexOf(4, list),\n]\n// => [4, -1]",
    "typescriptDefinitionTest": "import {lastIndexOf} from 'rambda'\n\nconst list = [1, 2, 3]\n\ndescribe('R.lastIndexOf', () => {\n  it('happy', () => {\n    const result = lastIndexOf(2, list)\n    result // $ExpectType number\n  })\n  it('curried', () => {\n    const result = lastIndexOf(2)(list)\n    result // $ExpectType number\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('lastIndexOf', function() {\n  var input = [1, 2, 3, 4, 5, 1];\n  var list = ['a', 1, 'a'];\n  list[-2] = 'a'; // Throw a wrench in the gears by assigning a non-valid array index as object property.\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.lastIndexOf(0, [-0]), -1);\n    eq(R.lastIndexOf(-0, [0]), -1);\n    eq(R.lastIndexOf(NaN, [NaN]), 0);\n    eq(R.lastIndexOf(new Just([42]), [new Just([42])]), 0);\n  });\n  it('dispatches to `lastIndexOf` method', function() {\n    function Empty() {}\n    Empty.prototype.lastIndexOf = R.always(-1);\n    function List(head, tail) {\n      this.head = head;\n      this.tail = tail;\n    }\n    List.prototype.lastIndexOf = function(x) {\n      var idx = this.tail.lastIndexOf(x);\n      return idx >= 0 ? 1 + idx : this.head === x ? 0 : -1;\n    };\n    var list = new List('b',\n      new List('a',\n        new List('n',\n          new List('a',\n            new List('n',\n              new List('a',\n                new Empty()\n              )\n            )\n          )\n        )\n      )\n    );\n    eq(R.lastIndexOf('a', 'banana'), 5);\n    eq(R.lastIndexOf('x', 'banana'), -1);\n    eq(R.lastIndexOf('a', list), 5);\n    eq(R.lastIndexOf('x', list), -1);\n  });\n  it('finds function, compared by identity', function() {\n    var f = function() {};\n    var g = function() {};\n    var list = [g, f, g, f];\n    eq(R.lastIndexOf(f, list), 3);\n  });\n});",
    "failedSpecsReasons": "Ramda method dispatches to `lastIndexOf` method",
    "failedSpecsCount": 3
  },
  "length": {
    "typing": "\nlength<T>(input: readonly T[]): number",
    "allTypings": "length<T>(input: readonly T[]): number;",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "export function length(x){\n  if (!x && x !== '' || x.length === undefined){\n    return NaN\n  }\n\n  return x.length\n}",
    "rambdaSpecs": "import { length } from './length'\n\ntest('happy', () => {\n  expect(length('foo')).toEqual(3)\n  expect(length([ 1, 2, 3 ])).toEqual(3)\n  expect(length([])).toEqual(0)\n})\n\ntest('with empty string', () => {\n  expect(length('')).toEqual(0)\n})\n\ntest('with bad input returns NaN', () => {\n  expect(length(0)).toBeNaN()\n  expect(length({})).toBeNaN()\n  expect(length(null)).toBeNaN()\n  expect(length(undefined)).toBeNaN()\n})",
    "explanation": "It returns the `length` property of list or string `input`.",
    "example": "const result = [\n  R.length([1, 2, 3, 4]),\n  R.length('foo'),\n]\n// => [4, 3]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('length', function() {\n  it('returns the length of a string', function() {\n    eq(R.length(''), 0);\n    eq(R.length('xyz'), 3);\n  });\n  it('returns NaN for length property of unexpected type', function() {\n    eq(R.identical(NaN, R.length({length: ''})), true);\n    eq(R.identical(NaN, R.length({length: '1.23'})), true);\n    eq(R.identical(NaN, R.length({length: null})), true);\n    eq(R.identical(NaN, R.length({length: undefined})), true);\n    eq(R.identical(NaN, R.length({})), true);\n  });\n});",
    "failedSpecsReasons": "Ramda method supports object with `length` method",
    "failedSpecsCount": 1
  },
  "lens": {
    "typing": "\nlens<T, U, V>(getter: (s: T) => U, setter: (a: U, s: T) => V): Lens",
    "allTypings": "lens<T, U, V>(getter: (s: T) => U, setter: (a: U, s: T) => V): Lens;",
    "categories": [
      "Lenses"
    ],
    "rambdaSource": "export function lens(getter, setter){\n  return function (functor){\n    return function (target){\n      return functor(getter(target)).map(focus => setter(focus, target))\n    }\n  }\n}",
    "explanation": "It returns a `lens` for the given `getter` and `setter` functions. \n\nThe `getter` **gets** the value of the focus; the `setter` **sets** the value of the focus. \n\nThe setter should not mutate the data structure.",
    "example": "const xLens = R.lens(R.prop('x'), R.assoc('x'));\n\nR.view(xLens, {x: 1, y: 2}) // => 1\nR.set(xLens, 4, {x: 1, y: 2}) // => {x: 4, y: 2}\nR.over(xLens, R.negate, {x: 1, y: 2}) // => {x: -1, y: 2}",
    "typescriptDefinitionTest": "import {lens, assoc} from 'rambda'\n\ninterface Input {\n  foo: string,\n}\n\ndescribe('R.lens', () => {\n  it('happy', () => {\n    const fn = lens<Input, string, string>((x: Input) => {\n      x.foo // $ExpectType string\n      return x.foo\n    }, assoc('name'))\n    fn // $ExpectType Lens\n  })\n})"
  },
  "lensIndex": {
    "typing": "\nlensIndex(index: number): Lens",
    "allTypings": "lensIndex(index: number): Lens;",
    "categories": [
      "Lenses"
    ],
    "rambdaSource": "import { lens } from './lens'\nimport { nth } from './nth'\nimport { update } from './update'\n\nexport function lensIndex(index){\n  return lens(nth(index), update(index))\n}",
    "rambdaSpecs": "import { compose } from './compose'\nimport { keys } from './keys'\nimport { lensIndex } from './lensIndex'\nimport { over } from './over'\nimport { set } from './set'\nimport { view } from './view'\n\nconst testList = [ { a : 1 }, { b : 2 }, { c : 3 } ]\n\ntest('focuses list element at the specified index', () => {\n  expect(view(lensIndex(0), testList)).toEqual({ a : 1 })\n})\n\ntest('returns undefined if the specified index does not exist', () => {\n  expect(view(lensIndex(10), testList)).toEqual(undefined)\n})\n\ntest('sets the list value at the specified index', () => {\n  expect(set(\n    lensIndex(0), 0, testList\n  )).toEqual([ 0, { b : 2 }, { c : 3 } ])\n})\n\ntest('applies function to the value at the specified list index', () => {\n  expect(over(\n    lensIndex(2), keys, testList\n  )).toEqual([ { a : 1 }, { b : 2 }, [ 'c' ] ])\n})\n\ntest('can be composed', () => {\n  const nestedList = [ 0, [ 10, 11, 12 ], 1, 2 ]\n  const composedLens = compose(lensIndex(1), lensIndex(0))\n\n  expect(view(composedLens, nestedList)).toEqual(10)\n})\n\ntest('set s (get s) === s', () => {\n  expect(set(\n    lensIndex(0), view(lensIndex(0), testList), testList\n  )).toEqual(testList)\n})\n\ntest('get (set s v) === v', () => {\n  expect(view(lensIndex(0), set(\n    lensIndex(0), 0, testList\n  ))).toEqual(0)\n})\n\ntest('get (set(set s v1) v2) === v2', () => {\n  expect(view(lensIndex(0),\n    set(\n      lensIndex(0), 11, set(\n        lensIndex(0), 10, testList\n      )\n    ))).toEqual(11)\n})",
    "explanation": "It returns a lens that focuses on specified `index`.",
    "example": "const list = ['a', 'b', 'c']\nconst headLens = R.lensIndex(0)\n\nR.view(headLens, list) // => 'a'\nR.set(headLens, 'x', list) // => ['x', 'b', 'c']\nR.over(headLens, R.toUpper, list) // => ['A', 'b', 'c']",
    "typescriptDefinitionTest": "import {view, lensIndex} from 'rambda'\n\ninterface Input {\n  a: number,\n}\nconst testList: Input[] = [{a: 1}, {a: 2}, {a: 3}]\n\ndescribe('R.lensIndex', () => {\n  it('happy', () => {\n    const result = view<Input[], Input>(lensIndex(0), testList)\n    result // $ExpectType Input\n    result.a // $ExpectType number\n  })\n})"
  },
  "lensPath": {
    "typing": "\nlensPath(path: RamdaPath): Lens",
    "allTypings": "lensPath(path: RamdaPath): Lens;\nlensPath(path: string): Lens;",
    "categories": [
      "Lenses"
    ],
    "rambdaSource": "import { assocPath } from './assocPath'\nimport { lens } from './lens'\nimport { path } from './path'\n\nexport function lensPath(key){\n  return lens(path(key), assocPath(key))\n}",
    "rambdaSpecs": "import { compose } from './compose'\nimport { identity } from './identity'\nimport { inc } from './inc'\nimport { lensPath } from './lensPath'\nimport { lensProp } from './lensProp'\nimport { over } from './over'\nimport { set } from './set'\nimport { view } from './view'\n\nconst testObj = {\n  a : [ { b : 1 }, { b : 2 } ],\n  d : 3,\n}\n\ntest('view', () => {\n  expect(view(lensPath('d'), testObj)).toEqual(3)\n  expect(view(lensPath('a.0.b'), testObj)).toEqual(1)\n  // this is different to ramda, as ramda will return a clone of the input object\n  expect(view(lensPath(''), testObj)).toEqual(undefined)\n})\n\ntest('set', () => {\n  expect(set(\n    lensProp('d'), 0, testObj\n  )).toEqual({\n    a : [ { b : 1 }, { b : 2 } ],\n    d : 0,\n  })\n  expect(set(\n    lensPath('a.0.b'), 0, testObj\n  )).toEqual({\n    a : [ { b : 0 }, { b : 2 } ],\n    d : 3,\n  })\n  expect(set(\n    lensPath('a.0.X'), 0, testObj\n  )).toEqual({\n    a : [\n      {\n        b : 1,\n        X : 0,\n      },\n      { b : 2 },\n    ],\n    d : 3,\n  })\n  expect(set(\n    lensPath([]), 0, testObj\n  )).toEqual(0)\n})\n\ntest('over', () => {\n  expect(over(\n    lensPath('d'), inc, testObj\n  )).toEqual({\n    a : [ { b : 1 }, { b : 2 } ],\n    d : 4,\n  })\n  expect(over(\n    lensPath('a.1.b'), inc, testObj\n  )).toEqual({\n    a : [ { b : 1 }, { b : 3 } ],\n    d : 3,\n  })\n  expect(over(\n    lensProp('X'), identity, testObj\n  )).toEqual({\n    a : [ { b : 1 }, { b : 2 } ],\n    d : 3,\n    X : undefined,\n  })\n  expect(over(\n    lensPath('a.0.X'), identity, testObj\n  )).toEqual({\n    a : [\n      {\n        b : 1,\n        X : undefined,\n      },\n      { b : 2 },\n    ],\n    d : 3,\n  })\n})\n\ntest('compose', () => {\n  const composedLens = compose(lensPath('a'), lensPath('1.b'))\n  expect(view(composedLens, testObj)).toEqual(2)\n})\n\ntest('set s (get s) === s', () => {\n  expect(set(\n    lensPath([ 'd' ]), view(lensPath([ 'd' ]), testObj), testObj\n  )).toEqual(testObj)\n  expect(set(\n    lensPath([ 'a', 0, 'b' ]),\n    view(lensPath([ 'a', 0, 'b' ]), testObj),\n    testObj\n  )).toEqual(testObj)\n})\n\ntest('get (set s v) === v', () => {\n  expect(view(lensPath([ 'd' ]), set(\n    lensPath([ 'd' ]), 0, testObj\n  ))).toEqual(0)\n  expect(view(lensPath([ 'a', 0, 'b' ]), set(\n    lensPath([ 'a', 0, 'b' ]), 0, testObj\n  ))).toEqual(0)\n})\n\ntest('get (set(set s v1) v2) === v2', () => {\n  const p = [ 'd' ]\n  const q = [ 'a', 0, 'b' ]\n  expect(view(lensPath(p), set(\n    lensPath(p), 11, set(\n      lensPath(p), 10, testObj\n    )\n  ))).toEqual(11)\n  expect(view(lensPath(q), set(\n    lensPath(q), 11, set(\n      lensPath(q), 10, testObj\n    )\n  ))).toEqual(11)\n})",
    "explanation": "It returns a lens that focuses on specified `path`.",
    "example": "const lensPath = R.lensPath(['x', 0, 'y'])\nconst input = {x: [{y: 2, z: 3}, {y: 4, z: 5}]}\n\nR.view(lensPath, input) //=> 2\n\nR.set(lensPath, 1, input) \n//=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}\n\nR.over(xHeadYLens, R.negate, input) \n//=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}",
    "typescriptDefinitionTest": "import {lensPath, view} from 'rambda'\n\ninterface Input {\n  foo: number[],\n  bar: {\n    a: string,\n    b: string,\n  },\n}\n\nconst testObject: Input = {\n  foo: [1, 2],\n  bar: {\n    a: 'x',\n    b: 'y',\n  },\n}\n\nconst path = lensPath(['bar', 'a'])\nconst pathAsString = lensPath('bar.a')\n\ndescribe('R.lensPath', () => {\n  it('happy', () => {\n    const result = view<Input, string>(path, testObject)\n    result // $ExpectType string\n  })\n  it('using string as path input', () => {\n    const result = view<Input, string>(pathAsString, testObject)\n    result // $ExpectType string\n  })\n})"
  },
  "lensProp": {
    "typing": "\nlensProp(prop: string): {\n  <T, U>(obj: T): U",
    "allTypings": "lensProp(prop: string): {\n  <T, U>(obj: T): U;\n  set<T, U, V>(val: T, obj: U): V;\n};",
    "categories": [
      "Lenses"
    ],
    "rambdaSource": "import { assoc } from './assoc'\nimport { lens } from './lens'\nimport { prop } from './prop'\n\nexport function lensProp(key){\n  return lens(prop(key), assoc(key))\n}",
    "rambdaSpecs": "import { compose } from './compose'\nimport { identity } from './identity'\nimport { inc } from './inc'\nimport { lensProp } from './lensProp'\nimport { over } from './over'\nimport { set } from './set'\nimport { view } from './view'\n\nconst testObj = {\n  a : 1,\n  b : 2,\n  c : 3,\n}\n\ntest('focuses object the specified object property', () => {\n  expect(view(lensProp('a'), testObj)).toEqual(1)\n})\n\ntest('returns undefined if the specified property does not exist', () => {\n  expect(view(lensProp('X'), testObj)).toEqual(undefined)\n})\n\ntest('sets the value of the object property specified', () => {\n  expect(set(\n    lensProp('a'), 0, testObj\n  )).toEqual({\n    a : 0,\n    b : 2,\n    c : 3,\n  })\n})\n\ntest('adds the property to the object if it doesn\\'t exist', () => {\n  expect(set(\n    lensProp('d'), 4, testObj\n  )).toEqual({\n    a : 1,\n    b : 2,\n    c : 3,\n    d : 4,\n  })\n})\n\ntest('applies function to the value of the specified object property', () => {\n  expect(over(\n    lensProp('a'), inc, testObj\n  )).toEqual({\n    a : 2,\n    b : 2,\n    c : 3,\n  })\n})\n\ntest('applies function to undefined and adds the property if it doesn\\'t exist', () => {\n  expect(over(\n    lensProp('X'), identity, testObj\n  )).toEqual({\n    a : 1,\n    b : 2,\n    c : 3,\n    X : undefined,\n  })\n})\n\ntest('can be composed', () => {\n  const nestedObj = {\n    a : { b : 1 },\n    c : 2,\n  }\n  const composedLens = compose(lensProp('a'), lensProp('b'))\n\n  expect(view(composedLens, nestedObj)).toEqual(1)\n})\n\ntest('set s (get s) === s', () => {\n  expect(set(\n    lensProp('a'), view(lensProp('a'), testObj), testObj\n  )).toEqual(testObj)\n})\n\ntest('get (set s v) === v', () => {\n  expect(view(lensProp('a'), set(\n    lensProp('a'), 0, testObj\n  ))).toEqual(0)\n})\n\ntest('get (set(set s v1) v2) === v2', () => {\n  expect(view(lensProp('a'),\n    set(\n      lensProp('a'), 11, set(\n        lensProp('a'), 10, testObj\n      )\n    ))).toEqual(11)\n})",
    "explanation": "It returns a lens that focuses on specified property `prop`.",
    "example": "const xLens = R.lensProp('x');\nconst input = {x: 1, y: 2}\n\nR.view(xLens, input) // => 1\n\nR.set(xLens, 4, input) \n// => {x: 4, y: 2}\n\nR.over(xLens, R.negate, input) \n// => {x: -1, y: 2}",
    "typescriptDefinitionTest": "import {lensProp, view} from 'rambda'\n\ninterface Input {\n  foo: string,\n}\n\nconst testObject: Input = {\n  foo: 'Led Zeppelin',\n}\n\nconst lens = lensProp('foo')\n\ndescribe('R.lensProp', () => {\n  it('happy', () => {\n    const result = view<Input, string>(lens, testObject)\n    result // $ExpectType string\n  })\n})"
  },
  "over": {
    "typing": "\nover<T>(lens: Lens, fn: Arity1Fn, value: T): T",
    "allTypings": "over<T>(lens: Lens, fn: Arity1Fn, value: T): T;\nover<T>(lens: Lens, fn: Arity1Fn, value: readonly T[]): T[];\nover(lens: Lens, fn: Arity1Fn): <T>(value: T) => T;\nover(lens: Lens, fn: Arity1Fn): <T>(value: readonly T[]) => T[];\nover(lens: Lens): <T>(fn: Arity1Fn, value: T) => T;\nover(lens: Lens): <T>(fn: Arity1Fn, value: readonly T[]) => T[];",
    "categories": [
      "Lenses"
    ],
    "rambdaSource": "import { curry } from './curry'\n\nconst Identity = x => ({\n  x,\n  map : fn => Identity(fn(x)),\n})\n\nfunction overFn(\n  lens, fn, object\n){\n  return lens(x => Identity(fn(x)))(object).x\n}\n\nexport const over = curry(overFn)",
    "rambdaSpecs": "import { assoc } from './assoc'\nimport { lens } from './lens'\nimport { lensIndex } from './lensIndex'\nimport { lensPath } from './lensPath'\nimport { over } from './over'\nimport { prop } from './prop'\nimport { toUpper } from './toUpper'\n\nconst testObject = {\n  foo : 'bar',\n  baz : {\n    a : 'x',\n    b : 'y',\n  },\n}\n\ntest('assoc lens', () => {\n  const assocLens = lens(prop('foo'), assoc('foo'))\n  const result = over(\n    assocLens, toUpper, testObject\n    )\n    const expected = {\n      ...testObject,\n      foo : 'BAR',\n    }\n    expect(result).toEqual(expected)\n  })\n  \n  test('path lens', () => {\n    const pathLens = lensPath('baz.a')\n  const result = over(\n    pathLens, toUpper, testObject\n  )\n  const expected = {\n    ...testObject,\n    baz : {\n      a : 'X',\n      b : 'y',\n    },\n  }\n  expect(result).toEqual(expected)\n})\n\ntest('index lens', () => {\n  const indexLens = lensIndex(0)\n  const result = over(indexLens, toUpper)(['foo', 'bar'])\n  expect(result).toEqual([ 'FOO', 'bar' ])\n})",
    "explanation": "It returns a copied **Object** or **Array** with modified value received by applying function `fn` to `lens` focus.",
    "example": "const headLens = R.lensIndex(0)\n \nR.over(headLens, R.toUpper, ['foo', 'bar', 'baz']) //=> ['FOO', 'bar', 'baz']"
  },
  "set": {
    "typing": "\nset<T, U>(lens: Lens, replacer: U, obj: T): T",
    "allTypings": "set<T, U>(lens: Lens, replacer: U, obj: T): T;\nset<U>(lens: Lens, replacer: U): <T>(obj: T) => T;\nset(lens: Lens): <T, U>(replacer: U, obj: T) => T;",
    "categories": [
      "Lenses"
    ],
    "rambdaSource": "import { always } from './always'\nimport { curry } from './curry'\nimport { over } from './over'\n\nfunction setFn(\n  lens, replacer, x\n){\n  return over(\n    lens, always(replacer), x\n  )\n}\n\nexport const set = curry(setFn)",
    "rambdaSpecs": "import { assoc } from './assoc'\nimport { lens } from './lens'\nimport { lensIndex } from './lensIndex'\nimport { lensPath } from './lensPath'\nimport { prop } from './prop'\nimport { set } from './set'\n\nconst testObject = {\n  foo : 'bar',\n  baz : {\n    a : 'x',\n    b : 'y',\n  },\n}\n\ntest('assoc lens', () => {\n  const assocLens = lens(prop('foo'), assoc('foo'))\n  const result = set(\n    assocLens, 'FOO', testObject\n  )\n  const expected = {\n    ...testObject,\n    foo : 'FOO',\n  }\n  expect(result).toEqual(expected)\n})\n\ntest('path lens', () => {\n  const pathLens = lensPath('baz.a')\n  const result = set(\n    pathLens, 'z', testObject\n  )\n  const expected = {\n    ...testObject,\n    baz : {\n      a : 'z',\n      b : 'y',\n    },\n  }\n  expect(result).toEqual(expected)\n})\n\ntest('index lens', () => {\n  const indexLens = lensIndex(0)\n\n  const result = set(\n    indexLens, 3, [ 1, 2 ]\n  )\n  expect(result).toEqual([ 3, 2 ])\n})",
    "explanation": "It returns a copied **Object** or **Array** with modified `lens` focus set to `replacer` value.",
    "example": "const input = {x: 1, y: 2}\nconst xLens = R.lensProp('x')\n\nR.set(xLens, 4, input) //=> {x: 4, y: 2}\nR.set(xLens, 8, input) //=> {x: 8, y: 2}"
  },
  "view": {
    "typing": "\nview<T, U>(lens: Lens): (target: T) => U",
    "allTypings": "view<T, U>(lens: Lens): (target: T) => U;\nview<T, U>(lens: Lens, target: T): U;",
    "categories": [
      "Lenses"
    ],
    "rambdaSource": "const Const = x => ({\n  x,\n  map : fn => Const(x),\n})\n\nexport function view(lens, target){\n  if (arguments.length === 1) return _target => view(lens, _target)\n\n  return lens(Const)(target).x\n}",
    "rambdaSpecs": "import { assoc } from './assoc'\nimport { lens } from './lens'\nimport { prop } from './prop'\nimport { view } from './view'\n\nconst testObject = { foo : 'Led Zeppelin' }\nconst assocLens = lens(prop('foo'), assoc('foo'))\n\ntest('happy', () => {\n  expect(view(assocLens, testObject)).toEqual('Led Zeppelin')\n})",
    "explanation": "It returns the value of `lens` focus over `target` object.",
    "example": "const lens = R.lensProp('x')\n\nR.view(lens, {x: 1, y: 2}) //=> 1\nR.view(lens, {x: 4, y: 2}) //=> 4",
    "typescriptDefinitionTest": "import {lens, view, assoc} from 'rambda'\n\ninterface Input {\n  foo: string,\n}\n\nconst testObject: Input = {\n  foo: 'Led Zeppelin',\n}\n\nconst fooLens = lens<Input, string, string>((x: Input) => {\n  return x.foo\n}, assoc('foo'))\n\ndescribe('R.view', () => {\n  it('happt', () => {\n    const result = view<Input, string>(fooLens, testObject)\n    result // $ExpectType string\n  })\n})"
  },
  "map": {
    "typing": "\nmap<T, U>(fn: ObjectIterator<T, U>, iterable: Dictionary<T>): Dictionary<U>",
    "allTypings": "map<T, U>(fn: ObjectIterator<T, U>, iterable: Dictionary<T>): Dictionary<U>;\nmap<T, U>(fn: Iterator<T, U>, iterable: readonly T[]): U[];\nmap<T, U>(fn: Iterator<T, U>): (iterable: readonly T[]) => U[];\nmap<T, U, S>(fn: ObjectIterator<T, U>): (iterable: Dictionary<T>) => Dictionary<U>;\nmap<T>(fn: Iterator<T, T>): (iterable: readonly T[]) => T[];\nmap<T>(fn: Iterator<T, T>, iterable: readonly T[]): T[];",
    "categories": [
      "List",
      "Object"
    ],
    "notes": "Unlike Ramda's `map`, here property and input object are passed as arguments to `fn`, when `iterable` is an object.",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\nimport { _keys } from './_internals/_keys'\n\nexport function mapArray(\n  fn, list, isIndexed = false\n){\n  let index = 0\n  const willReturn = Array(list.length)\n\n  while (index < list.length){\n    willReturn[ index ] = isIndexed ? fn(list[ index ], index) : fn(list[ index ])\n\n    index++\n  }\n\n  return willReturn\n}\n\nexport function mapObject(fn, obj){\n  let index = 0\n  const keys = _keys(obj)\n  const len = keys.length\n  const willReturn = {}\n\n  while (index < len){\n    const key = keys[ index ]\n    willReturn[ key ] = fn(\n      obj[ key ], key, obj\n    )\n    index++\n  }\n\n  return willReturn\n}\n\nexport function map(fn, list){\n  if (arguments.length === 1) return _list => map(fn, _list)\n  if (list === undefined) return []\n  if (_isArray(list)) return mapArray(fn, list)\n\n  return mapObject(fn, list)\n}",
    "rambdaSpecs": "import { map } from './map'\n\nconst double = x => x * 2\n\nconst sampleObject = {\n  a : 1,\n  b : 2,\n  c : 3,\n  d : 4,\n}\n\ntest('with array', () => {\n  expect(map(double, [ 1, 2, 3 ])).toEqual([ 2, 4, 6 ])\n})\n\ntest('with object', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n  }\n\n  expect(map(double, obj)).toEqual({\n    a : 2,\n    b : 4,\n  })\n})\n\ntest('pass input object as third argument', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n  }\n  const iterator = (\n    val, prop, inputObject\n  ) => {\n    expect(inputObject).toEqual(obj)\n\n    return val * 2\n  }\n\n  expect(map(iterator, obj)).toEqual({\n    a : 2,\n    b : 4,\n  })\n})\n\ntest('with object passes property as second argument', () => {\n  map((_, prop) => {\n    expect(typeof prop).toEqual('string')\n  })(sampleObject)\n})\n\n/**\n * https://github.com/selfrefactor/rambda/issues/77\n */\ntest('when undefined instead of array', () => {\n  expect(map(double, undefined)).toEqual([])\n})",
    "explanation": "It returns the result of looping through `iterable` with `fn`.\n\nIt works with both array and object.",
    "example": "const fn = x => x * 2\nconst fnWhenObject = (val, prop)=>{\n  return `${prop}-${val}`\n}\n\nconst iterable = [1, 2]\nconst obj = {a: 1, b: 2}\n\nconst result = [ \n  R.map(fn, list),\n  R.map(fnWhenObject, obj)\n]\n// => [ [1, 4], {a: 'a-1', b: 'b-2'}]",
    "typescriptDefinitionTest": "import {map} from 'rambda'\n\ndescribe('R.map with arrays', () => {\n  it('iterable returns the same type as the input', () => {\n    const result = map<number>(\n      (x: number) => {\n        x // $ExpectType number\n        return x + 2\n      },\n      [1, 2, 3]\n    )\n    result // $ExpectType number[]\n  })\n  it('iterable returns the same type as the input - curried', () => {\n    const result = map<number>((x: number) => {\n      x // $ExpectType number\n      return x + 2\n    })([1, 2, 3])\n    result // $ExpectType number[]\n  })\n})\n\ndescribe('R.map with objects', () => {\n  it('iterable with all three arguments - curried', () => {\n    // It requires dummy third typing argument\n    // in order to identify compared to curry typings for arrays\n    // ============================================\n    const result = map<number, string, any>((a, b, c) => {\n      a // $ExpectType number\n      b // $ExpectType string\n      c // $ExpectType Dictionary<number>\n      return `${a}`\n    })({a: 1, b: 2})\n    result // $ExpectType Dictionary<string>\n  })\n  it('iterable with all three arguments', () => {\n    const result = map<number, string>(\n      (a, b, c) => {\n        a // $ExpectType number\n        b // $ExpectType string\n        c // $ExpectType Dictionary<number>\n        return `${a}`\n      },\n      {a: 1, b: 2}\n    )\n    result // $ExpectType Dictionary<string>\n  })\n  it('iterable with property argument', () => {\n    const result = map<number, string>(\n      (a, b) => {\n        a // $ExpectType number\n        b // $ExpectType string\n        return `${a}`\n      },\n      {a: 1, b: 2}\n    )\n    result // $ExpectType Dictionary<string>\n  })\n  it('iterable with no property argument', () => {\n    const result = map<number, string>(\n      a => {\n        a // $ExpectType number\n        return `${a}`\n      },\n      {a: 1, b: 2}\n    )\n    result // $ExpectType Dictionary<string>\n  })\n})"
  },
  "match": {
    "typing": "\nmatch(regExpression: RegExp, str: string): string[]",
    "allTypings": "match(regExpression: RegExp, str: string): string[];\nmatch(regExpression: RegExp): (str: string) => string[];",
    "categories": [
      "String"
    ],
    "rambdaSource": "export function match(pattern, input){\n  if (arguments.length === 1) return _input => match(pattern, _input)\n\n  const willReturn = input.match(pattern)\n\n  return willReturn === null ? [] : willReturn\n}",
    "rambdaSpecs": "import { equals } from './equals'\nimport { match } from './match'\n\ntest('happy', () => {\n  expect(match(/a./g)('foo bar baz')).toEqual([ 'ar', 'az' ])\n})\n\ntest('fallback', () => {\n  expect(match(/a./g)('foo')).toEqual([])\n})\n\ntest('with string', () => {\n  expect(match('a', 'foo')).toEqual([])\n  expect(equals(match('o', 'foo'), [ 'o' ])).toBeTrue()\n})\n\ntest('throwing', () => {\n  expect(() => {\n    match(/a./g, null)\n  }).toThrowWithMessage(TypeError, 'Cannot read property \\'match\\' of null')\n})",
    "explanation": "Curried version of `String.prototype.match` which returns empty array, when there is no match.",
    "example": "const result = [\n  R.match('a', 'foo'),\n  R.match(/([a-z]a)/g, 'bananas')\n]\n// => [[], ['ba', 'na', 'na']]",
    "typescriptDefinitionTest": "import {match} from 'rambda'\n\nconst str = 'foo bar'\n\ndescribe('R.match', () => {\n  it('happy', () => {\n    const result = match(/foo/, str)\n    result // $ExpectType string[]\n  })\n  it('curried', () => {\n    const result = match(/foo/)(str)\n    result // $ExpectType string[]\n  })\n})"
  },
  "mathMod": {
    "typing": "\nmathMod(x: number, y: number): number",
    "allTypings": "mathMod(x: number, y: number): number;\nmathMod(x: number): (y: number) => number;",
    "categories": [
      "Number"
    ],
    "notes": "Explanation is taken from `Ramda` documentation site.",
    "rambdaSource": "import _isInteger from './_internals/_isInteger'\n\nexport function mathMod(x, y){\n  if (arguments.length === 1) return _y => mathMod(x, _y)\n  if (!_isInteger(x) || !_isInteger(y) || y < 1) return NaN\n\n  return (x % y + y) % y\n}",
    "rambdaSpecs": "import { mathMod } from './mathMod'\n\ntest('happy', () => {\n  expect(mathMod(-17)(5)).toEqual(3)\n  expect(mathMod(17, 5)).toEqual(2)\n  expect(mathMod(17, -5)).toBeNaN()\n  expect(mathMod(17, 0)).toBeNaN()\n  expect(mathMod('17', 5)).toBeNaN()\n  expect(mathMod({}, 2)).toBeNaN()\n  expect(mathMod([], 2)).toBeNaN()\n  expect(mathMod(Symbol(), 2)).toBeNaN()\n})",
    "explanation": "`R.mathMod` behaves like the modulo operator should mathematically, unlike the `%` operator (and by extension, `R.modulo`). So while `-17 % 5` is `-2`, `mathMod(-17, 5)` is `3`.",
    "example": "const result = [\n  R.mathMod(-17, 5),\n  R.mathMod(17, 5),\n  R.mathMod(17, -5),  \n  R.mathMod(17, 0)   \n]\n// => [3, 2, NaN, NaN]",
    "typescriptDefinitionTest": "import {mathMod} from 'rambda'\n\nconst first = 1\nconst second = 2\n\ndescribe('R.mathMod', () => {\n  it('happy', () => {\n    const result = mathMod(first, second)\n    result // $ExpectType number\n  })\n  it('curried', () => {\n    const result = mathMod(first, second)\n    result // $ExpectType number\n  })\n})"
  },
  "max": {
    "typing": "\nmax<T extends Ord>(x: T, y: T): T",
    "allTypings": "max<T extends Ord>(x: T, y: T): T;\nmax<T extends Ord>(x: T): (y: T) => T;",
    "categories": [
      "Logic"
    ],
    "rambdaSource": "export function max(x, y){\n  if (arguments.length === 1) return _y => max(x, _y)\n\n  return y > x ? y : x\n}",
    "rambdaSpecs": "import { max } from './max'\n\ntest('with number', () => {\n  expect(max(2, 1)).toBe(2)\n})\n\ntest('with string', () => {\n  expect(max('foo')('bar')).toBe('foo')\n  expect(max('bar')('baz')).toBe('baz')\n})",
    "explanation": "It returns the greater value between `x` and `y`.",
    "example": "const result = [\n  R.max(5, 7),  \n  R.max('bar', 'foo'),  \n]\n// => [7, 'foo']",
    "typescriptDefinitionTest": "import {max} from 'rambda'\n\nconst first = 1\nconst second = 2\n\ndescribe('R.max', () => {\n  it('happy', () => {\n    const result = max(first, second)\n    result // $ExpectType 1 | 2\n  })\n  it('curried', () => {\n    const result = max(first, second)\n    result // $ExpectType 1 | 2\n  })\n  it('curried - cann pass type', () => {\n    const result = max<number>(first, second)\n    result // $ExpectType number\n  })\n  it('can pass type', () => {\n    const result = max<number>(first, second)\n    result // $ExpectType number\n  })\n})"
  },
  "maxBy": {
    "typing": "\nmaxBy<T>(compareFn: (input: T) => Ord, x: T, y: T): T",
    "allTypings": "maxBy<T>(compareFn: (input: T) => Ord, x: T, y: T): T;\nmaxBy<T>(compareFn: (input: T) => Ord, x: T): (y: T) => T;\nmaxBy<T>(compareFn: (input: T) => Ord): FunctionToolbelt.Curry<(x: T, y: T) => T>;",
    "categories": [
      "Logic"
    ],
    "rambdaSource": "import { curry } from './curry'\n\nexport function maxByFn(\n  compareFn, x, y\n){\n  return compareFn(y) > compareFn(x) ? y : x\n}\n\nexport const maxBy = curry(maxByFn)",
    "rambdaSpecs": "import { maxBy } from './maxBy'\n\ntest('happy', () => {\n  expect(maxBy(\n    Math.abs, -5, 2\n  )).toEqual(-5)\n})\n\ntest('curried', () => {\n  expect(maxBy(Math.abs)(2, -5)).toEqual(-5)\n  expect(maxBy(Math.abs)(2)(-5)).toEqual(-5)\n})",
    "explanation": "It returns the greater value between `x` and `y` according to `compareFn` function.",
    "example": "const compareFn = Math.abs\n\nR.maxBy(compareFn, 5, -7) // => -7",
    "typescriptDefinitionTest": "import {maxBy} from 'rambda'\n\nconst compareFn = (x: number) => x % 2 === 0 ? 1 : -1\nconst first = 1\nconst second = 2\n\ndescribe('R.maxBy', () => {\n  it('happy', () => {\n    const result = maxBy(compareFn, first, second)\n    result // $ExpectType 1 | 2\n  })\n  it('curried 1', () => {\n    const result = maxBy(compareFn)(first, second)\n    result // $ExpectType number\n  })\n  it('curried 2', () => {\n    const result = maxBy<number>(compareFn, first)(second)\n    result // $ExpectType number\n  })\n  it('curried 3', () => {\n    const result = maxBy(compareFn)(first)(second)\n    result // $ExpectType number\n  })\n})"
  },
  "mean": {
    "typing": "\nmean(list: readonly number[]): number",
    "allTypings": "mean(list: readonly number[]): number;",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { sum } from './sum'\n\nexport function mean(list){\n  return sum(list) / list.length\n}",
    "rambdaSpecs": "import { mean } from './mean'\n\ntest('happy', () => {\n  expect(mean([ 2, 7 ])).toBe(4.5)\n})\n\ntest('with NaN', () => {\n  expect(mean([])).toBeNaN()\n})",
    "explanation": "It returns the mean value of `list` input.",
    "example": "R.mean([ 2, 7 ])\n// => 4.5",
    "typescriptDefinitionTest": "import {mean} from 'rambda'\n\ndescribe('R.mean', () => {\n  it('happy', () => {\n    const result = mean([1, 2, 3])\n\n    result // $ExpectType number\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('mean', function() {\n  it('handles array-like object', function() {\n    eq(R.mean((function() { return arguments; })(1, 2, 3)), 2);\n  });\n});"
  },
  "median": {
    "typing": "\nmedian(list: readonly number[]): number",
    "allTypings": "median(list: readonly number[]): number;",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { mean } from './mean'\n\nexport function median(list){\n  const len = list.length\n  if (len === 0) return NaN\n  const width = 2 - len % 2\n  const idx = (len - width) / 2\n\n  return mean(Array.prototype.slice\n    .call(list, 0)\n    .sort((a, b) => {\n      if (a === b) return 0\n\n      return a < b ? -1 : 1\n    })\n    .slice(idx, idx + width))\n}",
    "rambdaSpecs": "import { median } from './median'\n\ntest('happy', () => {\n  expect(median([ 2 ])).toEqual(2)\n  expect(median([ 7, 2, 10, 2, 9 ])).toEqual(7)\n})\n\ntest('with empty array', () => {\n  expect(median([])).toBeNaN()\n})",
    "explanation": "It returns the median value of `list` input.",
    "example": "R.median([ 7, 2, 10, 9 ]) // => 8",
    "typescriptDefinitionTest": "import {median} from 'rambda'\n\ndescribe('R.median', () => {\n  it('happy', () => {\n    const result = median([1, 2, 3])\n\n    result // $ExpectType number\n  })\n})"
  },
  "merge": {
    "typing": "\nmerge<O1 extends object, O2 extends object>(target: O1, newProps: O2): Merge<O2, O1, 'flat'>",
    "allTypings": "merge<O1 extends object, O2 extends object>(target: O1, newProps: O2): Merge<O2, O1, 'flat'>;\nmerge<O1 extends object>(target: O1): <O2 extends object>(newProps: O2) => Merge<O2, O1, 'flat'>;",
    "categories": [
      "Object"
    ],
    "rambdaSource": "export function merge(target, newProps){\n  if (arguments.length === 1) return _newProps => merge(target, _newProps)\n\n  return Object.assign(\n    {}, target || {}, newProps || {}\n  )\n}",
    "rambdaSpecs": "import { merge } from './merge'\n\nconst obj = {\n  foo : 1,\n  bar : 2,\n}\n\ntest('happy', () => {\n  expect(merge(obj, { bar : 20 })).toEqual({\n    foo : 1,\n    bar : 20,\n  })\n})\n\ntest('curry', () => {\n  expect(merge(obj)({ baz : 3 })).toEqual({\n    foo : 1,\n    bar : 2,\n    baz : 3,\n  })\n})\n\n/**\n * https://github.com/selfrefactor/rambda/issues/77\n */\ntest('when undefined or null instead of object', () => {\n  expect(merge(null, undefined)).toEqual({})\n  expect(merge(obj, null)).toEqual(obj)\n  expect(merge(obj, undefined)).toEqual(obj)\n  expect(merge(undefined, obj)).toEqual(obj)\n})",
    "explanation": "It creates a copy of `target` object with overidden `newProps` properties.",
    "example": "const target = { 'foo': 0, 'bar': 1 }\nconst newProps = { 'foo': 7 }\n\nconst result = R.merge(target, newProps)\n// => { 'foo': 7, 'bar': 1 }",
    "typescriptDefinitionTest": "import {merge} from 'rambda'\n\ndescribe('R.merge', () => {\n  const result = merge({foo: 1}, {bar: 2})\n  const curriedResult = merge({foo: 1})({bar: 2})\n\n  result.foo // $ExpectType number\n  result.bar // $ExpectType number\n  curriedResult.bar // $ExpectType number\n})"
  },
  "mergeAll": {
    "typing": "\nmergeAll<T>(list: object[]): T",
    "allTypings": "mergeAll<T>(list: object[]): T;\nmergeAll(list: object[]): object;",
    "rambdaSource": "import { map } from './map'\nimport { merge } from './merge'\n\nexport function mergeAll(arr){\n  let willReturn = {}\n  map(val => {\n    willReturn = merge(willReturn, val)\n  }, arr)\n\n  return willReturn\n}",
    "rambdaSpecs": "import { mergeAll } from './mergeAll'\n\ntest('case 1', () => {\n  const arr = [ { a : 1 }, { b : 2 }, { c : 3 } ]\n  const expectedResult = {\n    a : 1,\n    b : 2,\n    c : 3,\n  }\n  expect(mergeAll(arr)).toEqual(expectedResult)\n})\n\ntest('case 2', () => {\n  expect(mergeAll([ { foo : 1 }, { bar : 2 }, { baz : 3 } ])).toEqual({\n    foo : 1,\n    bar : 2,\n    baz : 3,\n  })\n})",
    "explanation": "It merges all objects of `list` array sequentially and returns the result.",
    "example": "const list = [\n  {a: 1},\n  {b: 2},\n  {c: 3}\n]\nconst result = R.mergeAll(list)\nconst expected = {\n  a: 1,\n  b: 2,\n  c: 3\n}\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {mergeAll} from 'rambda'\n\ndescribe('R.mergeAll', () => {\n  it('with passing type', () => {\n    interface Output {\n      foo: number,\n      bar: number,\n    }\n    const result = mergeAll<Output>([{foo: 1}, {bar: 2}])\n    result.foo // $ExpectType number\n    result.bar // $ExpectType number\n  })\n\n  it('without passing type', () => {\n    const result = mergeAll([{foo: 1}, {bar: 2}])\n    result // $ExpectType unknown\n  })\n})"
  },
  "mergeDeepRight": {
    "typing": "\nmergeDeepRight<O1 extends object, O2 extends object>(x: O1, y: O2): Merge<O2, O1, 'deep'>",
    "allTypings": "mergeDeepRight<O1 extends object, O2 extends object>(x: O1, y: O2): Merge<O2, O1, 'deep'>;\nmergeDeepRight<O1 extends object>(x: O1): <O2 extends object>(y: O2) => Merge<O2, O1, 'deep'>;",
    "rambdaSource": "import { type } from './type'\n\nexport function mergeDeepRight(target, source){\n  if (arguments.length === 1){\n    return sourceHolder => mergeDeepRight(target, sourceHolder)\n  }\n\n  const willReturn = JSON.parse(JSON.stringify(target))\n\n  Object.keys(source).forEach(key => {\n    if (type(source[ key ]) === 'Object'){\n      if (type(target[ key ]) === 'Object'){\n        willReturn[ key ] = mergeDeepRight(target[ key ], source[ key ])\n      } else {\n        willReturn[ key ] = source[ key ]\n      }\n    } else {\n      willReturn[ key ] = source[ key ]\n    }\n  })\n\n  return willReturn\n}",
    "rambdaSpecs": "// import { mergeDeepRight } from 'ramda'\nimport { mergeDeepRight } from './mergeDeepRight'\n\nconst slave = {\n  name    : 'evilMe',\n  age     : 10,\n  contact : {\n    a     : 1,\n    email : 'foo@example.com',\n  },\n}\nconst master = {\n  age     : 40,\n  contact : { email : 'baz@example.com' },\n  songs   : { title : 'Remains the same' },\n}\n\ntest('happy', () => {\n  const result = mergeDeepRight(slave, master)\n  const curryResult = mergeDeepRight(slave)(master)\n  const expected = {\n    age     : 40,\n    name    : 'evilMe',\n    contact : {\n      a     : 1,\n      email : 'baz@example.com',\n    },\n    songs : { title : 'Remains the same' },\n  }\n\n  expect(result).toEqual(expected)\n  expect(curryResult).toEqual(expected)\n})\n\ntest('ramda compatible test 1', () => {\n  const a = {\n    w : 1,\n    x : 2,\n    y : { z : 3 },\n  }\n  const b = {\n    a : 4,\n    b : 5,\n    c : { d : 6 },\n  }\n  const result = mergeDeepRight(a, b)\n  const expected = {\n    w : 1,\n    x : 2,\n    y : { z : 3 },\n    a : 4,\n    b : 5,\n    c : { d : 6 },\n  }\n\n  expect(result).toEqual(expected)\n})\n\ntest('ramda compatible test 2', () => {\n  const a = {\n    a : {\n      b : 1,\n      c : 2,\n    },\n    y : 0,\n  }\n  const b = {\n    a : {\n      b : 3,\n      d : 4,\n    },\n    z : 0,\n  }\n  const result = mergeDeepRight(a, b)\n  const expected = {\n    a : {\n      b : 3,\n      c : 2,\n      d : 4,\n    },\n    y : 0,\n    z : 0,\n  }\n\n  expect(result).toEqual(expected)\n})\n\ntest('ramda compatible test 3', () => {\n  const a = {\n    w : 1,\n    x : { y : 2 },\n  }\n  const result = mergeDeepRight(a, { x : { y : 3 } })\n  const expected = {\n    w : 1,\n    x : { y : 3 },\n  }\n  expect(result).toEqual(expected)\n})",
    "explanation": "Creates a new object with the own properties of the first object merged with the own properties of the second object. If a key exists in both objects:\n\n  - and both values are objects, the two values will be recursively merged\n  - otherwise the value from the second object will be used.",
    "typescriptDefinitionTest": "import {mergeDeepRight} from 'rambda'\n\ndescribe('R.mergeDeepRight', () => {\n  const result = mergeDeepRight({foo: {bar: 1}}, {foo: {bar: 2}})\n  result.foo.bar // $ExpectType number\n})"
  },
  "mergeLeft": {
    "typing": "\nmergeLeft<O1 extends object, O2 extends object>(target: O1, newProps: O2): Merge<O2, O1, 'flat'>",
    "allTypings": "mergeLeft<O1 extends object, O2 extends object>(target: O1, newProps: O2): Merge<O2, O1, 'flat'>;\nmergeLeft<O1 extends object>(target: O1): <O2 extends object>(newProps: O2) => Merge<O2, O1, 'flat'>;",
    "categories": [
      "Object"
    ],
    "rambdaSource": "import { merge } from './merge'\n\nexport function mergeLeft(x, y){\n  if (arguments.length === 1) return _y => mergeLeft(x, _y)\n\n  return merge(y, x)\n}",
    "rambdaSpecs": "import { mergeLeft } from './mergeLeft'\n\nconst obj = {\n  foo : 1,\n  bar : 2,\n}\n\ntest('happy', () => {\n  expect(mergeLeft({ bar : 20 }, obj)).toEqual({\n    foo : 1,\n    bar : 20,\n  })\n})\n\ntest('curry', () => {\n  expect(mergeLeft({ baz : 3 })(obj)).toEqual({\n    foo : 1,\n    bar : 2,\n    baz : 3,\n  })\n})\n\ntest('when undefined or null instead of object', () => {\n  expect(mergeLeft(null, undefined)).toEqual({})\n  expect(mergeLeft(obj, null)).toEqual(obj)\n  expect(mergeLeft(obj, undefined)).toEqual(obj)\n  expect(mergeLeft(undefined, obj)).toEqual(obj)\n})",
    "explanation": "Same as `R.merge`, but in opposite direction.",
    "example": "const result = R.mergeLeft(\n  {a: 10},\n  {a: 1, b: 2}\n)\n// => {a:10, b: 2}",
    "typescriptDefinitionTest": "import {mergeLeft} from 'rambda'\n\ndescribe('R.mergeLeft', () => {\n  const result = mergeLeft({foo: 1}, {bar: 2})\n  const curriedResult = mergeLeft({foo: 1})({bar: 2})\n\n  result.foo // $ExpectType number\n  result.bar // $ExpectType number\n  curriedResult.bar // $ExpectType number\n})"
  },
  "min": {
    "typing": "\nmin<T extends Ord>(x: T, y: T): T",
    "allTypings": "min<T extends Ord>(x: T, y: T): T;\nmin<T extends Ord>(x: T): (y: T) => T;",
    "categories": [
      "Logic"
    ],
    "rambdaSource": "export function min(x, y){\n  if (arguments.length === 1) return _y => min(x, _y)\n\n  return y < x ? y : x\n}",
    "rambdaSpecs": "import { min } from './min'\n\ntest('happy', () => {\n  expect(min(2, 1)).toBe(1)\n  expect(min(1)(2)).toBe(1)\n})",
    "explanation": "It returns the lesser value between `x` and `y`.",
    "example": "const result = [\n  R.min(5, 7),  \n  R.min('bar', 'foo'),  \n]\n// => [5, 'bar']",
    "typescriptDefinitionTest": "import {min} from 'rambda'\n\nconst first = 1\nconst second = 2\n\ndescribe('R.min', () => {\n  it('happy', () => {\n    const result = min(first, second)\n    result // $ExpectType 1 | 2\n  })\n  it('curried', () => {\n    const result = min(first, second)\n    result // $ExpectType 1 | 2\n  })\n  it('curried - cann pass type', () => {\n    const result = min<number>(first, second)\n    result // $ExpectType number\n  })\n  it('can pass type', () => {\n    const result = min<number>(first, second)\n    result // $ExpectType number\n  })\n})"
  },
  "minBy": {
    "typing": "\nminBy<T>(compareFn: (input: T) => Ord, x: T, y: T): T",
    "allTypings": "minBy<T>(compareFn: (input: T) => Ord, x: T, y: T): T;\nminBy<T>(compareFn: (input: T) => Ord, x: T): (y: T) => T;\nminBy<T>(compareFn: (input: T) => Ord): FunctionToolbelt.Curry<(x: T, y: T) => T>;",
    "categories": [
      "Logic"
    ],
    "rambdaSource": "import { curry } from './curry'\n\nexport function minByFn(\n  compareFn, x, y\n){\n  return compareFn(y) < compareFn(x) ? y : x\n}\n\nexport const minBy = curry(minByFn)",
    "rambdaSpecs": "import { minBy } from './minBy'\n\ntest('happy', () => {\n  expect(minBy(\n    Math.abs, -5, 2\n  )).toEqual(2)\n})\n\ntest('curried', () => {\n  expect(minBy(Math.abs)(2, -5)).toEqual(2)\n  expect(minBy(Math.abs)(2)(-5)).toEqual(2)\n})",
    "explanation": "It returns the lesser value between `x` and `y` according to `compareFn` function.",
    "example": "const compareFn = Math.abs\n\nR.minBy(compareFn, -5, 2) // => -5",
    "typescriptDefinitionTest": "import {minBy} from 'rambda'\n\nconst compareFn = (x: number) => x % 2 === 0 ? 1 : -1\nconst first = 1\nconst second = 2\n\ndescribe('R.minBy', () => {\n  it('happy', () => {\n    const result = minBy(compareFn, first, second)\n    result // $ExpectType 1 | 2\n  })\n  it('curried 1', () => {\n    const result = minBy(compareFn)(first, second)\n    result // $ExpectType number\n  })\n  it('curried 2', () => {\n    /*\n      Than should be the case, but passing type is required for some reason\n    */\n    const result = minBy<number>(compareFn, first)(second)\n    result // $ExpectType number\n  })\n  it('curried 3', () => {\n    const result = minBy(compareFn)(first)(second)\n    result // $ExpectType number\n  })\n})"
  },
  "modulo": {
    "typing": "\nmodulo(x: number, y: number): number",
    "allTypings": "modulo(x: number, y: number): number;\nmodulo(x: number): (y: number) => number;",
    "categories": [
      "Number"
    ],
    "rambdaSource": "export function modulo(x, y){\n  if (arguments.length === 1) return _y => modulo(x, _y)\n\n  return x % y\n}",
    "rambdaSpecs": "import { modulo } from './modulo'\n\ntest('happy', () => {\n  expect(modulo(17, 3)).toEqual(2)\n  expect(modulo(15)(6)).toEqual(3)\n})",
    "explanation": "Curried version of `x%y`.",
    "example": "R.modulo(17, 3) // => 2",
    "typescriptDefinitionTest": "import {modulo} from 'rambda'\n\ndescribe('R.modulo', () => {\n  it('happy', () => {\n    const result = modulo(4, 1)\n\n    result // $ExpectType number\n  })\n  it('curried', () => {\n    const result = modulo(4)(1)\n\n    result // $ExpectType number\n  })\n})"
  },
  "move": {
    "typing": "\nmove<T>(fromIndex: number, toIndex: number, list: readonly T[]): T[]",
    "allTypings": "move<T>(fromIndex: number, toIndex: number, list: readonly T[]): T[];\nmove(fromIndex: number, toIndex: number): <T>(list: readonly T[]) => T[];\nmove(fromIndex: number): {\n    <T>(toIndex: number, list: readonly T[]): T[];\n    (toIndex: number): <T>(list: readonly T[]) => T[];\n};",
    "categories": [
      "List"
    ],
    "notes": "Rambda.move doesn't support negative indexes - it throws an error.",
    "rambdaSource": "import { curry } from './curry'\n\nfunction moveFn(\n  fromIndex, toIndex, list\n){\n  if (fromIndex < 0 || toIndex < 0){\n    throw new Error('Rambda.move does not support negative indexes')\n  }\n  if (fromIndex > list.length - 1 || toIndex > list.length - 1) return list\n\n  const clone = list.slice()\n  clone[ fromIndex ] = list[ toIndex ]\n  clone[ toIndex ] = list[ fromIndex ]\n\n  return clone\n}\n\nexport const move = curry(moveFn)",
    "rambdaSpecs": "import { move } from './move'\nconst list = [ 1, 2, 3, 4 ]\n\ntest('happy', () => {\n  const result = move(\n    0, 1, list\n  )\n\n  expect(result).toEqual([ 2, 1, 3, 4 ])\n})\n\ntest('with negative index', () => {\n  const errorMessage = 'Rambda.move does not support negative indexes'\n  expect(() => move(\n    0, -1, list\n  )).toThrowWithMessage(Error, errorMessage)\n  expect(() => move(\n    -1, 0, list\n  )).toThrowWithMessage(Error, errorMessage)\n})\n\ntest('when indexes are outside the list outbounds', () => {\n  const result1 = move(\n    10, 1, list\n  )\n  const result2 = move(\n    1, 10, list\n  )\n\n  expect(result1).toEqual(list)\n  expect(result2).toEqual(list)\n})",
    "explanation": "It returns a copy of `list` with exchanged `fromIndex` and `toIndex` elements.",
    "example": "const list = [1, 2, 3]\nconst result = R.move(0, 1, list)\n// => [2, 1, 3]",
    "typescriptDefinitionTest": "import {move} from 'rambda'\n\nconst list = [1, 2, 3]\n\ndescribe('R.move', () => {\n  it('happy', () => {\n    const result = move(0, 1, list)\n\n    result // $ExpectType number[]\n  })\n  it('curried 1', () => {\n    const result = move(0, 1)(list)\n\n    result // $ExpectType number[]\n  })\n  it('curried 2', () => {\n    const result = move(0)(1)(list)\n\n    result // $ExpectType number[]\n  })\n})",
    "failedSpecsReasons": "Ramda method does not support negative indexes",
    "failedSpecsCount": 2
  },
  "multiply": {
    "typing": "\nmultiply(x: number, y: number): number",
    "allTypings": "multiply(x: number, y: number): number;\nmultiply(x: number): (y: number) => number;",
    "categories": [
      "Number"
    ],
    "rambdaSource": "export function multiply(x, y){\n  if (arguments.length === 1) return _y => multiply(x, _y)\n\n  return x * y\n}",
    "rambdaSpecs": "import { multiply } from './multiply'\n\ntest('happy', () => {\n  expect(multiply(2, 4)).toEqual(8)\n  expect(multiply(2)(4)).toEqual(8)\n})",
    "explanation": "Curried version of `x*y`.",
    "example": "R.multiply(2, 4) // => 8",
    "typescriptDefinitionTest": "import {multiply} from 'rambda'\n\ndescribe('R.multiply', () => {\n  it('happy', () => {\n    const result = multiply(4, 1)\n\n    result // $ExpectType number\n  })\n  it('curried', () => {\n    const result = multiply(4)(1)\n\n    result // $ExpectType number\n  })\n})"
  },
  "negate": {
    "typing": "\nnegate(x: number): number",
    "allTypings": "negate(x: number): number;",
    "categories": [
      "Number"
    ],
    "rambdaSource": "export function negate(x){\n  return -x\n}",
    "rambdaSpecs": "import { negate } from './negate'\n\ntest('negate', () => {\n  expect(negate(420)).toEqual(-420)\n  expect(negate(-13)).toEqual(13)\n})",
    "example": "R.negate(420)// => -420"
  },
  "none": {
    "typing": "\nnone<T>(predicate: (x: T) => boolean, list: readonly T[]): boolean",
    "allTypings": "none<T>(predicate: (x: T) => boolean, list: readonly T[]): boolean;\nnone<T>(predicate: (x: T) => boolean): (list: readonly T[]) => boolean;",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function none(predicate, list){\n  if (arguments.length === 1) return _list => none(predicate, _list)\n\n  for (let i = 0; i < list.length; i++){\n    if (!predicate(list[ i ])) return true\n  }\n\n  return false\n}",
    "rambdaSpecs": "import { none } from './none'\n\nconst isEven = n => n % 2 === 0\nconst isOdd = n => n % 2 === 1\nconst arr = [ 1, 3, 5, 7, 9, 11 ]\n\ntest('when true', () => {\n  expect(none(isEven, arr)).toBeTrue()\n})\n\ntest('when false curried', () => {\n  expect(none(isOdd)(arr)).toBeFalse()\n})",
    "explanation": "It returns `true`, if all members of array `list` returns `false`, when applied as argument to `predicate` function.",
    "example": "const list = [ 0, 1, 2, 3, 4 ]\nconst predicate = x => x > 6\n\nconst result = R.none(predicate, arr)\n// => true",
    "typescriptDefinitionTest": "import {none} from 'rambda'\n\ndescribe('R.none', () => {\n  it('happy', () => {\n    const result = none(\n      x => {\n        x // $ExpectType number\n        return x > 0\n      },\n      [1, 2, 3]\n    )\n    result // $ExpectType boolean\n  })\n  it('curried needs a type', () => {\n    const result = none<number>(x => {\n      x // $ExpectType number\n      return x > 0\n    })([1, 2, 3])\n    result // $ExpectType boolean\n  })\n})"
  },
  "not": {
    "typing": "\nnot(input: any): boolean",
    "allTypings": "not(input: any): boolean;",
    "categories": [
      "Logic"
    ],
    "rambdaSource": "export function not(input){\n  return !input\n}",
    "rambdaSpecs": "import { not } from './not'\n\ntest('not', () => {\n  expect(not(false)).toEqual(true)\n  expect(not(true)).toEqual(false)\n  expect(not(0)).toEqual(true)\n  expect(not(1)).toEqual(false)\n})",
    "explanation": "It returns a boolean negated version of `input`.",
    "example": "R.not(false) // true",
    "typescriptDefinitionTest": "import {not} from 'rambda'\n\ndescribe('R.not', () => {\n  it('happy', () => {\n    const result = not(4)\n\n    result // $ExpectType boolean\n  })\n})"
  },
  "nth": {
    "typing": "\nnth<T>(index: number, list: readonly T[]): T | undefined",
    "allTypings": "nth<T>(index: number, list: readonly T[]): T | undefined;\t\nnth(index: number): <T>(list: readonly T[]) => T | undefined;",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function nth(index, list){\n  if (arguments.length === 1) return _list => nth(index, _list)\n\n  const idx = index < 0 ? list.length + index : index\n\n  return Object.prototype.toString.call(list) === '[object String]' ?\n    list.charAt(idx) :\n    list[ idx ]\n}",
    "rambdaSpecs": "import { nth } from './nth'\n\ntest('happy', () => {\n  expect(nth(2, [ 1, 2, 3, 4 ])).toEqual(3)\n})\n\ntest('with curry', () => {\n  expect(nth(2)([ 1, 2, 3, 4 ])).toEqual(3)\n})\n\ntest('with string', () => {\n  expect(nth(2)('foo')).toEqual('o')\n})\n\ntest('with negative index', () => {\n  expect(nth(-3)([ 1, 2, 3, 4 ])).toEqual(2)\n})",
    "explanation": "Curried version of `list[index]`.",
    "example": "const list = [1, 2, 3]\nconst str = 'foo'\n\nconst result = [\n  R.nth(2, list),\n  R.nth(6, list),\n  R.nth(0, str),\n]\n// => [3, undefined, 'f']",
    "typescriptDefinitionTest": "import {nth} from 'rambda'\n\nconst list = [1, 2, 3]\n\ndescribe('R.nth', () => {\n  it('happy', () => {\n    const result = nth(4, list)\n\n    result // $ExpectType number | undefined\n  })\n  it('curried', () => {\n    const result = nth(1)(list)\n\n    result // $ExpectType number | undefined\n  })\n})"
  },
  "once": {
    "typing": "\nonce<T extends (...args: any[]) => any>(func: T): T",
    "allTypings": "once<T extends (...args: any[]) => any>(func: T): T;",
    "categories": [
      "Function"
    ],
    "rambdaSource": "import { curry } from './curry'\n\nfunction onceFn(fn, context){\n  let result\n\n  return function (){\n    if (fn){\n      result = fn.apply(context || this, arguments)\n      fn = null\n    }\n\n    return result\n  }\n}\n\nexport function once(fn, context){\n  if (arguments.length === 1){\n    const wrap = onceFn(fn, context)\n\n    return curry(wrap)\n  }\n\n  return onceFn(fn, context)\n}",
    "rambdaSpecs": "import { once } from './once'\n\ntest('with counter', () => {\n  let counter = 0\n  const runOnce = once(x => {\n    counter++\n\n    return x + 2\n  })\n  expect(runOnce(1)).toEqual(3)\n  runOnce(1)\n  runOnce(1)\n  runOnce(1)\n  expect(counter).toEqual(1)\n})\n\ntest('happy path', () => {\n  const addOneOnce = once((\n    a, b, c\n  ) => a + b + c, 1)\n\n  expect(addOneOnce(\n    10, 20, 30\n  )).toBe(60)\n  expect(addOneOnce(40)).toEqual(60)\n})",
    "explanation": "It returns a function, which invokes only once `fn` function.",
    "example": "let result = 0\nconst addOnce = R.once((x) => result = result + x)\n\naddOnce(1)\naddOnce(1)\n// => 1",
    "typescriptDefinitionTest": "import {once} from 'rambda'\n\ndescribe('R.once', () => {\n  it('happy', () => {\n    const runOnce = once((x: number) => {\n      return x + 2\n    })\n\n    const result = runOnce(1)\n    result // $ExpectType number\n  })\n})",
    "failedSpecsReasons": "Ramda method retains arity",
    "failedSpecsCount": 1
  },
  "omit": {
    "typing": "\nomit<T, K extends string>(propsToOmit: readonly K[], obj: T): Omit<T, K>",
    "allTypings": "omit<T, K extends string>(propsToOmit: readonly K[], obj: T): Omit<T, K>;\nomit<K extends string>(propsToOmit: readonly K[]): <T>(obj: T) => Omit<T, K>;\nomit<T, U>(propsToOmit: string, obj: T): U;\nomit<T, U>(propsToOmit: string): (obj: T) => U;\nomit<T>(propsToOmit: string, obj: object): T;\nomit<T>(propsToOmit: string): (obj: object) => T;",
    "categories": [
      "Object"
    ],
    "notes": "When using this method with `TypeScript`, it is much easier to pass `propsToOmit` as an array. If passing a string, you will need to explicitly declare the output type.",
    "rambdaSource": "export function omit(propsToOmit, obj){\n  if (arguments.length === 1) return _obj => omit(propsToOmit, _obj)\n\n  if (obj === null || obj === undefined){\n    return undefined\n  }\n\n  const propsToOmitValue =\n    typeof propsToOmit === 'string' ? propsToOmit.split(',') : propsToOmit\n\n  const willReturn = {}\n\n  for (const key in obj){\n    if (!propsToOmitValue.includes(key)){\n      willReturn[ key ] = obj[ key ]\n    }\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { omit } from './omit'\n\ntest('with string as condition', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n    c : 3,\n  }\n  const result = omit('a,c', obj)\n  const resultCurry = omit('a,c')(obj)\n  const expectedResult = { b : 2 }\n\n  expect(result).toEqual(expectedResult)\n  expect(resultCurry).toEqual(expectedResult)\n})\n\ntest('with null', () => {\n  expect(omit('a,b', null)).toEqual(undefined)\n})\n\ntest('doesn\\'t work with number as property', () => {\n  expect(omit([ 42 ], {\n    a  : 1,\n    42 : 2,\n  })).toEqual({\n    42 : 2,\n    a  : 1,\n  })\n})\n\ntest('happy', () => {\n  expect(omit([ 'a', 'c' ])({\n    a : 'foo',\n    b : 'bar',\n    c : 'baz',\n  })).toEqual({ b : 'bar' })\n})",
    "explanation": "It returns a partial copy of an `obj` without `propsToOmit` properties.",
    "example": "const obj = {a: 1, b: 2, c: 3}\nconst propsToOmit = 'a,c,d'\nconst propsToOmitList = ['a', 'c', 'd']\n\nconst result = [\n  R.omit(propsToOmit, obj), \n  R.omit(propsToOmitList, obj) \n]\n// => [{b: 2}, {b: 2}]",
    "typescriptDefinitionTest": "import {omit} from 'rambda'\n\ndescribe('R.omit with array as props input', () => {\n  it('allow Typescript to infer object type', () => {\n    const input = {a: 'foo', b: 2, c: 3, d: 4}\n    const result = omit(['b,c'], input)\n\n    result.a // $ExpectType string\n    result.d // $ExpectType number\n\n    const curriedResult = omit(['a,c'], input)\n\n    curriedResult.a // $ExpectType string\n    curriedResult.d // $ExpectType number\n  })\n\n  it('declare type of input object', () => {\n    interface Input {\n      a: string,\n      b: number,\n      c: number,\n      d: number,\n    }\n    const input: Input = {a: 'foo', b: 2, c: 3, d: 4}\n    const result = omit(['b,c'], input)\n    result // $ExpectType Pick<Input, \"b\" | \"a\" | \"c\" | \"d\">\n\n    result.a // $ExpectType string\n    result.d // $ExpectType number\n\n    const curriedResult = omit(['a,c'], input)\n\n    curriedResult.a // $ExpectType string\n    curriedResult.d // $ExpectType number\n  })\n})\n\ndescribe('R.omit with string as props input', () => {\n  interface Output {\n    b: number,\n    d: number,\n  }\n\n  it('explicitly declare output', () => {\n    const result = omit<Output>('a,c', {a: 1, b: 2, c: 3, d: 4})\n    result // $ExpectType Output\n    result.b // $ExpectType number\n\n    const curriedResult = omit<Output>('a,c')({a: 1, b: 2, c: 3, d: 4})\n\n    curriedResult.b // $ExpectType number\n  })\n\n  it('explicitly declare input and output', () => {\n    interface Input {\n      a: number,\n      b: number,\n      c: number,\n      d: number,\n    }\n    const result = omit<Input, Output>('a,c', {a: 1, b: 2, c: 3, d: 4})\n    result // $ExpectType Output\n    result.b // $ExpectType number\n\n    const curriedResult = omit<Input, Output>('a,c')({\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n    })\n\n    curriedResult.b // $ExpectType number\n  })\n\n  it('without passing type', () => {\n    const result = omit('a,c', {a: 1, b: 2, c: 3, d: 4})\n    result // $ExpectType unknown\n  })\n})"
  },
  "of": {
    "typing": "\nof<T>(x: T): T[]",
    "allTypings": "of<T>(x: T): T[];",
    "rambdaSource": "export function of(value){\n  return [ value ]\n}",
    "rambdaSpecs": "import { of } from './of'\n\ntest('happy', () => {\n  expect(of(3)).toEqual([ 3 ])\n\n  expect(of(null)).toEqual([ null ])\n})",
    "example": "R.of(null); //=> [null]\nR.of([42]); //=> [[42]]",
    "typescriptDefinitionTest": "import {of} from 'ramda'\n\nconst list = [1, 2, 3]\n\ndescribe('R.of', () => {\n  it('happy', () => {\n    const result = of(4)\n\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = of(list)\n\n    result // $ExpectType number[][]\n  })\n})"
  },
  "partial": {
    "typing": "\npartial<V0, V1, T>(fn: (x0: V0, x1: V1) => T, args: [V0]): (x1: V1) => T",
    "allTypings": "partial<V0, V1, T>(fn: (x0: V0, x1: V1) => T, args: [V0]): (x1: V1) => T;\npartial<V0, V1, V2, T>(fn: (x0: V0, x1: V1, x2: V2) => T, args: [V0, V1]): (x2: V2) => T;\npartial<V0, V1, V2, T>(fn: (x0: V0, x1: V1, x2: V2) => T, args: [V0]): (x1: V1, x2: V2) => T;\npartial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, args: [V0, V1, V2]): (x2: V3) => T;\npartial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, args: [V0, V1]): (x2: V2, x3: V3) => T;\npartial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, args: [V0]): (x1: V1, x2: V2, x3: V3) => T;\npartial<T>(fn: (...a: any[]) => T, args: any[]): (...x: any[]) => T;",
    "categories": [
      "Logic"
    ],
    "notes": "Rambda's partial doesn't need the input arguments to be wrapped as array.",
    "rambdaSource": "export function partial(fn, ...args){\n  const len = fn.length\n\n  return (...rest) => {\n    if (args.length + rest.length >= len){\n      return fn(...args, ...rest)\n    }\n\n    return partial(fn, ...[ ...args, ...rest ])\n  }\n}",
    "rambdaSpecs": "import { partial } from './partial'\nimport { type } from './type'\n\nconst greet = (\n  salutation, title, firstName, lastName\n) =>\n  salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!'\n\ntest('happy', () => {\n  const canPassAnyNumberOfArguments = partial(\n    greet, 'Hello', 'Ms.'\n  )\n  const fn = canPassAnyNumberOfArguments('foo')\n  const sayHello = partial(greet, [ 'Hello' ])\n  const sayHelloRamda = partial(sayHello, [ 'Ms.' ])\n\n  expect(type(fn)).toBe('Function')\n\n  expect(fn('bar')).toBe('Hello, Ms. foo bar!')\n  expect(sayHelloRamda('foo', 'bar')).toBe('Hello, Ms. foo bar!')\n})\n\ntest('extra arguments are ignored', () => {\n  const canPassAnyNumberOfArguments = partial(\n    greet, 'Hello', 'Ms.'\n  )\n  const fn = canPassAnyNumberOfArguments('foo')\n\n  expect(type(fn)).toBe('Function')\n\n  expect(fn(\n    'bar', 1, 2\n  )).toBe('Hello, Ms. foo bar!')\n})\n\ntest('when array is input', () => {\n  const fooFn = (\n    a, b, c, d\n  ) => ({\n    a,\n    b,\n    c,\n    d,\n  })\n  const barFn = partial(\n    fooFn, [ 1, 2 ], []\n  )\n\n  expect(barFn(1, 2)).toEqual({\n    a : [ 1, 2 ],\n    b : [],\n    c : 1,\n    d : 2,\n  })\n})\n\ntest('ramda spec', () => {\n  const sayHello = partial(greet, 'Hello')\n  const sayHelloToMs = partial(sayHello, 'Ms.')\n\n  expect(sayHelloToMs('Jane', 'Jones')).toBe('Hello, Ms. Jane Jones!')\n})",
    "explanation": "It is very similar to `R.curry`, but you can pass initial arguments when you create the curried function.\n\n`R.partial` will keep returning a function until all the arguments that the function `fn` expects are passed.\nThe name comes from the fact that you partially inject the inputs.",
    "example": "const fn = (title, firstName, lastName) => {\n  return title + ' ' + firstName + ' ' + lastName + '!'\n}\n\nconst canPassAnyNumberOfArguments = R.partial(fn, 'Hello')\nconst ramdaStyle = R.partial(fn, ['Hello'])\n\nconst finalFn = canPassAnyNumberOfArguments('Foo')\n\nfinalFn('Bar') // =>  'Hello, Foo Bar!'",
    "typescriptDefinitionTest": "import {partial} from 'rambda'\n\ndescribe('R.partial', () => {\n  it('happy', () => {\n    function greet(\n      salutation: string,\n      title: string,\n      firstName: string,\n      lastName: string\n    ) {\n      return `${salutation}, ${title} ${firstName} ${lastName}!`\n    }\n\n    const sayHello = partial(greet, ['Hello'])\n    const sayHelloToMs = partial(sayHello, ['Ms.'])\n    const result = sayHelloToMs('Jane', 'Jones')\n    result // $ExpectType string\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('partial', function() {\n  var disc = function(a, b, c) { // note disc(3, 7, 4) => 1\n    return b * b - 4 * a * c;\n  };\n  it('caches the initially supplied arguments', function() {\n    var f = R.partial(disc, [3]);\n    eq(f(7, 4), 1);\n    var g = R.partial(disc, [3, 7]);\n    eq(g(4), 1);\n  });\n  it('correctly reports the arity of the new function', function() {\n    var f = R.partial(disc, [3]);\n    eq(f.length, 2);\n    var g = R.partial(disc, [3, 7]);\n    eq(g.length, 1);\n  });\n});"
  },
  "partition": {
    "typing": "\npartition<T>(\n  predicate: Predicate<T>,\n  input: readonly T[]\n): [T[], T[]]",
    "allTypings": "partition<T>(\n  predicate: Predicate<T>,\n  input: readonly T[]\n): [T[], T[]];\npartition<T>(\n  predicate: Predicate<T>\n): (input: readonly T[]) => [T[], T[]];\npartition<T>(\n  predicate: (x: T, prop?: string) => boolean,\n  input: { [key: string]: T}\n): [{ [key: string]: T}, { [key: string]: T}];\npartition<T>(\n  predicate: (x: T, prop?: string) => boolean\n): (input: { [key: string]: T}) => [{ [key: string]: T}, { [key: string]: T}];",
    "categories": [
      "List",
      "Object"
    ],
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nexport function partitionObject(predicate, iterable){\n  const yes = {}\n  const no = {}\n  Object.entries(iterable).forEach(([ prop, value ]) => {\n    if (predicate(value, prop)){\n      yes[ prop ] = value\n    } else {\n      no[ prop ] = value\n    }\n  })\n\n  return [ yes, no ]\n}\n\nexport function partitionArray(predicate, list){\n  const yes = []\n  const no = []\n  let counter = -1\n\n  while (counter++ < list.length - 1){\n    if (predicate(list[ counter ])){\n      yes.push(list[ counter ])\n    } else {\n      no.push(list[ counter ])\n    }\n  }\n\n  return [ yes, no ]\n}\n\nexport function partition(predicate, iterable){\n  if (arguments.length === 1){\n    return listHolder => partition(predicate, listHolder)\n  }\n  if (!_isArray(iterable)) return partitionObject(predicate, iterable)\n\n  return partitionArray(predicate, iterable)\n}",
    "rambdaSpecs": "import { partition } from './partition'\n\ntest('with array', () => {\n  const predicate = (x) => {\n\n    return x > 2\n  }\n  const list = [ 1, 2, 3, 4 ]\n\n  const result = partition(predicate, list)\n  const expectedResult = [\n    [ 3, 4 ],\n    [ 1, 2 ],\n  ]\n\n  expect(result).toEqual(expectedResult)\n})\n\ntest('with object', () => {\n  const predicate = (value, prop) => {\n    expect(typeof prop).toBe('string')\n\n    return value > 2\n  }\n  const hash = {\n    a : 1,\n    b : 2,\n    c : 3,\n    d : 4,\n  }\n\n  const result = partition(predicate)(hash)\n  const expectedResult = [\n    {\n      c : 3,\n      d : 4,\n    },\n    {\n      a : 1,\n      b : 2,\n    },\n  ]\n\n  expect(result).toEqual(expectedResult)\n})\n\ntest('readme example', () => {\n  const list = [ 1, 2, 3 ]\n  const obj = {\n    a : 1,\n    b : 2,\n    c : 3,\n  }\n  const predicate = x => x > 2\n\n  const result = [ partition(predicate, list), partition(predicate, obj) ]\n  const expected = [\n    [ [ 3 ], [ 1, 2 ] ],\n    [\n      { c : 3 },\n      {\n        a : 1,\n        b : 2,\n      },\n    ],\n  ]\n  expect(result).toEqual(expected)\n})",
    "explanation": "It will return array of two objects/arrays according to `predicate` function. The first member holds all instanses of `input` that pass the `predicate` function, while the second member - those who doesn't.",
    "example": "const list = [1, 2, 3]\nconst obj = {a: 1, b: 2, c: 3}\nconst predicate = x => x > 2\n\nconst result = [\n  R.partition(predicate, list),\n  R.partition(predicate, obj)\n]\nconst expected = [\n  [[3], [1, 2]],\n  [{c: 3},  {a: 1, b: 2}],\n]\n// `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {partition} from 'rambda'\n\ndescribe('R.partition', () => {\n  it('with array', () => {\n    const predicate = (x: number) => {\n      return x > 2\n    }\n    const list = [1, 2, 3, 4]\n\n    const result = partition(predicate, list)\n    const curriedResult = partition(predicate)(list)\n    result // $ExpectType [number[], number[]]\n    curriedResult // $ExpectType [number[], number[]]\n  })\n\n  it('with object', () => {\n    const predicate = (value: number, prop?: string) => {\n      return value > 2\n    }\n    const hash = {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n    }\n\n    const result = partition(predicate, hash)\n    const curriedResult = partition(predicate)(hash)\n    result[0] // $ExpectType { [key: string]: number; }\n    result[1] // $ExpectType { [key: string]: number; }\n    curriedResult[0] // $ExpectType { [key: string]: number; }\n    curriedResult[1] // $ExpectType { [key: string]: number; }\n  })\n})",
    "failedSpecsReasons": "Ramda library supports fantasy-land",
    "failedSpecsCount": 1
  },
  "path": {
    "typing": "\npath<Input, T>(pathToSearch: Path, obj: Input): T | undefined",
    "allTypings": "path<Input, T>(pathToSearch: Path, obj: Input): T | undefined;\npath<T>(pathToSearch: Path, obj: any): T | undefined;\npath<T>(pathToSearch: Path): (obj: any) => T | undefined;\npath<Input, T>(pathToSearch: Path): (obj: Input) => T | undefined;",
    "categories": [
      "Object"
    ],
    "notes": "String anotation of `pathToSearch` is one of the differences between `Rambda` and `Ramda`.",
    "rambdaSource": "export function path(pathInput, obj){\n  if (arguments.length === 1) return _obj => path(pathInput, _obj)\n\n  if (obj === null || obj === undefined){\n    return undefined\n  }\n  let willReturn = obj\n  let counter = 0\n\n  const pathArrValue =\n    typeof pathInput === 'string' ? pathInput.split('.') : pathInput\n\n  while (counter < pathArrValue.length){\n    if (willReturn === null || willReturn === undefined){\n      return undefined\n    }\n    willReturn = willReturn[ pathArrValue[ counter ] ]\n    counter++\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { path } from './path'\n\ntest('with array inside object', () => {\n  const obj = { a : { b : [ 1, { c : 1 } ] } }\n\n  expect(path('a.b.1.c', obj)).toBe(1)\n})\n\ntest('works with undefined', () => {\n  const obj = { a : { b : { c : 1 } } }\n\n  expect(path('a.b.c.d.f', obj)).toBeUndefined()\n  expect(path('foo.babaz', undefined)).toBeUndefined()\n  expect(path('foo.babaz')(undefined)).toBeUndefined()\n})\n\ntest('works with string instead of array', () => {\n  expect(path('foo.bar.baz')({ foo : { bar : { baz : 'yes' } } })).toEqual('yes')\n})\n\ntest('path', () => {\n  expect(path([ 'foo', 'bar', 'baz' ])({ foo : { bar : { baz : 'yes' } } })).toEqual('yes')\n\n  expect(path([ 'foo', 'bar', 'baz' ])(null)).toBeUndefined()\n\n  expect(path([ 'foo', 'bar', 'baz' ])({ foo : { bar : 'baz' } })).toBeUndefined()\n})",
    "explanation": "If `pathToSearch` is `'a.b'` then it will return `1` if `obj` is `{a:{b:1}}`.\n\nIt will return `undefined`, if such path is not found.",
    "example": "const obj = {a: {b: 1}}\nconst pathToSearch = 'a.b'\nconst pathToSearchList = ['a', 'b']\n\nconst result = [\n  R.path(pathToSearch, obj),\n  R.path(pathToSearchList, obj),\n  R.path('a.b.c.d', obj)\n]\n// => [1, 1, undefined]",
    "typescriptDefinitionTest": "import {path} from 'rambda'\n\ninterface Input {\n  a: number,\n  b: {\n    c: boolean,\n  },\n}\n\ndescribe('R.path', () => {\n  it('without specified input type', () => {\n    const input = {a: 1, b: {c: true}}\n    const result = path<boolean>('a.b.c', input)\n    const resultCurried = path<boolean>('a.b.c')(input)\n    result // $ExpectType boolean | undefined\n    resultCurried // $ExpectType boolean | undefined\n  })\n\n  it('without specified output type', () => {\n    const input = {a: 1, b: {c: true}}\n    const result = path('a.b.c', input)\n    result // $ExpectType unknown\n  })\n\n  it('with string as path', () => {\n    const input: Input = {a: 1, b: {c: true}}\n    const resultA = path<boolean>('a.b.c', input)\n    const resultB = path<boolean>('a.b.c')(input)\n    resultA // $ExpectType boolean | undefined\n    resultB // $ExpectType boolean | undefined\n  })\n  it('with array as path', () => {\n    const input: Input = {a: 1, b: {c: true}}\n    const resultA = path<boolean>(['a', 'b', 'c'], input)\n    const resultB = path<boolean>(['a', 'b', 'c'])(input)\n    resultA // $ExpectType boolean | undefined\n    resultB // $ExpectType boolean | undefined\n  })\n})\n\ndescribe('path with specified input', () => {\n  it('with string as path', () => {\n    const input: Input = {a: 1, b: {c: true}}\n    // const wrongInput = { a: 1, b: true }\n    // const resultA = path<Input, boolean>('a.b.c', wrongInput)\n    const resultA = path<Input, boolean>('a.b.c', input)\n    const resultB = path<Input, boolean>('a.b.c')(input)\n    resultA // $ExpectType boolean | undefined\n    resultB // $ExpectType boolean | undefined\n  })\n  it('with array as path', () => {\n    const input: Input = {a: 1, b: {c: true}}\n    const resultA = path<Input, boolean>(['a', 'b', 'c'], input)\n    const resultB = path<Input, boolean>(['a', 'b', 'c'])(input)\n    resultA // $ExpectType boolean | undefined\n    resultB // $ExpectType boolean | undefined\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('path', function() {\n  var deepObject = {a: {b: {c: 'c'}}, falseVal: false, nullVal: null, undefinedVal: undefined, arrayVal: ['arr']};\n  it('takes a path that contains negative indices into arrays', function() {\n    eq(R.path(['x', -2], {x: ['a', 'b', 'c', 'd']}), 'c');\n    eq(R.path([-1, 'y'], [{x: 1, y: 99}, {x: 2, y: 98}, {x: 3, y: 97}]), 97);\n  });\n});",
    "failedSpecsReasons": "Ramda method supports negative indexes",
    "failedSpecsCount": 1
  },
  "pathEq": {
    "typing": "\npathEq(pathToSearch: Path, target: any, input: any): boolean",
    "allTypings": "pathEq(pathToSearch: Path, target: any, input: any): boolean;\npathEq(pathToSearch: Path, target: any): (input: any) => boolean;\npathEq(pathToSearch: Path): FunctionToolbelt.Curry<(a: any, b: any) => boolean>;",
    "categories": [
      "Object"
    ],
    "rambdaSource": "import { curry } from './curry'\nimport { equals } from './equals'\nimport { path } from './path'\n\nfunction pathEqFn(\n  pathToSearch, target, input\n){\n  return equals(path(pathToSearch, input), target)\n}\n\nexport const pathEq = curry(pathEqFn)",
    "rambdaSpecs": "import { pathEq } from './pathEq'\n\ntest('when true', () => {\n  const path = 'a.b'\n  const obj = { a : { b : { c : 1 } } }\n  const target = { c : 1 }\n\n  expect(pathEq(\n    path, target, obj\n  )).toBeTrue()\n})\n\ntest('when false', () => {\n  const path = 'a.b'\n  const obj = { a : { b : 1 } }\n  const target = 2\n\n  expect(pathEq(path, target)(obj)).toBeFalse()\n})\n\ntest('when wrong path', () => {\n  const path = 'foo.bar'\n  const obj = { a : { b : 1 } }\n  const target = 2\n\n  expect(pathEq(\n    path, target, obj\n  )).toBeFalse()\n})",
    "explanation": "It returns `true` if `pathToSearch` of `input` object is equal to `target` value.\n\n`pathToSearch` is passed to `R.path`, which means that it can be either a string or an array. Also equality between `target` and the found value is determined by `R.equals`.",
    "example": "const path = 'a.b'\nconst target = {c: 1}\nconst input = {a: {b: {c: 1}}}\n\nconst result = R.pathEq(\n  path,\n  target,\n  input\n)\n// => true",
    "typescriptDefinitionTest": "import {pathEq} from 'rambda'\n\ndescribe('R.pathEq', () => {\n  it('with string path', () => {\n    const pathToSearch = 'a.b.c'\n    const input = {a: {b: {c: 1}}}\n    const target = {c: 1}\n\n    const result = pathEq(pathToSearch, input, target)\n    const curriedResult = pathEq(pathToSearch, input, target)\n    result // $ExpectType boolean\n    curriedResult // $ExpectType boolean\n  })\n\n  it('with array path', () => {\n    const pathToSearch = ['a', 'b', 'c']\n    const input = {a: {b: {c: 1}}}\n    const target = {c: 1}\n\n    const result = pathEq(pathToSearch, input, target)\n    const curriedResult = pathEq(pathToSearch, input, target)\n    result // $ExpectType boolean\n    curriedResult // $ExpectType boolean\n  })\n})\n\ndescribe('with ramda specs', () => {\n  const testPath = ['x', 0, 'y']\n  const testObj = {\n    x: [\n      {y: 2, z: 3},\n      {y: 4, z: 5},\n    ],\n  }\n\n  const result1 = pathEq(testPath, 2, testObj)\n  const result2 = pathEq(testPath, 2)(testObj)\n  const result3 = pathEq(testPath)(2)(testObj)\n  const result4 = pathEq(testPath)(2, testObj)\n  result1 // $ExpectType boolean\n  result2 // $ExpectType boolean\n  result3 // $ExpectType boolean\n  result4 // $ExpectType boolean\n})",
    "failedSpecsReasons": "Ramda library supports fantasy-land",
    "failedSpecsCount": 1
  },
  "paths": {
    "typing": "\npaths<Input, T>(pathsToSearch: Path[], obj: Input): (T | undefined)[]",
    "allTypings": "paths<Input, T>(pathsToSearch: Path[], obj: Input): (T | undefined)[];\npaths<Input, T>(pathsToSearch: Path[]): (obj: Input) => (T | undefined)[];\npaths<T>(pathsToSearch: Path[], obj: any): (T | undefined)[];\npaths<T>(pathsToSearch: Path[]): (obj: any) => (T | undefined)[];",
    "categories": [
      "Object"
    ],
    "rambdaSource": "import { path } from './path'\n\nexport function paths(pathsToSearch, obj){\n  if (arguments.length === 1){\n    return _obj => paths(pathsToSearch, _obj)\n  }\n\n  return pathsToSearch.map(singlePath => path(singlePath, obj))\n}",
    "rambdaSpecs": "import { paths } from './paths'\n\nconst obj = {\n  a : {\n    b : {\n      c : 1,\n      d : 2,\n    },\n  },\n  p : [ { q : 3 } ],\n  x : {\n    y : 'FOO',\n    z : [ [ {} ] ],\n  },\n}\n\ntest('with string path + curry', () => {\n  const pathsInput = [ 'a.b.d', 'p.q' ]\n  const expected = [ 2, undefined ]\n  const result = paths(pathsInput, obj)\n  const curriedResult = paths(pathsInput)(obj)\n\n  expect(result).toEqual(expected)\n  expect(curriedResult).toEqual(expected)\n})\n\ntest('with array path', () => {\n  const result = paths([\n    [ 'a', 'b', 'c' ],\n    [ 'x', 'y' ],\n  ],\n  obj)\n\n  expect(result).toEqual([ 1, 'FOO' ])\n})\n\ntest('takes a paths that contains indices into arrays', () => {\n  expect(paths([\n    [ 'p', 0, 'q' ],\n    [ 'x', 'z', 0, 0 ],\n  ],\n  obj)).toEqual([ 3, {} ])\n  expect(paths([\n    [ 'p', 0, 'q' ],\n    [ 'x', 'z', 2, 1 ],\n  ],\n  obj)).toEqual([ 3, undefined ])\n})\n\ntest('gets a deep property\\'s value from objects', () => {\n  expect(paths([ [ 'a', 'b' ] ], obj)).toEqual([ obj.a.b ])\n  expect(paths([ [ 'p', 0 ] ], obj)).toEqual([ obj.p[ 0 ] ])\n})\n\ntest('returns undefined for items not found', () => {\n  expect(paths([ [ 'a', 'x', 'y' ] ], obj)).toEqual([ undefined ])\n  expect(paths([ [ 'p', 2 ] ], obj)).toEqual([ undefined ])\n})",
    "explanation": "It loops over members of `pathsToSearch` as `singlePath` and returns the array produced by `R.path(singlePath, obj)`.\n\nBecause it calls `R.path`, then `singlePath` can be either string or a list.",
    "example": "const obj = {\n  a : {\n    b : {\n      c : 1,\n      d : 2\n    }\n  }\n}\n\nconst result = R.paths([\n  'a.b.c',\n  'a.b.c.d',\n  'a.b.c.d.e',\n], obj)\n// => [1, 2, undefined]",
    "typescriptDefinitionTest": "import {paths} from 'rambda'\n\ninterface Input {\n  a: number,\n  b: number,\n  c: number,\n}\n\nconst input: Input = {a: 1, b: 2, c: 3}\n\ndescribe('R.paths', () => {\n  it('with dot notation', () => {\n    const result = paths<number>(['a.b.c', 'foo.bar'], input)\n    result // $ExpectType (number | undefined)[]\n  })\n\n  it('without type', () => {\n    const result = paths(['a.b.c', 'foo.bar'], input)\n    result // $ExpectType unknown[]\n  })\n\n  it('with array as path', () => {\n    const result = paths<number>([['a', 'b', 'c'], ['foo.bar']], input)\n    result // $ExpectType (number | undefined)[]\n  })\n\n  it('curried', () => {\n    const result = paths<number>([['a', 'b', 'c'], ['foo.bar']])(input)\n    result // $ExpectType (number | undefined)[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('paths', function() {\n  var obj = {\n    a: {\n      b: {\n        c: 1,\n        d: 2\n      }\n    },\n    p: [{q: 3}, 'Hi'],\n    x: {\n      y: 'Alice',\n      z: [[{}]]\n    }\n  };\n  it('takes a path that contains negative indices into arrays', function() {\n    eq(R.paths([['p', -2, 'q'], ['p', -1]], obj), [3, 'Hi']);\n    eq(R.paths([['p', -4, 'q'], ['x', 'z', -1, 0]], obj), [undefined, {}]);\n  });\n});",
    "failedSpecsReasons": "Ramda method supports negative indexes",
    "failedSpecsCount": 1
  },
  "pathOr": {
    "typing": "\npathOr<T>(defaultValue: T, pathToSearch: Path, obj: any): T",
    "allTypings": "pathOr<T>(defaultValue: T, pathToSearch: Path, obj: any): T;\npathOr<T>(defaultValue: T, pathToSearch: Path): (obj: any) => T;\npathOr<T>(defaultValue: T): FunctionToolbelt.Curry<(a: Path, b: any) => T>;",
    "categories": [
      "Object"
    ],
    "rambdaSource": "import { curry } from './curry'\nimport { defaultTo } from './defaultTo'\nimport { path } from './path'\n\nfunction pathOrFn(\n  defaultValue, list, obj\n){\n  return defaultTo(defaultValue, path(list, obj))\n}\n\nexport const pathOr = curry(pathOrFn)",
    "rambdaSpecs": "import { pathOr } from './pathOr'\n\ntest('with undefined', () => {\n  const result = pathOr(\n    'foo', 'x.y', { x : { y : 1 } }\n  )\n\n  expect(result).toEqual(1)\n})\n\ntest('with null', () => {\n  const result = pathOr(\n    'foo', 'x.y', null\n  )\n\n  expect(result).toEqual('foo')\n})\n\ntest('with NaN', () => {\n  const result = pathOr(\n    'foo', 'x.y', NaN\n  )\n\n  expect(result).toEqual('foo')\n})\n\ntest('curry case (x)(y)(z)', () => {\n  const result = pathOr('foo')('x.y.z')({ x : { y : { a : 1 } } })\n\n  expect(result).toEqual('foo')\n})\n\ntest('curry case (x)(y,z)', () => {\n  const result = pathOr('foo', 'x.y.z')({ x : { y : { a : 1 } } })\n\n  expect(result).toEqual('foo')\n})\n\ntest('curry case (x,y)(z)', () => {\n  const result = pathOr('foo')('x.y.z', { x : { y : { a : 1 } } })\n\n  expect(result).toEqual('foo')\n})",
    "explanation": "It reads `obj` input and returns either `R.path(pathToSearch, obj)` result or `defaultValue` input.",
    "example": "const defaultValue = 'DEFAULT_VALUE'\nconst pathToSearch = 'a.b'\nconst pathToSearchList = ['a', 'b']\n\nconst obj = {\n  a : {\n    b : 1\n  }\n}\n\nconst result = [\n  R.pathOr(DEFAULT_VALUE, pathToSearch, obj) \n  R.pathOr(DEFAULT_VALUE, pathToSearchList, obj) \n  R.pathOr(DEFAULT_VALUE, 'a.b.c', obj) \n]\n// => [1, 1, 'DEFAULT_VALUE']",
    "typescriptDefinitionTest": "import {pathOr} from 'rambda'\n\ndescribe('R.pathOr', () => {\n  it('with string path', () => {\n    const x = pathOr<string>('foo', 'x.y', {x: {y: 'bar'}})\n    x // $ExpectType string\n  })\n  it('with array path', () => {\n    const x = pathOr<string>('foo', ['x', 'y'], {x: {y: 'bar'}})\n    x // $ExpectType string\n  })\n  it('without passing type looks bad', () => {\n    const x = pathOr('foo', 'x.y', {x: {y: 'bar'}})\n    x // $ExpectType \"foo\"\n  })\n  it('curried', () => {\n    const x = pathOr<string>('foo', 'x.y')({x: {y: 'bar'}})\n    x // $ExpectType string\n  })\n})"
  },
  "pick": {
    "typing": "\npick<T, K extends string | number | symbol>(propsToPick: readonly K[], input: T): Pick<T, Exclude<keyof T, Exclude<keyof T, K>>>",
    "allTypings": "pick<T, K extends string | number | symbol>(propsToPick: readonly K[], input: T): Pick<T, Exclude<keyof T, Exclude<keyof T, K>>>;\npick<K extends string | number | symbol>(propsToPick: readonly K[]): <T>(input: T) => Pick<T, Exclude<keyof T, Exclude<keyof T, K>>>;\npick<T, U>(propsToPick: string, input: T): U;\npick<T, U>(propsToPick: string): (input: T) => U;\npick<T>(propsToPick: string, input: object): T;\npick<T>(propsToPick: string): (input: object) => T;",
    "categories": [
      "Object",
      "List"
    ],
    "notes": "When using this method with `TypeScript`, it is much easier to pass `propsToPick` as an array. If passing a string, you will need to explicitly declare the output type.",
    "rambdaSource": "export function pick(propsToPick, input){\n  if (arguments.length === 1) return _input => pick(propsToPick, _input)\n\n  if (input === null || input === undefined){\n    return undefined\n  }\n  const keys =\n    typeof propsToPick === 'string' ? propsToPick.split(',') : propsToPick\n\n  const willReturn = {}\n  let counter = 0\n\n  while (counter < keys.length){\n    if (keys[ counter ] in input){\n      willReturn[ keys[ counter ] ] = input[ keys[ counter ] ]\n    }\n    counter++\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { pick } from './pick'\n\nconst obj = {\n  a : 1,\n  b : 2,\n  c : 3,\n}\n\ntest('props to pick is a string', () => {\n  const result = pick('a,c', obj)\n  const resultCurry = pick('a,c')(obj)\n  const expectedResult = {\n    a : 1,\n    c : 3,\n  }\n\n  expect(result).toEqual(expectedResult)\n  expect(resultCurry).toEqual(expectedResult)\n})\n\ntest('when prop is missing', () => {\n  const result = pick('a,d,f', obj)\n  expect(result).toEqual({ a : 1 })\n})\n\ntest('props to pick is an array', () => {\n  expect(pick([ 'a', 'c' ])({\n    a : 'foo',\n    b : 'bar',\n    c : 'baz',\n  })).toEqual({\n    a : 'foo',\n    c : 'baz',\n  })\n\n  expect(pick([ 'a', 'd', 'e', 'f' ])({\n    a : 'foo',\n    b : 'bar',\n    c : 'baz',\n  })).toEqual({ a : 'foo' })\n\n  expect(pick('a,d,e,f')(null)).toEqual(undefined)\n})\n\ntest('works with list as input and number as props - props to pick is an array', () => {\n  const result = pick([ 1, 2 ], [ 'a', 'b', 'c', 'd' ])\n  expect(result).toEqual({\n    1 : 'b',\n    2 : 'c',\n  })\n})\n\ntest('works with list as input and number as props - props to pick is a string', () => {\n  const result = pick('1,2', [ 'a', 'b', 'c', 'd' ])\n  expect(result).toEqual({\n    1 : 'b',\n    2 : 'c',\n  })\n})\n\ntest('with symbol', () => {\n  const symbolProp = Symbol('s')\n  expect(pick([ symbolProp ], { [ symbolProp ] : 'a' })).toMatchInlineSnapshot(`\n    Object {\n      Symbol(s): \"a\",\n    }\n  `)\n})",
    "explanation": "It returns a partial copy of an `input` containing only `propsToPick` properties.\n\n`input` can be either an object or an array.\n\nString anotation of `propsToPick` is one of the differences between `Rambda` and `Ramda`.",
    "example": "const obj = {\n  a : 1,\n  b : false,\n  foo: 'cherry'\n}\nconst list = [1, 2, 3, 4]\nconst propsToPick = 'a,foo'\nconst propsToPickList = ['a', 'foo']\n\nconst result = [\n  R.pick(propsToPick, obj),\n  R.pick(propsToPickList, obj),\n  R.pick('a,bar', obj),\n  R.pick('bar', obj),\n  R.pick([0, 3], list),\n  R.pick('0,3', list),\n]\n\nconst expected = [\n  {a:1, foo: 'cherry'},\n  {a:1, foo: 'cherry'},\n  {a:1},\n  {},\n  [1,4],\n  [1,4]\n]\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {pick} from 'rambda'\n\nconst input = {a: 'foo', b: 2, c: 3, d: 4}\n\ndescribe('R.pick with array as props input', () => {\n  it('without passing type', () => {\n    const result = pick(['a', 'c'], input)\n    result.a // $ExpectType string\n    result.c // $ExpectType number\n  })\n})\n\ndescribe('R.pick with string as props input', () => {\n  interface Input {\n    a: string,\n    b: number,\n    c: number,\n    d: number,\n  }\n  interface Output {\n    a: string,\n    c: number,\n  }\n  it('explicitly declare output', () => {\n    const result = pick<Output>('a,c', input)\n    result // $ExpectType Output\n    result.a // $ExpectType string\n    result.c // $ExpectType number\n\n    const curriedResult = pick<Output>('a,c')(input)\n\n    curriedResult.a // $ExpectType string\n  })\n\n  it('explicitly declare input and output', () => {\n    const result = pick<Input, Output>('a,c', input)\n    result // $ExpectType Output\n    result.a // $ExpectType string\n\n    const curriedResult = pick<Input, Output>('a,c')(input)\n\n    curriedResult.a // $ExpectType string\n  })\n\n  it('without passing type', () => {\n    const result = pick('a,c', input)\n    result // $ExpectType unknown\n  })\n})"
  },
  "pickAll": {
    "typing": "\npickAll<T, U>(propsToPick: readonly string[], input: T): U",
    "allTypings": "pickAll<T, U>(propsToPick: readonly string[], input: T): U;\npickAll<T, U>(propsToPick: readonly string[]): (input: T) => U;\npickAll<T, U>(propsToPick: string, input: T): U;\npickAll<T, U>(propsToPick: string): (input: T) => U;",
    "categories": [
      "Object"
    ],
    "notes": "When using this method with `TypeScript`, it is much easier to pass `propsToPick` as an array. If passing a string, you will need to explicitly declare the output type.",
    "rambdaSource": "export function pickAll(propsToPick, obj){\n  if (arguments.length === 1) return _obj => pickAll(propsToPick, _obj)\n\n  if (obj === null || obj === undefined){\n    return undefined\n  }\n  const keysValue =\n    typeof propsToPick === 'string' ? propsToPick.split(',') : propsToPick\n\n  const willReturn = {}\n  let counter = 0\n\n  while (counter < keysValue.length){\n    if (keysValue[ counter ] in obj){\n      willReturn[ keysValue[ counter ] ] = obj[ keysValue[ counter ] ]\n    } else {\n      willReturn[ keysValue[ counter ] ] = undefined\n    }\n    counter++\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { pickAll } from './pickAll'\n\ntest('when input is undefined or null', () => {\n  expect(pickAll('a', null)).toBe(undefined)\n  expect(pickAll('a', undefined)).toBe(undefined)\n})\n\ntest('with string as condition', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n    c : 3,\n  }\n  const result = pickAll('a,c', obj)\n  const resultCurry = pickAll('a,c')(obj)\n  const expectedResult = {\n    a : 1,\n    b : undefined,\n    c : 3,\n  }\n\n  expect(result).toEqual(expectedResult)\n  expect(resultCurry).toEqual(expectedResult)\n})\n\ntest('with array as condition', () => {\n  expect(pickAll([ 'a', 'b', 'c' ], {\n    a : 'foo',\n    c : 'baz',\n  })).toEqual({\n    a : 'foo',\n    b : undefined,\n    c : 'baz',\n  })\n})",
    "explanation": "Same as `R.pick` but it won't skip the missing props, i.e. it will assign them to `undefined`.",
    "example": "const obj = {\n  a : 1,\n  b : false,\n  foo: 'cherry'\n}\nconst propsToPick = 'a,foo,bar'\nconst propsToPickList = ['a', 'foo', 'bar']\n\nconst result = [\n  R.pickAll(propsToPick, obj),\n  R.pickAll(propsToPickList, obj),\n  R.pickAll('a,bar', obj),\n  R.pickAll('bar', obj),\n]\nconst expected = [\n  {a:1, foo: 'cherry', bar: undefined},\n  {a:1, foo: 'cherry', bar: undefined},\n  {a:1, bar: undefined},\n  {bar: undefined}\n]\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {pickAll} from 'rambda'\n\ninterface Input {\n  a: string,\n  b: number,\n  c: number,\n  d: number,\n}\ninterface Output {\n  a?: string,\n  c?: number,\n}\nconst input = {a: 'foo', b: 2, c: 3, d: 4}\n\ndescribe('R.pickAll with array as props input', () => {\n  it('without passing type', () => {\n    const result = pickAll(['a', 'c'], input)\n    result // $ExpectType unknown\n  })\n  it('without passing type + curry', () => {\n    const result = pickAll(['a', 'c'])(input)\n    result // $ExpectType unknown\n  })\n  it('explicitly passing types', () => {\n    const result = pickAll<Input, Output>(['a', 'c'], input)\n    result.a // $ExpectType string | undefined\n    result.c // $ExpectType number | undefined\n  })\n  it('explicitly passing types + curry', () => {\n    const result = pickAll<Input, Output>(['a', 'c'])(input)\n    result.a // $ExpectType string | undefined\n    result.c // $ExpectType number | undefined\n  })\n})\n\ndescribe('R.pickAll with string as props input', () => {\n  it('without passing type', () => {\n    const result = pickAll('a,c', input)\n    result // $ExpectType unknown\n  })\n  it('without passing type + curry', () => {\n    const result = pickAll('a,c')(input)\n    result // $ExpectType unknown\n  })\n  it('explicitly passing types', () => {\n    const result = pickAll<Input, Output>('a,c', input)\n    result.a // $ExpectType string | undefined\n    result.c // $ExpectType number | undefined\n  })\n  it('explicitly passing types + curry', () => {\n    const result = pickAll<Input, Output>('a,c')(input)\n    result.a // $ExpectType string | undefined\n    result.c // $ExpectType number | undefined\n  })\n})"
  },
  "pipe": {
    "typing": "\npipe<T1>(fn0: () => T1): () => T1",
    "allTypings": "pipe<T1>(fn0: () => T1): () => T1;\npipe<V0, T1>(fn0: (x0: V0) => T1): (x0: V0) => T1;\npipe<V0, V1, T1>(fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T1;\npipe<V0, V1, V2, T1>(fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T1;\n\npipe<T1, T2>(fn0: () => T1, fn1: (x: T1) => T2): () => T2;\npipe<V0, T1, T2>(fn0: (x0: V0) => T1, fn1: (x: T1) => T2): (x0: V0) => T2;\npipe<V0, V1, T1, T2>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2): (x0: V0, x1: V1) => T2;\npipe<V0, V1, V2, T1, T2>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2): (x0: V0, x1: V1, x2: V2) => T2;\n\npipe<T1, T2, T3>(fn0: () => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): () => T3;\npipe<V0, T1, T2, T3>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): (x: V0) => T3;\npipe<V0, V1, T1, T2, T3>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): (x0: V0, x1: V1) => T3;\npipe<V0, V1, V2, T1, T2, T3>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): (x0: V0, x1: V1, x2: V2) => T3;\n\npipe<T1, T2, T3, T4>(fn0: () => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): () => T4;\npipe<V0, T1, T2, T3, T4>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): (x: V0) => T4;\npipe<V0, V1, T1, T2, T3, T4>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): (x0: V0, x1: V1) => T4;\npipe<V0, V1, V2, T1, T2, T3, T4>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): (x0: V0, x1: V1, x2: V2) => T4;\n\npipe<T1, T2, T3, T4, T5>(fn0: () => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): () => T5;\npipe<V0, T1, T2, T3, T4, T5>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): (x: V0) => T5;\npipe<V0, V1, T1, T2, T3, T4, T5>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): (x0: V0, x1: V1) => T5;\npipe<V0, V1, V2, T1, T2, T3, T4, T5>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): (x0: V0, x1: V1, x2: V2) => T5;\n\npipe<T1, T2, T3, T4, T5, T6>(fn0: () => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6): () => T6;\npipe<V0, T1, T2, T3, T4, T5, T6>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6): (x: V0) => T6;\npipe<V0, V1, T1, T2, T3, T4, T5, T6>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6): (x0: V0, x1: V1) => T6;\npipe<V0, V1, V2, T1, T2, T3, T4, T5, T6>(\n  fn0: (x0: V0, x1: V1, x2: V2) => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6): (x0: V0, x1: V1, x2: V2) => T6;\n\npipe<T1, T2, T3, T4, T5, T6, T7>(\n  fn0: () => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn: (x: T6) => T7): () => T7;\npipe<V0, T1, T2, T3, T4, T5, T6, T7>(\n  fn0: (x: V0) => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn: (x: T6) => T7): (x: V0) => T7;\npipe<V0, V1, T1, T2, T3, T4, T5, T6, T7>(\n  fn0: (x0: V0, x1: V1) => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn6: (x: T6) => T7): (x0: V0, x1: V1) => T7;\npipe<V0, V1, V2, T1, T2, T3, T4, T5, T6, T7>(\n  fn0: (x0: V0, x1: V1, x2: V2) => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn6: (x: T6) => T7): (x0: V0, x1: V1, x2: V2) => T7;\n\npipe<T1, T2, T3, T4, T5, T6, T7, T8>(\n  fn0: () => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn6: (x: T6) => T7,\n  fn: (x: T7) => T8): () => T8;\npipe<V0, T1, T2, T3, T4, T5, T6, T7, T8>(\n  fn0: (x: V0) => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn6: (x: T6) => T7,\n  fn: (x: T7) => T8): (x: V0) => T8;\npipe<V0, V1, T1, T2, T3, T4, T5, T6, T7, T8>(\n  fn0: (x0: V0, x1: V1) => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn6: (x: T6) => T7,\n  fn7: (x: T7) => T8): (x0: V0, x1: V1) => T8;\npipe<V0, V1, V2, T1, T2, T3, T4, T5, T6, T7, T8>(\n  fn0: (x0: V0, x1: V1, x2: V2) => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn6: (x: T6) => T7,\n  fn7: (x: T7) => T8): (x0: V0, x1: V1, x2: V2) => T8;\n\npipe<T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n  fn0: () => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn6: (x: T6) => T7,\n  fn7: (x: T7) => T8,\n  fn8: (x: T8) => T9): () => T9;\npipe<V0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n  fn0: (x0: V0) => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn6: (x: T6) => T7,\n  fn7: (x: T7) => T8,\n  fn8: (x: T8) => T9): (x0: V0) => T9;\npipe<V0, V1, T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n  fn0: (x0: V0, x1: V1) => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn6: (x: T6) => T7,\n  fn7: (x: T7) => T8,\n  fn8: (x: T8) => T9): (x0: V0, x1: V1) => T9;\npipe<V0, V1, V2, T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n  fn0: (x0: V0, x1: V1, x2: V2) => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn6: (x: T6) => T7,\n  fn7: (x: T7) => T8,\n  fn8: (x: T8) => T9): (x0: V0, x1: V1, x2: V2) => T9;\n\npipe<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n  fn0: () => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn6: (x: T6) => T7,\n  fn7: (x: T7) => T8,\n  fn8: (x: T8) => T9,\n  fn9: (x: T9) => T10): () => T10;\npipe<V0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n  fn0: (x0: V0) => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn6: (x: T6) => T7,\n  fn7: (x: T7) => T8,\n  fn8: (x: T8) => T9,\n  fn9: (x: T9) => T10): (x0: V0) => T10;\npipe<V0, V1, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n  fn0: (x0: V0, x1: V1) => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn6: (x: T6) => T7,\n  fn7: (x: T7) => T8,\n  fn8: (x: T8) => T9,\n  fn9: (x: T9) => T10): (x0: V0, x1: V1) => T10;\npipe<V0, V1, V2, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n  fn0: (x0: V0, x1: V1, x2: V2) => T1,\n  fn1: (x: T1) => T2,\n  fn2: (x: T2) => T3,\n  fn3: (x: T3) => T4,\n  fn4: (x: T4) => T5,\n  fn5: (x: T5) => T6,\n  fn6: (x: T6) => T7,\n  fn7: (x: T7) => T8,\n  fn8: (x: T8) => T9,\n  fn9: (x: T9) => T10): (x0: V0, x1: V1, x2: V2) => T10;",
    "categories": [
      "Function"
    ],
    "rambdaSource": "import { compose } from './compose'\n\nexport function pipe(...fns){\n  if (fns.length === 0)\n    throw new Error('pipe requires at least one argument')\n\n  return compose(...fns.reverse())\n}",
    "rambdaSpecs": "import { add, last, map } from '../rambda'\nimport { pipe } from './pipe'\n\ntest('happy', () => {\n  const list = [ 1, 2, 3 ]\n\n  const result = pipe(\n    map(add(1)), map(add(10)), last\n  )(list)\n\n  expect(result).toEqual(14)\n})\n\ntest('with bad input', () => {\n  expect(() => pipe()).toThrowWithMessage(Error,\n    'pipe requires at least one argument')\n})",
    "explanation": "It performs left-to-right function composition.",
    "example": "const result = R.pipe(\n  R.filter(val => val > 2),\n  R.map(a => a * 2)\n)([1, 2, 3, 4])\n\n// => [6, 8]",
    "typescriptDefinitionTest": "import {add, subtract, pipe} from 'rambda'\n\ndescribe('R.pipe', () => {\n  it('happy', () => {\n    const result = pipe(subtract(11), add(1), add(1))(1)\n    result // $ExpectType number\n  })\n\n  it('with void', () => {\n    const result = pipe(\n      () => {},\n      () => {}\n    )()\n    result // $ExpectType void\n  })\n})",
    "failedRamdaSpecs": "var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('pipe', function() {\n  it('performs left-to-right function composition', function() {\n    //  f :: (String, Number?) -> ([Number] -> [Number])\n    var f = R.pipe(parseInt, R.multiply, R.map);\n    eq(f.length, 2);\n    eq(f('10')([1, 2, 3]), [10, 20, 30]);\n    eq(f('10', 2)([1, 2, 3]), [2, 4, 6]);\n  });\n  it('passes context to functions', function() {\n    function x(val) {\n      return this.x * val;\n    }\n    function y(val) {\n      return this.y * val;\n    }\n    function z(val) {\n      return this.z * val;\n    }\n    var context = {\n      a: R.pipe(x, y, z),\n      x: 4,\n      y: 2,\n      z: 1\n    };\n    eq(context.a(5), 40);\n  });\n  it('can be applied to one argument', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.pipe(f);\n    eq(g.length, 3);\n    eq(g(1, 2, 3), [1, 2, 3]);\n  });\n});",
    "failedSpecsReasons": "Ramda method passes context to functions | Rambda composed functions have no length",
    "failedSpecsCount": 3
  },
  "pluck": {
    "typing": "\npluck<K extends keyof T, T>(property: K, list: readonly T[]): Array<T[K]>",
    "allTypings": "pluck<K extends keyof T, T>(property: K, list: readonly T[]): Array<T[K]>;\npluck<T>(property: number, list: ReadonlyArray<{ [k: number]: T }>): T[];\npluck<P extends string>(property: P): <T>(list: ReadonlyArray<Record<P, T>>) => T[];\npluck(property: number): <T>(list: ReadonlyArray<{ [k: number]: T }>) => T[];",
    "categories": [
      "List",
      "Object"
    ],
    "rambdaSource": "import { map } from './map'\n\nexport function pluck(property, list){\n  if (arguments.length === 1) return _list => pluck(property, _list)\n\n  const willReturn = []\n\n  map(x => {\n    if (x[ property ] !== undefined){\n      willReturn.push(x[ property ])\n    }\n  }, list)\n\n  return willReturn\n}",
    "rambdaSpecs": "import { pluck } from './pluck'\n\ntest('happy', () => {\n  expect(pluck('a')([ { a : 1 }, { a : 2 }, { b : 1 } ])).toEqual([ 1, 2 ])\n})\n\ntest('with number', () => {\n  const input = [\n    [ 1, 2 ],\n    [ 3, 4 ],\n  ]\n\n  expect(pluck(0, input)).toEqual([ 1, 3 ])\n})",
    "explanation": "It returns list of the values of `property` taken from the all objects inside `list`.",
    "example": "const list = [{a: 1}, {a: 2}, {b: 3}]\nconst property = 'a'\n\nR.pluck(list, property) \n// => [1, 2]",
    "typescriptDefinitionTest": "import {pluck} from 'rambda'\n\ndescribe('R.pluck', () => {\n  it('with object', () => {\n    interface ListMember {\n      a: number,\n      b: string,\n    }\n    const input: ListMember[] = [\n      {a: 1, b: 'foo'},\n      {a: 2, b: 'bar'},\n    ]\n    const resultA = pluck('a', input)\n    const resultB = pluck('b')(input)\n    resultA // $ExpectType number[]\n    resultB // $ExpectType string[]\n  })\n\n  it('with array', () => {\n    const input = [\n      [1, 2],\n      [3, 4],\n      [5, 6],\n    ]\n    const result = pluck(0, input)\n    const resultCurry = pluck(0)(input)\n    result // $ExpectType number[]\n    resultCurry // $ExpectType number[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('pluck', function() {\n  var people = [\n    {name: 'Fred', age: 23},\n    {name: 'Wilma', age: 21},\n    {name: 'Pebbles', age: 2}\n  ];\n  it('behaves as a transducer when given a transducer in list position', function() {\n    var numbers = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];\n    var transducer = R.compose(R.pluck('a'), R.map(R.add(1)), R.take(2));\n    eq(R.transduce(transducer, R.flip(R.append), [], numbers), [2, 3]);\n  });\n});",
    "failedSpecsReasons": "Ramda method behaves as a transducer",
    "failedSpecsCount": 1
  },
  "prepend": {
    "typing": "\nprepend<T>(x: T, input: T[]): T[]",
    "allTypings": "prepend<T>(x: T, input: T[]): T[];\nprepend<T>(x: T): (input: T[]) => T[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function prepend(x, input){\n  if (arguments.length === 1) return _input => prepend(x, _input)\n\n  if (typeof input === 'string') return [ x ].concat(input.split(''))\n\n  return [ x ].concat(input)\n}",
    "rambdaSpecs": "import { prepend } from './prepend'\n\ntest('happy', () => {\n  expect(prepend('yes', [ 'foo', 'bar', 'baz' ])).toEqual([\n    'yes',\n    'foo',\n    'bar',\n    'baz',\n  ])\n})\n\ntest('with empty list', () => {\n  expect(prepend('foo')([])).toEqual([ 'foo' ])\n})\n\ntest('with string instead of array', () => {\n  expect(prepend('foo')('bar')).toEqual([ 'foo', 'b', 'a', 'r' ])\n})",
    "explanation": "It adds element `x` at the beginning of `list`.",
    "example": "const result = R.prepend('foo', ['bar', 'baz'])\n// => ['foo', 'bar', 'baz']",
    "typescriptDefinitionTest": "import {prepend} from 'rambda'\n\nconst list = [1, 2, 3]\n\ndescribe('R.prepend', () => {\n  it('happy', () => {\n    const result = prepend(4, list)\n\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = prepend(4)(list)\n\n    result // $ExpectType number[]\n  })\n})"
  },
  "product": {
    "typing": "\nproduct(list: readonly number[]): number",
    "allTypings": "product(list: readonly number[]): number;",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { multiply } from './multiply'\nimport { reduce } from './reduce'\n\nexport const product = reduce(multiply, 1)",
    "rambdaSpecs": "import { product } from './product'\n\ntest('happy', () => {\n  expect(product([ 2, 3, 4 ])).toEqual(24)\n})\n\ntest('bad input', () => {\n  expect(product([ null ])).toEqual(0)\n  expect(product([])).toEqual(1)\n})",
    "example": "R.product([ 2, 3, 4 ])\n// => 24)",
    "typescriptDefinitionTest": "import {product} from 'rambda'\n\ndescribe('R.product', () => {\n  it('happy', () => {\n    const result = product([1, 2, 3])\n\n    result // $ExpectType number\n  })\n})"
  },
  "prop": {
    "typing": "\nprop<P extends keyof T, T>(propToFind: P, obj: T): T[P]",
    "allTypings": "prop<P extends keyof T, T>(propToFind: P, obj: T): T[P];\nprop<P extends string>(p: P): <T>(propToFind: Record<P, T>) => T;\nprop<P extends string, T>(p: P): (propToFind: Record<P, T>) => T;",
    "categories": [
      "Object"
    ],
    "rambdaSource": "export function prop(propToFind, obj){\n  if (arguments.length === 1) return _obj => prop(propToFind, _obj)\n\n  if (!obj) return undefined\n\n  return obj[ propToFind ]\n}",
    "rambdaSpecs": "import { prop } from './prop'\n\ntest('prop', () => {\n  expect(prop('foo')({ foo : 'baz' })).toEqual('baz')\n\n  expect(prop('bar')({ foo : 'baz' })).toEqual(undefined)\n\n  expect(prop('bar')(null)).toEqual(undefined)\n})",
    "explanation": "It returns the value of property `propToFind` in `obj`.\n\nIf there is no such property, it returns `undefined`.",
    "example": "const result = [\n  R.prop('x', {x: 100}), \n  R.prop('x', {a: 1}) \n]\n// => [100, undefined]",
    "typescriptDefinitionTest": "import {prop} from 'rambda'\n\nconst obj = {a: 1, b: 'foo'}\n\ndescribe('R.prop', () => {\n  it('happy', () => {\n    const result = prop('a', obj)\n\n    result // $ExpectType number\n  })\n  it('curried', () => {\n    const result = prop('b')(obj)\n\n    result // $ExpectType string\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('prop', function() {\n  var fred = {name: 'Fred', age: 23};\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.prop(0, deities), 'Cthulhu');\n    eq(R.prop(1, deities), 'Dagon');\n    eq(R.prop(2, deities), 'Yog-Sothoth');\n    eq(R.prop(-1, deities), 'Yog-Sothoth');\n  });\n});"
  },
  "propEq": {
    "typing": "\npropEq<K extends string | number>(propToFind: K, valueToMatch: any, obj: Record<K, any>): boolean",
    "allTypings": "propEq<K extends string | number>(propToFind: K, valueToMatch: any, obj: Record<K, any>): boolean;\npropEq<K extends string | number>(propToFind: K, valueToMatch: any): (obj: Record<K, any>) => boolean;\npropEq<K extends string | number>(propToFind: K): {\n  (valueToMatch: any, obj: Record<K, any>): boolean;\n  (valueToMatch: any): (obj: Record<K, any>) => boolean;\n};",
    "categories": [
      "Object"
    ],
    "rambdaSource": "import { curry } from './curry'\n\nfunction propEqFn(\n  propToFind, valueToMatch, obj\n){\n  if (!obj) return false\n\n  return obj[ propToFind ] === valueToMatch\n}\n\nexport const propEq = curry(propEqFn)",
    "rambdaSpecs": "import { propEq } from './propEq'\n\ntest('happy', () => {\n  expect(propEq('foo', 'bar')({ foo : 'bar' })).toBeTrue()\n  expect(propEq('foo', 'bar')({ foo : 'baz' })).toBeFalse()\n  expect(propEq('foo')('bar')({ foo : 'baz' })).toBeFalse()\n  expect(propEq(\n    'foo', 'bar', null\n  )).toBeFalse()\n})",
    "explanation": "It returns true if `obj` has property `propToFind` and its value is equal to `valueToMatch`.",
    "example": "const obj = { foo: 'bar' }\nconst secondObj = { foo: 1 }\n\nconst propToFind = 'foo'\nconst valueToMatch = 'bar'\n\nconst result = [\n  R.propEq(propToFind, valueToMatch, obj),\n  R.propEq(propToFind, valueToMatch, secondObj)\n]\n// => [true, false]",
    "typescriptDefinitionTest": "import {propEq} from 'rambda'\n\nconst property = 'foo'\nconst numberProperty = 1\nconst value = 'bar'\nconst obj = {[property]: value}\nconst objWithNumberIndex = {[numberProperty]: value}\n\ndescribe('R.propEq', () => {\n  it('happy', () => {\n    const result = propEq(property, value, obj)\n    result // $ExpectType boolean\n  })\n\n  it('number is property', () => {\n    const result = propEq(1, value, objWithNumberIndex)\n    result // $ExpectType boolean\n  })\n\n  it('with optional property', () => {\n    interface MyType {\n      optional?: string | number,\n    }\n\n    const myObject: MyType = {}\n    const valueToFind = '1111'\n    // $ExpectError\n    propEq('optional', valueToFind, myObject)\n\n    // $ExpectError\n    propEq('optional', valueToFind, myObject)\n  })\n\n  it('imported from @types/ramda', () => {\n    interface A {\n      foo: string | null;\n    }\n    const obj: A = {\n      foo: 'bar',\n    };\n    const value = '';\n    const result = propEq('foo', value)(obj);\n    result // $ExpectType boolean\n    \n    // $ExpectError\n    propEq('bar', value)(obj);\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('propEq', function() {\n  var obj1 = {name: 'Abby', age: 7, hair: 'blond'};\n  var obj2 = {name: 'Fred', age: 12, hair: 'brown'};\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.propEq(0, 'Cthulhu', deities), true);\n    eq(R.propEq(1, 'Dagon', deities), true);\n    eq(R.propEq(2, 'Yog-Sothoth', deities), true);\n    eq(R.propEq(-1, 'Yog-Sothoth', deities), true);\n    eq(R.propEq(3, undefined, deities), true);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.propEq('value', 0, {value: -0}), false);\n    eq(R.propEq('value', -0, {value: 0}), false);\n    eq(R.propEq('value', NaN, {value: NaN}), true);\n    eq(R.propEq('value', new Just([42]), {value: new Just([42])}), true);\n  });\n});",
    "failedSpecsReasons": "Ramda method pass to `equals` method if available",
    "failedSpecsCount": 1
  },
  "propIs": {
    "typing": "\npropIs(type: any, name: string, obj: any): boolean",
    "allTypings": "propIs(type: any, name: string, obj: any): boolean;\npropIs(type: any, name: string): (obj: any) => boolean;\npropIs(type: any): {\n    (name: string, obj: any): boolean;\n    (name: string): (obj: any) => boolean;\n};",
    "categories": [
      "Object"
    ],
    "rambdaSource": "import { curry } from './curry'\nimport { is } from './is'\n\nfunction propIsFn(\n  targetPrototype, property, obj\n){\n  return is(targetPrototype, obj[ property ])\n}\n\nexport const propIs = curry(propIsFn)",
    "rambdaSpecs": "import { propIs } from './propIs'\n\nconst obj = { value : 1 }\nconst property = 'value'\n\ntest('when true', () => {\n  expect(propIs(\n    Number, property, obj\n  )).toBeTrue()\n})\n\ntest('when false', () => {\n  expect(propIs(\n    String, property, obj\n  )).toBeFalse()\n  expect(propIs(\n    String, property, {}\n  )).toBeFalse()\n})",
    "explanation": "It returns `true` if `property` of `obj` is from `target` type.",
    "example": "const obj = {a:1, b: 'foo'}\nconst property = 'foo'\n\nconst result = [\n  R.propIs(String, property, obj),\n  R.propIs(Number, property, obj)\n]\n// => [true, false]",
    "typescriptDefinitionTest": "import {propIs} from 'rambda'\n\nconst property = 'a'\nconst obj = {a: 1}\n\ndescribe('R.propIs', () => {\n  it('happy', () => {\n    const result = propIs(Number, property, obj)\n    result // $ExpectType boolean\n  })\n\n  it('curried', () => {\n    const result = propIs(Number, property)(obj)\n    result // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('propIs', function() {\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.propIs(String, 0, deities), true);\n    eq(R.propIs(String, 1, deities), true);\n    eq(R.propIs(String, 2, deities), true);\n    eq(R.propIs(String, -1, deities), true);\n    eq(R.propIs(String, 3, deities), false);\n  });\n});"
  },
  "propOr": {
    "typing": "\npropOr<T>(defaultValue: T, property: string, obj: { [key: string]: T}): T",
    "allTypings": "propOr<T>(defaultValue: T, property: string, obj: { [key: string]: T}): T;\npropOr<T>(defaultValue: T, property: string): (obj: { [key: string]: T}) => T;\npropOr<T>(defaultValue: T): FunctionToolbelt.Curry<(property: string, obj: { [key: string]: T}) => T>;",
    "categories": [
      "Object"
    ],
    "rambdaSource": "import { curry } from './curry'\nimport { defaultTo } from './defaultTo'\n\nfunction propOrFn(\n  defaultValue, property, obj\n){\n  if (!obj) return defaultValue\n\n  return defaultTo(defaultValue, obj[ property ])\n}\n\nexport const propOr = curry(propOrFn)",
    "rambdaSpecs": "import { propOr } from './propOr'\n\ntest('propOr (result)', () => {\n  const obj = { a : 1 }\n  expect(propOr(\n    'default', 'a', obj\n  )).toEqual(1)\n  expect(propOr(\n    'default', 'notExist', obj\n  )).toEqual('default')\n  expect(propOr(\n    'default', 'notExist', null\n  )).toEqual('default')\n})\n\ntest('propOr (currying)', () => {\n  const obj = { a : 1 }\n  expect(propOr('default')('a', obj)).toEqual(1)\n  expect(propOr('default', 'a')(obj)).toEqual(1)\n  expect(propOr('default')('notExist', obj)).toEqual('default')\n  expect(propOr('default', 'notExist')(obj)).toEqual('default')\n})",
    "explanation": "It returns either `defaultValue` or the value of `property` in `obj`.",
    "example": "const obj = {a: 1}\nconst defaultValue = 'DEFAULT_VALUE'\nconst property = 'a'\n\nconst result = [\n  R.propOr(defaultValue, property, obj),\n  R.propOr(defaultValue, 'foo', obj)\n]\n// => [1, 'DEFAULT_VALUE']",
    "typescriptDefinitionTest": "import {propOr} from 'rambda'\n\nconst obj = {foo: 'bar'}\nconst property = 'foo'\nconst fallback = 'fallback'\n\ndescribe('R.propOr', () => {\n  it('happy', () => {\n    const result = propOr(fallback, property, obj)\n    result // $ExpectType string\n  })\n  it('curry 1', () => {\n    const result = propOr(fallback)(property, obj)\n    result // $ExpectType string\n  })\n  it('curry 2', () => {\n    const result = propOr(fallback, property)(obj)\n    result // $ExpectType string\n  })\n  it('curry 3', () => {\n    const result = propOr(fallback)(property)(obj)\n    result // $ExpectType string\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('propOr', function() {\n  var fred = {name: 'Fred', age: 23};\n  var anon = {age: 99};\n  var nm = R.propOr('Unknown', 'name');\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.propOr('Unknown', 0, deities), 'Cthulhu');\n    eq(R.propOr('Unknown', 1, deities), 'Dagon');\n    eq(R.propOr('Unknown', 2, deities), 'Yog-Sothoth');\n    eq(R.propOr('Unknown', -1, deities), 'Yog-Sothoth');\n    eq(R.propOr('Unknown', 3, deities), 'Unknown');\n  });\n});"
  },
  "range": {
    "typing": "\nrange(startInclusive: number, endExclusive: number): number[]",
    "allTypings": "range(startInclusive: number, endExclusive: number): number[];\nrange(startInclusive: number): (endExclusive: number) => number[];",
    "categories": [
      "Number"
    ],
    "rambdaSource": "export function range(start, end){\n  if (arguments.length === 1) return _end => range(start, _end)\n\n  if (Number.isNaN(Number(start)) || Number.isNaN(Number(end))){\n    throw new TypeError('Both arguments to range must be numbers')\n  }\n\n  if (end < start) return []\n\n  const len = end - start\n  const willReturn = Array(len)\n\n  for (let i = 0; i < len; i++){\n    willReturn[ i ] = start + i\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { range } from './range'\n\ntest('happy', () => {\n  expect(range(0, 10)).toEqual([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ])\n})\n\ntest('end range is bigger than start range', () => {\n  expect(range(7, 3)).toEqual([])\n  expect(range(5, 5)).toEqual([])\n})\n\ntest('with bad input', () => {\n  const throwMessage = 'Both arguments to range must be numbers'\n  expect(() => range('a', 6)).toThrowWithMessage(Error, throwMessage)\n  expect(() => range(6, 'z')).toThrowWithMessage(Error, throwMessage)\n})\n\ntest('curry', () => {\n  expect(range(0)(10)).toEqual([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ])\n})",
    "explanation": "It returns list of numbers between `startInclusive` to `endExclusive` markers.",
    "example": "R.range(0, 5)\n// => [0, 1, 2, 3, 4]",
    "typescriptDefinitionTest": "import {range} from 'rambda'\n\ndescribe('R.range', () => {\n  it('happy', () => {\n    const result = range(1, 4)\n\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = range(1)(4)\n\n    result // $ExpectType number[]\n  })\n})"
  },
  "reduce": {
    "typing": "\nreduce<T, TResult>(reducer: (prev: TResult, current: T, i: number) => TResult, initialValue: TResult, list: readonly T[]): TResult",
    "allTypings": "reduce<T, TResult>(reducer: (prev: TResult, current: T, i: number) => TResult, initialValue: TResult, list: readonly T[]): TResult;\nreduce<T, TResult>(reducer: (prev: TResult, current: T) => TResult, initialValue: TResult, list: readonly T[]): TResult;\nreduce<T, TResult>(reducer: (prev: TResult, current: T, i?: number) => TResult): (initialValue: TResult, list: readonly T[]) => TResult;\nreduce<T, TResult>(reducer: (prev: TResult, current: T, i?: number) => TResult, initialValue: TResult): (list: readonly T[]) => TResult;",
    "categories": [
      "List"
    ],
    "notes": "It passes index of the list as third argument to `reducer` function.",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\nimport { _keys } from './_internals/_keys'\nimport { curry } from './curry'\n\nfunction reduceFn(\n  reducer, acc, list\n){\n  if (!_isArray(list)){\n    throw new TypeError('reduce: list must be array or iterable')\n  }\n  let index = 0\n  const len = list.length\n\n  while (index < len){\n    acc = reducer(\n      acc, list[ index ], index, list\n    )\n    index++\n  }\n\n  return acc\n}\n\nexport const reduce = curry(reduceFn)",
    "rambdaSpecs": "import { reduce } from './reduce'\n\nconst reducer = (\n  prev, current, i\n) => {\n  expect(i).toBeNumber()\n\n  return prev + current\n}\nconst initialValue = 1\nconst list = [ 1, 2, 3 ]\n\ntest('happy', () => {\n  expect(reduce(\n    reducer, initialValue, list\n  )).toEqual(7)\n})\n\ntest('with object as iterable', () => {\n  expect(() =>\n    reduce(\n      reducer, initialValue, {\n        a : 1,\n        b : 2,\n      }\n    )).toThrowWithMessage(TypeError, 'reduce: list must be array or iterable')\n})\n\ntest('with undefined as iterable', () => {\n  expect(() => reduce(\n    reducer, initialValue, undefined\n  )).toThrowWithMessage(TypeError,\n    'reduce: list must be array or iterable')\n})",
    "example": "const list = [1, 2, 3]\nconst initialValue = 10\nconst reducer = (prev, current) => prev * current\n\nconst result = R.reduce(reducer, initialValue, list)\n// => 60",
    "typescriptDefinitionTest": "import {reduce} from 'rambda'\n\ndescribe('R.reduce', () => {\n  it('happy', () => {\n    const result = reduce<number, number>(\n      (acc, elem) => {\n        acc // $ExpectType number\n        elem // $ExpectType number\n        return acc + elem\n      },\n      1,\n      [1, 2, 3]\n    )\n\n    result // $ExpectType number\n  })\n\n  it('with two types', () => {\n    const result = reduce<number, string>(\n      (acc, elem) => {\n        acc // $ExpectType string\n        elem // $ExpectType number\n\n        return `${acc}${elem}`\n      },\n      'foo',\n      [1, 2, 3]\n    )\n\n    result // $ExpectType string\n  })\n\n  it('with index', () => {\n    const result = reduce<number, number>(\n      (acc, elem, i) => {\n        acc // $ExpectType number\n        elem // $ExpectType number\n        i // $ExpectType number\n        return acc + elem\n      },\n      1,\n      [1, 2, 3]\n    )\n\n    result // $ExpectType number\n  })\n\n  it('fallback', () => {\n    const result = reduce(\n      (acc, val) => {\n        acc // $ExpectType number\n        return acc + val\n      },\n      1,\n      [1, 2, 3]\n    )\n\n    result // $ExpectType number\n  })\n\n  it('fallback with index', () => {\n    const result = reduce(\n      (acc, val, i) => {\n        acc // $ExpectType number\n        i // $ExpectType number\n        return acc + val\n      },\n      1,\n      [1, 2, 3]\n    )\n\n    result // $ExpectType number\n  })\n\n  it('fallback with two types', () => {\n    const result = reduce(\n      (acc, val) => {\n        acc // $ExpectType string\n        return acc + val\n      },\n      'foo',\n      [1, 2, 3]\n    )\n\n    result // $ExpectType string\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('reduce', function() {\n  var add = function(a, b) {return a + b;};\n  var mult = function(a, b) {return a * b;};\n  it('Prefers the use of the iterator of an object over reduce (and handles short-circuits)', function() {\n    var symIterator = (typeof Symbol !== 'undefined') ? Symbol.iterator : '@@iterator';\n    function Reducible(arr) {\n      this.arr = arr;\n    }\n    Reducible.prototype.reduce = function(f, init) {\n      var acc = init;\n      for (var i = 0; i < this.arr.length; i += 1) {\n        acc = f(acc, this.arr[i]);\n      }\n      return acc;\n    };\n    Reducible.prototype[symIterator] = function() {\n      var a = this.arr;\n      return {\n        _pos: 0,\n        next: function() {\n          if (this._pos < a.length) {\n            var v = a[this._pos];\n            this._pos += 1;\n            return {\n              value: v,\n              done: false\n            };\n          } else {\n            return {\n              done: true\n            };\n          }\n        }\n      };\n    };\n    var xf = R.take(2);\n    var apendingT = { };\n    apendingT['@@transducer/result'] = R.identity;\n    apendingT['@@transducer/step'] = R.flip(R.append);\n    var rfn = xf(apendingT);\n    var list = new Reducible([1, 2, 3, 4, 5, 6]);\n    eq(R.reduce(rfn, [], list), [1, 2]);\n  });\n  it('short circuits with reduced', function() {\n    var addWithMaxOf10 = function(acc, val) {return acc + val > 10 ? R.reduced(acc) : acc + val;};\n    eq(R.reduce(addWithMaxOf10, 0, [1, 2, 3, 4]), 10);\n    eq(R.reduce(addWithMaxOf10, 0, [2, 4, 6, 8]), 6);\n  });\n});",
    "failedSpecsReasons": "Rambda library doesn't have `R.reduced` method | Ramda method pass to `reduce` method",
    "failedSpecsCount": 2
  },
  "reject": {
    "typing": "\nreject<T>(predicate: Predicate<T>, list: readonly T[]): T[]",
    "allTypings": "reject<T>(predicate: Predicate<T>, list: readonly T[]): T[];\nreject<T>(predicate: Predicate<T>): (list: readonly T[]) => T[];\nreject<T>(predicate: Predicate<T>, obj: Dictionary<T>): Dictionary<T>;\nreject<T, U>(predicate: Predicate<T>): (obj: Dictionary<T>) => Dictionary<T>;",
    "categories": [
      "List",
      "Object"
    ],
    "rambdaSource": "import { filter } from './filter'\n\nexport function reject(predicate, list){\n  if (arguments.length === 1) return _list => reject(predicate, _list)\n\n  return filter(x => !predicate(x), list)\n}",
    "rambdaSpecs": "import { reject } from './reject'\n\nconst isOdd = n => n % 2 === 1\n\ntest('with array', () => {\n  expect(reject(isOdd)([ 1, 2, 3, 4 ])).toEqual([ 2, 4 ])\n})\n\ntest('with object', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n    c : 3,\n    d : 4,\n  }\n  expect(reject(isOdd, obj)).toEqual({\n    b : 2,\n    d : 4,\n  })\n})",
    "explanation": "It has the opposite effect of `R.filter`.",
    "example": "const list = [1, 2, 3, 4]\nconst obj = {a: 1, b: 2}\nconst predicate = x => x > 1\n\nconst result = [\n  R.reject(predicate, list)\n  R.reject(predicate, obj)\n]\n// => [[1, 2], {a: 1}]",
    "typescriptDefinitionTest": "import {reject} from 'rambda'\n\ndescribe('R.reject with array', () => {\n  it('happy', () => {\n    const result = reject(\n      x => {\n        x // $ExpectType number\n        return x > 1\n      },\n      [1, 2, 3]\n    )\n    result // $ExpectType number[]\n  })\n  it('curried require explicit type', () => {\n    const result = reject<number>(x => {\n      x // $ExpectType number\n      return x > 1\n    })([1, 2, 3])\n    result // $ExpectType number[]\n  })\n})\n\ndescribe('R.reject with objects', () => {\n  it('happy', () => {\n    const result = reject(\n      x => {\n        x // $ExpectType number\n\n        return x > 1\n      },\n      {a: 1, b: 2}\n    )\n    result // $ExpectType Dictionary<number>\n  })\n  it('curried require dummy type', () => {\n    const result = reject<number, any>(x => {\n      return x > 1\n    })({a: 1, b: 2})\n    result // $ExpectType Dictionary<number>\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('reject', function() {\n  var even = function(x) {return x % 2 === 0;};\n  it('dispatches to `filter` method', function() {\n    function Nothing() {}\n    Nothing.value = new Nothing();\n    Nothing.prototype.filter = function() {\n      return this;\n    };\n    function Just(x) { this.value = x; }\n    Just.prototype.filter = function(pred) {\n      return pred(this.value) ? this : Nothing.value;\n    };\n    var m = new Just(42);\n    eq(R.filter(R.T, m), m);\n    eq(R.filter(R.F, m), Nothing.value);\n    eq(R.reject(R.T, m), Nothing.value);\n    eq(R.reject(R.F, m), m);\n  });\n});",
    "failedSpecsReasons": "Ramda method dispatches to `filter` method",
    "failedSpecsCount": 1
  },
  "repeat": {
    "typing": "\nrepeat<T>(x: T): (timesToRepeat: number) => T[]",
    "allTypings": "repeat<T>(x: T): (timesToRepeat: number) => T[];\nrepeat<T>(x: T, timesToRepeat: number): T[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function repeat(x, timesToRepeat){\n  if (arguments.length === 1){\n    return _timesToRepeat => repeat(x, _timesToRepeat)\n  }\n\n  return Array(timesToRepeat).fill(x)\n}",
    "rambdaSpecs": "import { repeat } from './repeat'\n\ntest('repeat', () => {\n  expect(repeat('')(3)).toEqual([ '', '', '' ])\n  expect(repeat('foo', 3)).toEqual([ 'foo', 'foo', 'foo' ])\n\n  const obj = {}\n  const arr = repeat(obj, 3)\n\n  expect(arr).toEqual([ {}, {}, {} ])\n\n  expect(arr[ 0 ] === arr[ 1 ]).toBeTrue()\n})",
    "example": "R.repeat('foo', 3)\n// => ['foo', 'foo', 'foo']",
    "typescriptDefinitionTest": "import {repeat} from 'rambda'\n\ndescribe('R.repeat', () => {\n  it('happy', () => {\n    const result = repeat(4, 7)\n\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = repeat(4)(7)\n\n    result // $ExpectType number[]\n  })\n})"
  },
  "replace": {
    "typing": "\nreplace(strOrRegex: RegExp | string, replacer: string, str: string): string",
    "allTypings": "replace(strOrRegex: RegExp | string, replacer: string, str: string): string;\nreplace(strOrRegex: RegExp | string, replacer: string): (str: string) => string;\nreplace(strOrRegex: RegExp | string): (replacer: string) => (str: string) => string;",
    "categories": [
      "String"
    ],
    "rambdaSource": "import { curry } from './curry'\n\nfunction replaceFn(\n  pattern, replacer, str\n){\n  return str.replace(pattern, replacer)\n}\n\nexport const replace = curry(replaceFn)",
    "rambdaSpecs": "import { replace } from './replace'\n\ntest('happy', () => {\n  expect(replace(\n    'foo', 'yes', 'foo bar baz'\n  )).toEqual('yes bar baz')\n})\n\ntest('1', () => {\n  expect(replace(/\\s/g)('|')('foo bar baz')).toEqual('foo|bar|baz')\n})\n\ntest('2', () => {\n  expect(replace(/\\s/g)('|', 'foo bar baz')).toEqual('foo|bar|baz')\n})\n\ntest('3', () => {\n  expect(replace(/\\s/g, '|')('foo bar baz')).toEqual('foo|bar|baz')\n})",
    "explanation": "It replaces `strOrRegex` found in `str` with `replacer`.",
    "example": "const strOrRegex = /o/g\n\nconst result = R.replace(strOrRegex, '|0|', 'foo')\n// => 'f|0||0|'",
    "typescriptDefinitionTest": "import {replace} from 'rambda'\n\nconst str = 'foo bar foo'\nconst replacer = 'bar'\n\ndescribe('R.replace', () => {\n  it('happy', () => {\n    const result = replace(/foo/g, replacer, str)\n\n    result // $ExpectType string\n  })\n  it('with string as search pattern', () => {\n    const result = replace('foo', replacer, str)\n\n    result // $ExpectType string\n  })\n})\n\ndescribe('R.replace - curried', () => {\n  it('happy', () => {\n    const result = replace(/foo/g, replacer)(str)\n\n    result // $ExpectType string\n  })\n  it('with string as search pattern', () => {\n    const result = replace('foo', replacer)(str)\n\n    result // $ExpectType string\n  })\n})"
  },
  "reverse": {
    "typing": "\nreverse<T>(input: readonly T[]): T[]",
    "allTypings": "reverse<T>(input: readonly T[]): T[];\nreverse(input: string): string;",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "export function reverse(listOrString){\n  if (typeof listOrString === 'string'){\n    return listOrString.split('').reverse()\n      .join('')\n  }\n\n  const clone = listOrString.slice()\n\n  return clone.reverse()\n}",
    "rambdaSpecs": "import { reverse } from './reverse'\n\ntest('happy', () => {\n  expect(reverse([ 1, 2, 3 ])).toEqual([ 3, 2, 1 ])\n})\n\ntest('with string', () => {\n  expect(reverse('baz')).toEqual('zab')\n})\n\ntest('it doesn\\'t mutate', () => {\n  const arr = [ 1, 2, 3 ]\n\n  expect(reverse(arr)).toEqual([ 3, 2, 1 ])\n\n  expect(arr).toEqual([ 1, 2, 3 ])\n})",
    "explanation": "It returns a reversed copy of list or string `input`.",
    "example": "const result = [\n  R.reverse('foo'),\n  R.reverse([1, 2, 3])\n]\n// => ['oof', [3, 2, 1]",
    "typescriptDefinitionTest": "import {reverse} from 'rambda'\n\nconst list = [1, 2, 3, 4, 5]\n\ndescribe('R.reverse', () => {\n  it('happy', () => {\n    const result = reverse(list)\n    result // $ExpectType number[]\n  })\n})"
  },
  "slice": {
    "typing": "\nslice(from: number, to: number, input: string): string",
    "allTypings": "slice(from: number, to: number, input: string): string;\nslice<T>(from: number, to: number, input: readonly T[]): T[];\nslice(from: number, to: number): {\n  (input: string): string;\n  <T>(input: readonly T[]): T[];\n};\nslice(from: number): {\n  (to: number, input: string): string;\n  <T>(to: number, input: readonly T[]): T[];\n};",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "import { curry } from './curry'\n\nfunction sliceFn(\n  from, to, list\n){\n  return list.slice(from, to)\n}\n\nexport const slice = curry(sliceFn)",
    "rambdaSpecs": "import { slice } from './slice'\n\ntest('slice', () => {\n  expect(slice(\n    1, 3, [ 'a', 'b', 'c', 'd' ]\n  )).toEqual([ 'b', 'c' ])\n  expect(slice(\n    1, Infinity, [ 'a', 'b', 'c', 'd' ]\n  )).toEqual([ 'b', 'c', 'd' ])\n  expect(slice(\n    0, -1, [ 'a', 'b', 'c', 'd' ]\n  )).toEqual([ 'a', 'b', 'c' ])\n  expect(slice(\n    -3, -1, [ 'a', 'b', 'c', 'd' ]\n  )).toEqual([ 'b', 'c' ])\n  expect(slice(\n    0, 3, 'ramda'\n  )).toEqual('ram')\n})",
    "example": "const list = [0, 1, 2, 3, 4, 5]\nconst str = 'FOO_BAR'\nconst from = 1\nconst to = 4\n\nconst result = [\n  R.slice(str, to, list),\n  R.slice(from, to, list)\n]\n// => ['OO_', [1, 2, 3]]",
    "typescriptDefinitionTest": "import {slice} from 'rambda'\n\nconst list = [1, 2, 3, 4, 5]\n\ndescribe('R.slice', () => {\n  it('happy', () => {\n    const result = slice(1, 3, list)\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = slice(1, 3)(list)\n    result // $ExpectType number[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('slice', function() {\n  it('handles array-like object', function() {\n    var args = (function() { return arguments; }(1, 2, 3, 4, 5));\n    eq(R.slice(1, 4, args), [2, 3, 4]);\n  });\n});"
  },
  "sort": {
    "typing": "\nsort<T>(sortFn: (a: T, b: T) => number, list: readonly T[]): T[]",
    "allTypings": "sort<T>(sortFn: (a: T, b: T) => number, list: readonly T[]): T[];\nsort<T>(sortFn: (a: T, b: T) => number): (list: readonly T[]) => T[];",
    "categories": [
      "List"
    ],
    "notes": "`sortFn` function must return a number.",
    "rambdaSource": "export function sort(sortFn, list){\n  if (arguments.length === 1) return _list => sort(sortFn, _list)\n\n  const clone = list.slice()\n\n  return clone.sort(sortFn)\n}",
    "rambdaSpecs": "import { sort } from './sort'\n\nconst fn = (a, b) => a > b ? 1 : -1\n\ntest('sort', () => {\n  expect(sort((a, b) => a - b)([ 2, 3, 1 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('it doesn\\'t mutate', () => {\n  const list = [ 'foo', 'bar', 'baz' ]\n\n  expect(sort(fn, list)).toEqual([ 'bar', 'baz', 'foo' ])\n\n  expect(list[ 0 ]).toBe('foo')\n  expect(list[ 1 ]).toBe('bar')\n  expect(list[ 2 ]).toBe('baz')\n})",
    "explanation": "It returns copy of `list` sorted by `sortFn` function.",
    "example": "const list = [\n  {a: 2},\n  {a: 3},\n  {a: 1}\n]\nconst sortFn = (x, y) => {\n  return x.a > y.a ? 1 : -1\n}\n\nconst result = R.sort(sortFn, list)\nconst expected = [\n  {a: 1},\n  {a: 2},\n  {a: 3}\n]\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {sort} from 'rambda'\n\nconst list = [3, 0, 5, 2, 1]\n\nfunction sortFn(a: number, b: number): number {\n  return a > b ? 1 : -1\n}\n\ndescribe('R.sort', () => {\n  it('happy', () => {\n    const result = sort(sortFn, list)\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = sort(sortFn)(list)\n    result // $ExpectType number[]\n  })\n})"
  },
  "sortBy": {
    "typing": "\nsortBy<T>(sortFn: (a: T) => Ord, list: readonly T[]): T[]",
    "allTypings": "sortBy<T>(sortFn: (a: T) => Ord, list: readonly T[]): T[];\nsortBy(sortFn: (a: any) => Ord): <T>(list: readonly T[]) => T[];",
    "categories": [
      "List"
    ],
    "notes": "`sortFn` function must return a value to compare.",
    "rambdaSource": "export function sortBy(sortFn, list){\n  if (arguments.length === 1) return _list => sortBy(sortFn, _list)\n\n  const clone = list.slice()\n\n  return clone.sort((a, b) => {\n    const aSortResult = sortFn(a)\n    const bSortResult = sortFn(b)\n\n    if (aSortResult === bSortResult) return 0\n\n    return aSortResult < bSortResult ? -1 : 1\n  })\n}",
    "rambdaSpecs": "import { compose } from './compose'\nimport { prop } from './prop'\nimport { sortBy } from './sortBy'\nimport { toLower } from './toLower'\n\ntest('happy', () => {\n  const input = [ { a : 2 }, { a : 1 }, { a : 1 }, { a : 3 } ]\n  const expected = [ { a : 1 }, { a : 1 }, { a : 2 }, { a : 3 } ]\n\n  const result = sortBy(x => x.a)(input)\n  expect(result).toEqual(expected)\n})\n\ntest('with compose', () => {\n  const alice = {\n    name : 'ALICE',\n    age  : 101,\n  }\n  const bob = {\n    name : 'Bob',\n    age  : -10,\n  }\n  const clara = {\n    name : 'clara',\n    age  : 314.159,\n  }\n  const people = [ clara, bob, alice ]\n  const sortByNameCaseInsensitive = sortBy(compose(toLower, prop('name')))\n\n  expect(sortByNameCaseInsensitive(people)).toEqual([ alice, bob, clara ])\n})",
    "explanation": "It returns copy of `list` sorted by `sortFn` function.",
    "example": "const list = [\n  {a: 2},\n  {a: 3},\n  {a: 1}\n]\nconst sortFn = x => x.a\n\nconst result = R.sortBy(sortFn, list)\nconst expected = [\n  {a: 1},\n  {a: 2},\n  {a: 3}\n]\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {sortBy} from 'rambda'\n\ninterface Input {\n  a: number,\n}\n\ndescribe('R.sortBy', () => {\n  it('passing type to sort function', () => {\n    function fn(x: any): number {\n      return x.a\n    }\n    function fn2(x: Input): number {\n      return x.a\n    }\n\n    const input = [{a: 2}, {a: 1}, {a: 0}]\n    const result = sortBy(fn, input)\n    const curriedResult = sortBy(fn2)(input)\n\n    result // $ExpectType { a: number; }[]\n    curriedResult // $ExpectType { a: number; }[]\n    result[0].a // $ExpectType number\n  })\n  it('passing type to sort function and list', () => {\n    function fn(x: Input): number {\n      return x.a\n    }\n\n    const input: Input[] = [{a: 2}, {a: 1}, {a: 0}]\n    const result = sortBy(fn, input)\n    const curriedResult = sortBy(fn)(input)\n\n    result // $ExpectType Input[]\n    curriedResult // $ExpectType Input[]\n    result[0].a // $ExpectType number\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\nvar albums = [\n  {title: 'Art of the Fugue', artist: 'Glenn Gould', genre: 'Baroque'},\n  {title: 'A Farewell to Kings', artist: 'Rush', genre: 'Rock'},\n  {title: 'Timeout', artist: 'Dave Brubeck Quartet', genre: 'Jazz'},\n  {title: 'Fly By Night', artist: 'Rush', genre: 'Rock'},\n  {title: 'Goldberg Variations', artist: 'Daniel Barenboim', genre: 'Baroque'},\n  {title: 'New World Symphony', artist: 'Leonard Bernstein', genre: 'Romantic'},\n  {title: 'Romance with the Unseen', artist: 'Don Byron', genre: 'Jazz'},\n  {title: 'Somewhere In Time', artist: 'Iron Maiden', genre: 'Metal'},\n  {title: 'In Times of Desparation', artist: 'Danny Holt', genre: 'Modern'},\n  {title: 'Evita', artist: 'Various', genre: 'Broadway'},\n  {title: 'Five Leaves Left', artist: 'Nick Drake', genre: 'Folk'},\n  {title: 'The Magic Flute', artist: 'John Eliot Gardiner', genre: 'Classical'}\n];\ndescribe('sortBy', function() {\n  it('sorts array-like object', function() {\n    var args = (function() { return arguments; }('c', 'a', 'b'));\n    var result = R.sortBy(R.identity, args);\n    eq(result[0], 'a');\n    eq(result[1], 'b');\n    eq(result[2], 'c');\n  });\n});",
    "failedSpecsReasons": "Ramda method works with array-like objects",
    "failedSpecsCount": 1
  },
  "split": {
    "typing": "\nsplit(separator: string | RegExp): (str: string) => string[]",
    "allTypings": "split(separator: string | RegExp): (str: string) => string[];\nsplit(separator: string | RegExp, str: string): string[];",
    "categories": [
      "String"
    ],
    "rambdaSource": "export function split(separator, str){\n  if (arguments.length === 1) return _str => split(separator, _str)\n\n  return str.split(separator)\n}",
    "rambdaSpecs": "import { split } from './split'\n\nconst str = 'foo|bar|baz'\nconst splitChar = '|'\nconst expected = [ 'foo', 'bar', 'baz' ]\n\ntest('happy', () => {\n  expect(split(splitChar, str)).toEqual(expected)\n})\n\ntest('curried', () => {\n  expect(split(splitChar)(str)).toEqual(expected)\n})",
    "explanation": "Curried version of `String.prototype.split`",
    "example": "const str = 'foo|bar|baz'\nconst separator = |'\nconst result = R.split(separator, str))\n// => [ 'foo', 'bar', 'baz' ]",
    "typescriptDefinitionTest": "import {split} from 'rambda'\n\nconst str = 'foo|bar|baz'\nconst splitChar = '|'\n\ndescribe('R.split', () => {\n  it('happy', () => {\n    const result = split(splitChar, str)\n\n    result // $ExpectType string[]\n  })\n  it('curried', () => {\n    const result = split(splitChar)(str)\n\n    result // $ExpectType string[]\n  })\n})"
  },
  "splitEvery": {
    "typing": "\nsplitEvery<T>(sliceLength: number, input: readonly T[]): T[][]",
    "allTypings": "splitEvery<T>(sliceLength: number, input: readonly T[]): T[][];\nsplitEvery(sliceLength: number, input: string): string[];\nsplitEvery(sliceLength: number): {\n  (input: string): string[];\n  <T>(input: readonly T[]): T[][];\n};",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "export function splitEvery(sliceLength, listOrString){\n  if (arguments.length === 1){\n    return _listOrString => splitEvery(sliceLength, _listOrString)\n  }\n\n  if (sliceLength < 1){\n    throw new Error('First argument to splitEvery must be a positive integer')\n  }\n\n  const willReturn = []\n  let counter = 0\n\n  while (counter < listOrString.length){\n    willReturn.push(listOrString.slice(counter, counter += sliceLength))\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { splitEvery } from './splitEvery'\n\ntest('happy', () => {\n  expect(splitEvery(3, [ 1, 2, 3, 4, 5, 6, 7 ])).toEqual([\n    [ 1, 2, 3 ],\n    [ 4, 5, 6 ],\n    [ 7 ],\n  ])\n\n  expect(splitEvery(3)('foobarbaz')).toEqual([ 'foo', 'bar', 'baz' ])\n})\n\ntest('with bad input', () => {\n  expect(() =>\n    expect(splitEvery(0)('foo')).toEqual([ 'f', 'o', 'o' ])).toThrowWithMessage(Error,\n    'First argument to splitEvery must be a positive integer')\n})",
    "explanation": "It splits `input` into slices of `sliceLength`.",
    "example": "const result = [\n  R.splitEvery(2, [1, 2, 3]), \n  R.splitEvery(3, 'foobar') \n]\n\nconst expected = [\n  [[1, 2], [3]],\n  ['foo', 'bar']\n]\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {splitEvery} from 'rambda'\n\nconst list = [1, 2, 3, 4, 5, 6, 7]\n\ndescribe('R.splitEvery', () => {\n  it('happy', () => {\n    const result = splitEvery(3, list)\n\n    result // $ExpectType number[][]\n  })\n  it('curried', () => {\n    const result = splitEvery(3)(list)\n\n    result // $ExpectType number[][]\n  })\n})"
  },
  "startsWith": {
    "typing": "\nstartsWith(target: string, str: string): boolean",
    "allTypings": "startsWith(target: string, str: string): boolean;\nstartsWith(target: string): (str: string) => boolean;",
    "categories": [
      "String"
    ],
    "notes": "It doesn't work with arrays unlike its corresponding **Ramda** method.",
    "rambdaSource": "export function startsWith(target, str){\n  if (arguments.length === 1) return _str => startsWith(target, _str)\n\n  return str.startsWith(target)\n}",
    "rambdaSpecs": "import { startsWith } from './startsWith'\n\ntest('true', () => {\n  const result = startsWith('foo', 'foo-bar')\n\n  expect(result).toBeTrue()\n})\n\ntest('false', () => {\n  const result = startsWith('baz')('foo-bar')\n\n  expect(result).toBeFalse()\n})",
    "explanation": "Curried version of `String.prototype.startsWith`",
    "example": "const str = 'foo-bar'\n\nconst result = [\n  R.startsWith('foo', str),\n  R.startsWith('bar', str)\n]\n// => [true, false]",
    "typescriptDefinitionTest": "import {startsWith} from 'rambda'\n\nconst target = 'foo'\nconst input = 'foo bar'\n\ndescribe('R.startsWith', () => {\n  it('happy', () => {\n    const result = startsWith(target, input)\n\n    result // $ExpectType boolean\n  })\n  it('curried', () => {\n    const result = startsWith(target)(input)\n\n    result // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('startsWith', function() {\n  it('should return true when an array starts with the provided value', function() {\n    eq(R.startsWith(['a'], ['a', 'b', 'c']), true);\n  });\n  it('should return true when an array starts with the provided values', function() {\n    eq(R.startsWith(['a', 'b'], ['a', 'b', 'c']), true);\n  });\n  it('should return false when an array does not start with the provided value', function() {\n    eq(R.startsWith(['b'], ['a', 'b', 'c']), false);\n  });\n  it('should return false when an array does not start with the provided values', function() {\n    eq(R.startsWith(['b', 'c'], ['a', 'b', 'c']), false);\n  });\n});",
    "failedSpecsReasons": "Rambda method doesn't support arrays",
    "failedSpecsCount": 4
  },
  "subtract": {
    "typing": "\nsubtract(x: number, y: number): number",
    "allTypings": "subtract(x: number, y: number): number;\nsubtract(x: number): (y: number) => number;",
    "categories": [
      "Number"
    ],
    "rambdaSource": "export function subtract(a, b){\n  if (arguments.length === 1) return _b => subtract(a, _b)\n\n  return a - b\n}",
    "rambdaSpecs": "import { subtract } from './subtract'\n\ntest('happy', () => {\n  expect(subtract(2, 1)).toEqual(1)\n  expect(subtract(2)(1)).toEqual(1)\n})",
    "explanation": "Curried version of `x - y`",
    "example": "const x = 3\nconst y = 1\n\nR.subtract(x, y) \n// => 2"
  },
  "sum": {
    "typing": "\nsum(list: readonly number[]): number",
    "allTypings": "sum(list: readonly number[]): number;",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function sum(list){\n  return list.reduce((prev, current) => prev + current, 0)\n}",
    "rambdaSpecs": "import { sum } from './sum'\n\ntest('happy', () => {\n  expect(sum([ 1, 2, 3, 4, 5 ])).toBe(15)\n})",
    "example": "R.sum([1, 2, 3, 4, 5]) \n// => 15"
  },
  "symmetricDifference": {
    "typing": "\nsymmetricDifference<T>(x: readonly T[], y: readonly T[]): T[]",
    "allTypings": "symmetricDifference<T>(x: readonly T[], y: readonly T[]): T[];\nsymmetricDifference<T>(x: readonly T[]): <T>(y: readonly T[]) => T[];",
    "categories": [
      "List"
    ],
    "notes": "`R.equals` is used to determine equality, i.e. it can be safely used with list of objects.",
    "rambdaSource": "import { concat } from './concat'\nimport { filter } from './filter'\nimport { includes } from './includes'\n\nexport function symmetricDifference(x, y){\n  if (arguments.length === 1){\n    return _y => symmetricDifference(x, _y)\n  }\n\n  return concat(filter(value => !includes(value, y), x),\n    filter(value => !includes(value, x), y))\n}",
    "rambdaSpecs": "import { symmetricDifference } from './symmetricDifference'\n\ntest('symmetricDifference', () => {\n  const list1 = [ 1, 2, 3, 4 ]\n  const list2 = [ 3, 4, 5, 6 ]\n  expect(symmetricDifference(list1)(list2)).toEqual([ 1, 2, 5, 6 ])\n\n  expect(symmetricDifference([], [])).toEqual([])\n})\n\ntest('symmetricDifference with objects', () => {\n  const list1 = [ { id : 1 }, { id : 2 }, { id : 3 }, { id : 4 } ]\n  const list2 = [ { id : 3 }, { id : 4 }, { id : 5 }, { id : 6 } ]\n  expect(symmetricDifference(list1)(list2)).toEqual([\n    { id : 1 },\n    { id : 2 },\n    { id : 5 },\n    { id : 6 },\n  ])\n})",
    "explanation": "It returns a merged list of `x` and `y` with all equal elements removed.",
    "example": "const x = [ 1, 2, 3, 4 ]\nconst y = [ 3, 4, 5, 6 ]\n\nconst result = symmetricDifference(x, y)\n// => [ 1, 2, 5, 6 ]",
    "typescriptDefinitionTest": "import {symmetricDifference} from 'rambda'\n\ndescribe('R.symmetricDifference', () => {\n  it('happy', () => {\n    const list1 = [1, 2, 3, 4]\n    const list2 = [3, 4, 5, 6]\n    const result = symmetricDifference(list1, list2)\n\n    result // $ExpectType number[]\n  })\n\n  it('curried', () => {\n    const list1 = [{id: 1}, {id: 2}, {id: 3}, {id: 4}]\n    const list2 = [{id: 3}, {id: 4}, {id: 5}, {id: 6}]\n    const result = symmetricDifference(list1)(list2)\n\n    result // $ExpectType { id: number; }[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('symmetricDifference', function() {\n  var M = [1, 2, 3, 4];\n  var M2 = [1, 2, 3, 4, 1, 2, 3, 4];\n  var N = [3, 4, 5, 6];\n  var N2 = [3, 3, 4, 4, 5, 5, 6, 6];\n  var Z = [3, 4, 5, 6, 10];\n  var Z2 = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8];\n  it('does not allow duplicates in the output even if the input lists had duplicates', function() {\n    eq(R.symmetricDifference(M2, N2), [1, 2, 5, 6]);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.symmetricDifference([0], [-0]).length, 2);\n    eq(R.symmetricDifference([-0], [0]).length, 2);\n    eq(R.symmetricDifference([NaN], [NaN]).length, 0);\n    eq(R.symmetricDifference([new Just([42])], [new Just([42])]).length, 0);\n  });\n  it('will not create a \"sparse\" array', function() {\n    eq(R.symmetricDifference(M2, [3]).length, 3);\n  });\n});"
  },
  "T": {
    "typing": "\nT(): boolean",
    "allTypings": "T(): boolean;",
    "categories": [
      "Logic"
    ],
    "rambdaSource": "export function T(){\n  return true\n}",
    "example": "R.T() \n// => true"
  },
  "tail": {
    "typing": "\ntail<T>(input: readonly T[]): T[]",
    "allTypings": "tail<T>(input: readonly T[]): T[];\ntail(input: string): string;",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "import { drop } from './drop'\n\nexport function tail(listOrString){\n  return drop(1, listOrString)\n}",
    "rambdaSpecs": "import { tail } from './tail'\n\ntest('tail', () => {\n  expect(tail([ 1, 2, 3 ])).toEqual([ 2, 3 ])\n  expect(tail([ 1, 2 ])).toEqual([ 2 ])\n  expect(tail([ 1 ])).toEqual([])\n  expect(tail([])).toEqual([])\n\n  expect(tail('abc')).toEqual('bc')\n  expect(tail('ab')).toEqual('b')\n  expect(tail('a')).toEqual('')\n  expect(tail('')).toEqual('')\n})",
    "explanation": "It returns all but the first element of `input`.",
    "example": "const result = [\n  R.tail([1, 2, 3]),  \n  R.tail('foo') \n]\n// => [[2, 3], 'oo']",
    "typescriptDefinitionTest": "import {tail} from 'rambda'\n\ndescribe('R.tail', () => {\n  it('with string', () => {\n    const result = tail('foo')\n\n    result // $ExpectType string\n  })\n  it('with list', () => {\n    const result = tail([1, 2, 3])\n\n    result // $ExpectType number[]\n  })\n})"
  },
  "take": {
    "typing": "\ntake<T>(howMany: number, input: readonly T[]): T[]",
    "allTypings": "take<T>(howMany: number, input: readonly T[]): T[];\ntake(howMany: number, input: string): string;\ntake<T>(howMany: number): {\n  <T>(input: readonly T[]): T[];\n  (input: string): string;\n};",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "import baseSlice from './_internals/baseSlice'\n\nexport function take(howMany, listOrString){\n  if (arguments.length === 1)\n    return _listOrString => take(howMany, _listOrString)\n  if (howMany < 0) return listOrString.slice()\n  if (typeof listOrString === 'string') return listOrString.slice(0, howMany)\n\n  return baseSlice(\n    listOrString, 0, howMany\n  )\n}",
    "rambdaSpecs": "import { take } from './take'\n\ntest('happy', () => {\n  const arr = [ 'foo', 'bar', 'baz' ]\n\n  expect(take(1, arr)).toEqual([ 'foo' ])\n\n  expect(arr).toEqual([ 'foo', 'bar', 'baz' ])\n\n  expect(take(2)([ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar' ])\n  expect(take(3, [ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar', 'baz' ])\n  expect(take(4, [ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar', 'baz' ])\n  expect(take(3)('rambda')).toEqual('ram')\n})\n\ntest('with negative index', () => {\n  expect(take(-1, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(take(-Infinity, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('with zero index', () => {\n  expect(take(0, [ 1, 2, 3 ])).toEqual([])\n})",
    "explanation": "It returns the first `howMany` elements of `input`.",
    "example": "const howMany = 2\n\nconst result = [\n  R.take(howMany, [1, 2, 3]),\n  R.take(howMany, 'foobar'),\n]\n// => [[1, 2], 'fo']",
    "typescriptDefinitionTest": "import {take} from 'rambda'\n\nconst list = [1, 2, 3, 4]\nconst str = 'foobar'\nconst howMany = 2\n\ndescribe('R.take - array', () => {\n  it('happy', () => {\n    const result = take(howMany, list)\n\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = take(howMany)(list)\n\n    result // $ExpectType number[]\n  })\n})\n\ndescribe('R.take - string', () => {\n  it('happy', () => {\n    const result = take(howMany, str)\n\n    result // $ExpectType string\n  })\n  it('curried', () => {\n    const result = take(howMany)(str)\n\n    result // $ExpectType string\n  })\n})",
    "failedRamdaSpecs": "var assert = require('assert');\nvar sinon = require('sinon');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('take', function() {\n  it('handles zero correctly (#1224)', function() {\n    eq(R.into([], R.take(0), [1, 2, 3]), []);\n  });\n  it('steps correct number of times', function() {\n    var spy = sinon.spy();\n    R.into([], R.compose(R.map(spy), R.take(2)), [1, 2, 3]);\n    sinon.assert.calledTwice(spy);\n  });\n  it('transducer called for every member of list if `n` is < 0', function() {\n    var spy = sinon.spy();\n    R.into([], R.compose(R.map(spy), R.take(-1)), [1, 2, 3]);\n    sinon.assert.calledThrice(spy);\n  });\n});",
    "failedSpecsReasons": "Rambda library doesn't have 'R.into` method",
    "failedSpecsCount": 3
  },
  "takeLast": {
    "typing": "\ntakeLast<T>(howMany: number, input: readonly T[]): T[]",
    "allTypings": "takeLast<T>(howMany: number, input: readonly T[]): T[];\ntakeLast(howMany: number, input: string): string;\ntakeLast<T>(howMany: number): {\n  <T>(input: readonly T[]): T[];\n  (input: string): string;\n};",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "import baseSlice from './_internals/baseSlice'\n\nexport function takeLast(howMany, listOrString){\n  if (arguments.length === 1)\n    return _listOrString => takeLast(howMany, _listOrString)\n\n  const len = listOrString.length\n  if (howMany < 0) return listOrString.slice()\n  let numValue = howMany > len ? len : howMany\n\n  if (typeof listOrString === 'string')\n    return listOrString.slice(len - numValue)\n\n  numValue = len - numValue\n\n  return baseSlice(\n    listOrString, numValue, len\n  )\n}",
    "rambdaSpecs": "import { takeLast } from './takeLast'\n\ntest('with arrays', () => {\n  expect(takeLast(1, [ 'foo', 'bar', 'baz' ])).toEqual([ 'baz' ])\n\n  expect(takeLast(2)([ 'foo', 'bar', 'baz' ])).toEqual([ 'bar', 'baz' ])\n\n  expect(takeLast(3, [ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar', 'baz' ])\n\n  expect(takeLast(4, [ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar', 'baz' ])\n\n  expect(takeLast(10, [ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar', 'baz' ])\n})\n\ntest('with strings', () => {\n  expect(takeLast(3, 'rambda')).toEqual('bda')\n\n  expect(takeLast(7, 'rambda')).toEqual('rambda')\n})\n\ntest('with negative index', () => {\n  expect(takeLast(-1, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(takeLast(-Infinity, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n})",
    "explanation": "It returns the last `howMany` elements of `input`.",
    "example": "const howMany = 2\n\nconst result = [\n  R.takeLast(howMany, [1, 2, 3]),\n  R.takeLast(howMany, 'foobar'),\n]\n// => [[2, 3], 'ar']",
    "typescriptDefinitionTest": "import {takeLast} from 'rambda'\n\nconst list = [1, 2, 3, 4]\nconst str = 'foobar'\nconst howMany = 2\n\ndescribe('R.takeLast - array', () => {\n  it('happy', () => {\n    const result = takeLast(howMany, list)\n\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = takeLast(howMany)(list)\n\n    result // $ExpectType number[]\n  })\n})\n\ndescribe('R.takeLast - string', () => {\n  it('happy', () => {\n    const result = takeLast(howMany, str)\n\n    result // $ExpectType string\n  })\n  it('curried', () => {\n    const result = takeLast(howMany)(str)\n\n    result // $ExpectType string\n  })\n})"
  },
  "tap": {
    "typing": "\ntap<T>(fn: (x: T) => void, input: T): T",
    "allTypings": "tap<T>(fn: (x: T) => void, input: T): T;\ntap<T>(fn: (x: T) => void): (input: T) => T;",
    "categories": [
      "Function"
    ],
    "rambdaSource": "export function tap(fn, x){\n  if (arguments.length === 1) return _x => tap(fn, _x)\n\n  fn(x)\n\n  return x\n}",
    "rambdaSpecs": "import { tap } from './tap'\n\ntest('tap', () => {\n  let a = 1\n  const sayX = x => a = x\n\n  expect(tap(sayX, 100)).toEqual(100)\n  expect(tap(sayX)(100)).toEqual(100)\n  expect(a).toEqual(100)\n})",
    "explanation": "It applies function `fn` to input `x` and returns `x`. \n\nOne use case is debuging in the middle of `R.compose`.",
    "example": "const list = [1, 2, 3]\n\nR.compose(\n  R.map(x => x * 2)\n  R.tap(console.log),\n  R.filter(x => x > 1)\n)(list)\n// => `2` and `3` will be logged",
    "typescriptDefinitionTest": "import {tap, pipe} from 'rambda'\n\ndescribe('R.tap', () => {\n  it('happy', () => {\n    pipe(\n      tap(x => {\n        x // $ExpectType number[]\n      }),\n      (x: number[]) => x.length\n    )([1, 2])\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar listXf = require('./helpers/listXf');\nvar _curry2 = require('rambda/internal/_curry2');\n\ndescribe('tap', function() {\n  var pushToList = _curry2(function(lst, x) { lst.push(x); });\n  it('can act as a transducer', function() {\n    var sideEffect = [];\n    var numbers = [1,2,3,4,5];\n    var xf = R.compose(R.map(R.identity), R.tap(pushToList(sideEffect)));\n    eq(R.into([], xf, numbers), numbers);\n    eq(sideEffect, numbers);\n  });\n  it('dispatches to transformer objects', function() {\n    var sideEffect = [];\n    var pushToSideEffect = pushToList(sideEffect);\n    eq(R.tap(pushToSideEffect, listXf), {\n      f: pushToSideEffect,\n      xf: listXf\n    });\n  });\n});",
    "failedSpecsReasons": "Ramda method can act as a transducer",
    "failedSpecsCount": 2
  },
  "test": {
    "typing": "\ntest(regExpression: RegExp): (str: string) => boolean",
    "allTypings": "test(regExpression: RegExp): (str: string) => boolean;\ntest(regExpression: RegExp, str: string): boolean;",
    "categories": [
      "String"
    ],
    "rambdaSource": "export function test(pattern, str){\n  if (arguments.length === 1) return _str => test(pattern, _str)\n\n  if (typeof pattern === 'string'){\n    throw new TypeError(`test requires a value of type RegExp as its first argument; received \"${ pattern }\"`)\n  }\n\n  return str.search(pattern) !== -1\n}",
    "rambdaSpecs": "import { test as testMethod } from './test'\n\ntest('happy', () => {\n  expect(testMethod(/^x/, 'xyz')).toBeTrue()\n\n  expect(testMethod(/^y/)('xyz')).toBeFalse()\n})\n\ntest('throws if first argument is not regex', () => {\n  expect(() => testMethod('foo', 'bar')).toThrowWithMessage(TypeError,\n    'test requires a value of type RegExp as its first argument; received \"foo\"')\n})",
    "explanation": "It determines whether `str` matches `regExpression`.",
    "example": "R.test(/^f/, 'foo')\n// => true",
    "typescriptDefinitionTest": "import {test} from 'rambda'\n\nconst input = 'foo   '\nconst regex = /foo/\n\ndescribe('R.test', () => {\n  it('happy', () => {\n    const result = test(regex, input)\n\n    result // $ExpectType boolean\n  })\n  it('curried', () => {\n    const result = test(regex)(input)\n\n    result // $ExpectType boolean\n  })\n})"
  },
  "times": {
    "typing": "\ntimes<T>(fn: (i: number) => T, howMany: number): T[]",
    "allTypings": "times<T>(fn: (i: number) => T, howMany: number): T[];\ntimes<T>(fn: (i: number) => T): (howMany: number) => T[];",
    "rambdaSource": "import { map } from './map'\nimport { range } from './range'\n\nexport function times(fn, howMany){\n  if (arguments.length === 1) return _howMany => times(fn, _howMany)\n  if (!Number.isInteger(howMany) || howMany < 0){\n    throw new RangeError('n must be an integer')\n  }\n\n  return map(fn, range(0, howMany))\n}",
    "rambdaSpecs": "import assert from 'assert'\n\nimport { identity } from './identity'\nimport { times } from './times'\n\ntest('happy', () => {\n  const result = times(identity, 5)\n\n  expect(result).toEqual([ 0, 1, 2, 3, 4 ])\n})\n\ntest('with bad input', () => {\n  assert.throws(() => {\n    times(3)('cheers!')\n  }, RangeError)\n  assert.throws(() => {\n    times(identity, -1)\n  }, RangeError)\n})\n\ntest('curry', () => {\n  const result = times(identity)(5)\n\n  expect(result).toEqual([ 0, 1, 2, 3, 4 ])\n})",
    "explanation": "It returns the result of applying function `fn` over members of range array.\n\nThe range array includes numbers between `0` and `howMany`(exclusive).",
    "example": "const fn = x => x * 2\nconst howMany = 5\n\nR.times(fn, howMany)\n//=> [0, 2, 4, 6, 8]",
    "typescriptDefinitionTest": "import {times, identity} from 'rambda'\n\ndescribe('R.times', () => {\n  it('happy', () => {\n    const result = times(identity, 5)\n    result // $ExpectType number[]\n  })\n})"
  },
  "toLower": {
    "typing": "\ntoLower(str: string): string",
    "allTypings": "toLower(str: string): string;",
    "categories": [
      "String"
    ],
    "rambdaSource": "export function toLower(str){\n  return str.toLowerCase()\n}",
    "rambdaSpecs": "import { toLower } from './toLower'\n\ntest('toLower', () => {\n  expect(toLower('FOO|BAR|BAZ')).toEqual('foo|bar|baz')\n})",
    "example": "R.toLower('FOO')\n// => 'foo'"
  },
  "toUpper": {
    "typing": "\ntoUpper(str: string): string",
    "allTypings": "toUpper(str: string): string;",
    "categories": [
      "String"
    ],
    "rambdaSource": "export function toUpper(str){\n  return str.toUpperCase()\n}",
    "rambdaSpecs": "import { toUpper } from './toUpper'\n\ntest('toUpper', () => {\n  expect(toUpper('foo|bar|baz')).toEqual('FOO|BAR|BAZ')\n})",
    "example": "R.toUpper('foo')\n// => 'FOO'"
  },
  "toPairs": {
    "typing": "\ntoPairs<S>(obj: { [k: string]: S } | { [k: number]: S }): [string, S][]",
    "allTypings": "toPairs<S>(obj: { [k: string]: S } | { [k: number]: S }): [string, S][];",
    "categories": [
      "Object"
    ],
    "rambdaSource": "export function toPairs(obj){\n  return Object.entries(obj)\n}",
    "rambdaSpecs": "import { toPairs } from './toPairs'\n\nconst obj = {\n  a : 1,\n  b : 2,\n  c : [ 3, 4 ],\n}\nconst expected = [\n  [ 'a', 1 ],\n  [ 'b', 2 ],\n  [ 'c', [ 3, 4 ] ],\n]\n\ntest('happy', () => {\n  expect(toPairs(obj)).toEqual(expected)\n})",
    "explanation": "It transforms an object to a list.",
    "example": "const list = {\n  a : 1,\n  b : 2,\n  c : [ 3, 4 ],\n}\nconst expected = [ [ 'a', 1 ], [ 'b', 2 ], [ 'c', [ 3, 4 ] ] ]\n\nconst result = R.toPairs(list)\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {toPairs} from 'rambda'\n\nconst obj = {\n  a: 1,\n  b: 2,\n  c: [3, 4],\n}\n\ndescribe('R.toPairs', () => {\n  it('happy', () => {\n    const result = toPairs(obj)\n\n    result // $ExpectType [string, number | number[]][]\n  })\n})"
  },
  "toString": {
    "typing": "\ntoString<T>(x: T): string",
    "allTypings": "toString<T>(x: T): string;",
    "categories": [
      "String"
    ],
    "rambdaSource": "export function toString(x){\n  return x.toString()\n}",
    "rambdaSpecs": "import { toString } from './toString'\n\ntest('happy', () => {\n  expect(toString([ 1, 2, 3 ])).toEqual('1,2,3')\n})",
    "example": "R.toString([1, 2]) \n// => '1,2'",
    "failedRamdaSpecs": "var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\ndescribe('toString', function() {\n  it('returns the string representation of null', function() {\n    assert.strictEqual(R.toString(null), 'null');\n  });\n  it('returns the string representation of undefined', function() {\n    assert.strictEqual(R.toString(undefined), 'undefined');\n  });\n  it('returns the string representation of a number primitive', function() {\n    assert.strictEqual(R.toString(0), '0');\n    assert.strictEqual(R.toString(-0), '-0');\n    assert.strictEqual(R.toString(1.23), '1.23');\n    assert.strictEqual(R.toString(-1.23), '-1.23');\n    assert.strictEqual(R.toString(1e+23), '1e+23');\n    assert.strictEqual(R.toString(-1e+23), '-1e+23');\n    assert.strictEqual(R.toString(1e-23), '1e-23');\n    assert.strictEqual(R.toString(-1e-23), '-1e-23');\n    assert.strictEqual(R.toString(Infinity), 'Infinity');\n    assert.strictEqual(R.toString(-Infinity), '-Infinity');\n    assert.strictEqual(R.toString(NaN), 'NaN');\n  });\n  it('returns the string representation of a string primitive', function() {\n    assert.strictEqual(R.toString('abc'), '\"abc\"');\n    assert.strictEqual(R.toString('x \"y\" z'), '\"x \\\\\"y\\\\\" z\"');\n    assert.strictEqual(R.toString(\"' '\"), '\"\\' \\'\"');\n    assert.strictEqual(R.toString('\" \"'), '\"\\\\\" \\\\\"\"');\n    assert.strictEqual(R.toString('\\b \\b'), '\"\\\\b \\\\b\"');\n    assert.strictEqual(R.toString('\\f \\f'), '\"\\\\f \\\\f\"');\n    assert.strictEqual(R.toString('\\n \\n'), '\"\\\\n \\\\n\"');\n    assert.strictEqual(R.toString('\\r \\r'), '\"\\\\r \\\\r\"');\n    assert.strictEqual(R.toString('\\t \\t'), '\"\\\\t \\\\t\"');\n    assert.strictEqual(R.toString('\\v \\v'), '\"\\\\v \\\\v\"');\n    assert.strictEqual(R.toString('\\0 \\0'), '\"\\\\0 \\\\0\"');\n    assert.strictEqual(R.toString('\\\\ \\\\'), '\"\\\\\\\\ \\\\\\\\\"');\n  });\n  it('returns the string representation of a Boolean object', function() {\n    assert.strictEqual(R.toString(new Boolean(true)), 'new Boolean(true)');\n    assert.strictEqual(R.toString(new Boolean(false)), 'new Boolean(false)');\n  });\n  it('returns the string representation of a Number object', function() {\n    assert.strictEqual(R.toString(new Number(0)), 'new Number(0)');\n    assert.strictEqual(R.toString(new Number(-0)), 'new Number(-0)');\n  });\n  it('returns the string representation of a String object', function() {\n    assert.strictEqual(R.toString(new String('abc')), 'new String(\"abc\")');\n    assert.strictEqual(R.toString(new String('x \"y\" z')), 'new String(\"x \\\\\"y\\\\\" z\")');\n    assert.strictEqual(R.toString(new String(\"' '\")), 'new String(\"\\' \\'\")');\n    assert.strictEqual(R.toString(new String('\" \"')), 'new String(\"\\\\\" \\\\\"\")');\n    assert.strictEqual(R.toString(new String('\\b \\b')), 'new String(\"\\\\b \\\\b\")');\n    assert.strictEqual(R.toString(new String('\\f \\f')), 'new String(\"\\\\f \\\\f\")');\n    assert.strictEqual(R.toString(new String('\\n \\n')), 'new String(\"\\\\n \\\\n\")');\n    assert.strictEqual(R.toString(new String('\\r \\r')), 'new String(\"\\\\r \\\\r\")');\n    assert.strictEqual(R.toString(new String('\\t \\t')), 'new String(\"\\\\t \\\\t\")');\n    assert.strictEqual(R.toString(new String('\\v \\v')), 'new String(\"\\\\v \\\\v\")');\n    assert.strictEqual(R.toString(new String('\\0 \\0')), 'new String(\"\\\\0 \\\\0\")');\n    assert.strictEqual(R.toString(new String('\\\\ \\\\')), 'new String(\"\\\\\\\\ \\\\\\\\\")');\n  });\n  it('returns the string representation of a Date object', function() {\n    assert.strictEqual(R.toString(new Date('2001-02-03T04:05:06.000Z')), 'new Date(\"2001-02-03T04:05:06.000Z\")');\n    assert.strictEqual(R.toString(new Date('XXX')), 'new Date(NaN)');\n  });\n  it('returns the string representation of an array', function() {\n    assert.strictEqual(R.toString([]), '[]');\n    assert.strictEqual(R.toString([1, 2, 3]), '[1, 2, 3]');\n    assert.strictEqual(R.toString([1, [2, [3]]]), '[1, [2, [3]]]');\n    assert.strictEqual(R.toString(['x', 'y']), '[\"x\", \"y\"]');\n  });\n  it('returns the string representation of an array with non-numeric property names', function() {\n    var xs = [1, 2, 3];\n    xs.foo = 0;\n    xs.bar = 0;\n    xs.baz = 0;\n    assert.strictEqual(R.toString(xs), '[1, 2, 3, \"bar\": 0, \"baz\": 0, \"foo\": 0]');\n  });\n  it('returns the string representation of an arguments object', function() {\n    assert.strictEqual(R.toString((function() { return arguments; })()), '(function() { return arguments; }())');\n    assert.strictEqual(R.toString((function() { return arguments; })(1, 2, 3)), '(function() { return arguments; }(1, 2, 3))');\n    assert.strictEqual(R.toString((function() { return arguments; })(['x', 'y'])), '(function() { return arguments; }([\"x\", \"y\"]))');\n  });\n  it('returns the string representation of a plain object', function() {\n    assert.strictEqual(R.toString({}), '{}');\n    assert.strictEqual(R.toString({foo: 1, bar: 2, baz: 3}), '{\"bar\": 2, \"baz\": 3, \"foo\": 1}');\n    assert.strictEqual(R.toString({'\"quoted\"': true}), '{\"\\\\\"quoted\\\\\"\": true}');\n    assert.strictEqual(R.toString({a: {b: {c: {}}}}), '{\"a\": {\"b\": {\"c\": {}}}}');\n  });\n  it('treats instance without custom `toString` method as plain object', function() {\n    function Point(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    assert.strictEqual(R.toString(new Point(1, 2)), '{\"x\": 1, \"y\": 2}');\n  });\n  it('dispatches to custom `toString` method', function() {\n    function Point(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    Point.prototype.toString = function() {\n      return 'new Point(' + this.x + ', ' + this.y + ')';\n    };\n    assert.strictEqual(R.toString(new Point(1, 2)), 'new Point(1, 2)');\n    function Just(x) {\n      if (!(this instanceof Just)) {\n        return new Just(x);\n      }\n      this.value = x;\n    }\n    Just.prototype.toString = function() {\n      return 'Just(' + R.toString(this.value) + ')';\n    };\n    assert.strictEqual(R.toString(Just(42)), 'Just(42)');\n    assert.strictEqual(R.toString(Just([1, 2, 3])), 'Just([1, 2, 3])');\n    assert.strictEqual(R.toString(Just(Just(Just('')))), 'Just(Just(Just(\"\")))');\n    assert.strictEqual(R.toString({toString: R.always('x')}), 'x');\n  });\n  it('handles object with no `toString` method', function() {\n    if (typeof Object.create === 'function') {\n      var a = Object.create(null);\n      var b = Object.create(null); b.x = 1; b.y = 2;\n      assert.strictEqual(R.toString(a), '{}');\n      assert.strictEqual(R.toString(b), '{\"x\": 1, \"y\": 2}');\n    }\n  });\n  it('handles circular references', function() {\n    var a = [];\n    a[0] = a;\n    assert.strictEqual(R.toString(a), '[<Circular>]');\n    var o = {};\n    o.o = o;\n    assert.strictEqual(R.toString(o), '{\"o\": <Circular>}');\n    var b = ['bee'];\n    var c = ['see'];\n    b[1] = c;\n    c[1] = b;\n    assert.strictEqual(R.toString(b), '[\"bee\", [\"see\", <Circular>]]');\n    assert.strictEqual(R.toString(c), '[\"see\", [\"bee\", <Circular>]]');\n    var p = {};\n    var q = {};\n    p.q = q;\n    q.p = p;\n    assert.strictEqual(R.toString(p), '{\"q\": {\"p\": <Circular>}}');\n    assert.strictEqual(R.toString(q), '{\"p\": {\"q\": <Circular>}}');\n    var x = [];\n    var y = {};\n    x[0] = y;\n    y.x = x;\n    assert.strictEqual(R.toString(x), '[{\"x\": <Circular>}]');\n    assert.strictEqual(R.toString(y), '{\"x\": [<Circular>]}');\n  });\n});"
  },
  "transpose": {
    "typing": "\ntranspose<T>(list: readonly T[][]): T[][]",
    "allTypings": "transpose<T>(list: readonly T[][]): T[][];",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nexport function transpose(array){\n  return array.reduce((acc, el) => {\n    el.forEach((nestedEl, i) =>\n      _isArray(acc[ i ]) ? acc[ i ].push(nestedEl) : acc.push([ nestedEl ]))\n\n    return acc\n  }, [])\n}",
    "rambdaSpecs": "import { transpose } from './transpose'\n\ntest('happy', () => {\n  const input = [\n    [ 'a', 1 ],\n    [ 'b', 2 ],\n    [ 'c', 3 ],\n  ]\n\n  expect(transpose(input)).toEqual([\n    [ 'a', 'b', 'c' ],\n    [ 1, 2, 3 ],\n  ])\n})\n\ntest('when rows are shorter', () => {\n  const actual = transpose([ [ 10, 11 ], [ 20 ], [], [ 30, 31, 32 ] ])\n  const expected = [ [ 10, 20, 30 ], [ 11, 31 ], [ 32 ] ]\n  expect(actual).toEqual(expected)\n})\n\ntest('with empty array', () => {\n  expect(transpose([])).toEqual([])\n})\n\ntest('array with falsy values', () => {\n  const actual = transpose([\n    [ true, false, undefined, null ],\n    [ null, undefined, false, true ],\n  ])\n  const expected = [\n    [ true, null ],\n    [ false, undefined ],\n    [ undefined, false ],\n    [ null, true ],\n  ]\n  expect(actual).toEqual(expected)\n})",
    "example": "const list = [[10, 11], [20], [], [30, 31, 32]]\nconst expected = [[10, 20, 30], [11, 31], [32]]\n\nconst result = R.transpose(list)\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {transpose} from 'rambda'\n\nconst input = [\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]\n\ndescribe('R.transpose', () => {\n  it('happy', () => {\n    const result = transpose(input)\n\n    result // $ExpectType (string | number)[][]\n  })\n})"
  },
  "trim": {
    "typing": "\ntrim(str: string): string",
    "allTypings": "trim(str: string): string;",
    "categories": [
      "String"
    ],
    "rambdaSource": "export function trim(str){\n  return str.trim()\n}",
    "rambdaSpecs": "import { trim } from './trim'\n\ntest('trim', () => {\n  expect(trim(' foo ')).toEqual('foo')\n})",
    "example": "R.trim('  foo  ') \n// => 'foo'",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('trim', function() {\n  var test = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFFHello, World!\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n  it('trims all ES5 whitespace', function() {\n    eq(R.trim(test), 'Hello, World!');\n    eq(R.trim(test).length, 13);\n  });\n  if (typeof String.prototype.trim !== 'function') {\n    it('falls back to a shim if String.prototype.trim is not present', function() {\n      eq(R.trim('   xyz  '), 'xyz');\n      eq(R.trim(test), 'Hello, World!');\n      eq(R.trim(test).length, 13);\n      eq(R.trim('\\u200b'), '\\u200b');\n      eq(R.trim('\\u200b').length, 1);\n    });\n  }\n});",
    "failedSpecsReasons": "Ramda method trims all ES5 whitespace",
    "failedSpecsCount": 1
  },
  "tryCatch": {
    "typing": "\ntryCatch<T, U>(\n  fn: (input: T) => U,\n  fallback: U\n): (input: T) => U",
    "allTypings": "tryCatch<T, U>(\n  fn: (input: T) => U,\n  fallback: U\n): (input: T) => U;\ntryCatch<T, U>(\n  fn: (input: T) => U,\n  fallback: (input: T) => U\n): (input: T) => U;\ntryCatch<T>(\n  fn: (input: any) => Promise<any>,\n  fallback: T\n): (input: any) => Promise<T>;\ntryCatch<T>(\n  fn: (input: any) => Promise<any>,\n  fallback: (input: any) => Promise<any>,\n): (input: any) => Promise<T>;",
    "categories": [
      "Async",
      "Function"
    ],
    "notes": "Please check the tests of `R.tryCatch` to fully understand how this method works.",
    "rambdaSource": "import { isFunction } from './isFunction'\n\nexport function tryCatch(fn, fallback){\n  if (!isFunction(fn)){\n    throw new Error(`R.tryCatch | fn '${ fn }'`)\n  }\n  const passFallback = isFunction(fallback)\n\n    return (...inputs) => {\n      try {\n        return fn(...inputs)\n      } catch (e){\n        return passFallback ? fallback(e, ...inputs) : fallback\n      }\n    }\n}",
    "rambdaSpecs": "import { tryCatch as tryCatchRamda } from 'ramda'\n\nimport { compareCombinations } from './_internals/testUtils'\nimport { prop } from './prop'\nimport { tryCatch } from './tryCatch'\n\ntest('happy', () => {\n  const fn = () => {\n    throw new Error('foo')\n  }\n  const result = tryCatch(fn, () => true)()\n  expect(result).toBeTrue()\n})\n\ntest('when fallback is used', () => {\n  const fn = x => x.x\n\n  expect(tryCatch(fn, false)(null)).toBeFalse()\n})\n\ntest('with json parse', () => {\n  const good = () => JSON.parse(JSON.stringify({ a : 1 }))\n  const bad = () => JSON.parse('a{a')\n\n  expect(tryCatch(good, 1)()).toEqual({ a : 1 })\n  expect(tryCatch(bad, 1)()).toBe(1)\n})\n\ntest('when fallback is function', () => {\n  const fn = x => x.x\n\n  expect(tryCatch(fn, () => 1)(null)).toBe(1)\n})\n\ntest('when fn is used', () => {\n  const fn = prop('x')\n\n  expect(tryCatch(fn, false)({})).toBe(undefined)\n  expect(tryCatch(fn, false)({ x : 1 })).toBe(1)\n})\n\ntest('fallback receives error object and all initial inputs', () => {\n  function thrower(\n    a, b, c\n  ){\n    void c\n    throw new Error('throwerError')\n  }\n\n  function catchFn(\n    e, a, b, c\n  ){\n    return [ e.message, a, b, c ].join('|')\n  }\n\n  const willThrow = tryCatch(thrower, catchFn)\n  const result = willThrow(\n    'A', 'B', 'C'\n  )\n  expect(result).toBe('throwerError|A|B|C')\n})\n\ntest('fallback receives error object', () => {\n  function throwFn(){\n    throw new Error(10)\n  }\n\n  function eCatcher(\n    e, a, b\n  ){\n    return e.message\n  }\n\n  const willThrow = tryCatch(throwFn, eCatcher)\n  expect(willThrow([])).toBe('10')\n  expect(willThrow([ {}, {}, {} ])).toBe('10')\n})\n\nconst possibleFns = [\n  null,\n  () => 1,\n  () => 0,\n  () => JSON.parse('{a:1'),\n  () => {\n    const x = {}\n\n    return x.x\n  },\n  x => x.foo,\n  () => {\n    throw new Error('foo')\n  },\n]\n\nconst possibleCatchers = [\n  null,\n  e => e.message.length,\n  (e, ...inputs) => `${ e.message.length } ${ inputs.length }`,\n  () => {\n    throw new Error('bar')\n  },\n]\n\nconst possibleInputs = [ null, {}, { foo : 1 } ]\n\ndescribe('brute force', () => {\n  compareCombinations({\n    returnsFunctionFlag : true,\n    firstInput          : possibleFns,\n    callback            : errorsCounters => {\n      expect(errorsCounters).toMatchInlineSnapshot(`\n        Object {\n          \"ERRORS_MESSAGE_MISMATCH\": 0,\n          \"ERRORS_TYPE_MISMATCH\": 12,\n          \"RESULTS_MISMATCH\": 0,\n          \"SHOULD_NOT_THROW\": 0,\n          \"SHOULD_THROW\": 7,\n        }\n      `)\n    },\n    secondInput : possibleCatchers,\n    thirdInput  : possibleInputs,\n    fn          : tryCatch,\n    fnRamda     : tryCatchRamda,\n  })\n})",
    "explanation": "It returns function that runs `fn` in `try/catch` block. If there was an error, then `fallback` is used to return the result. Note that `fn` can be value or asynchronous/synchronous function(unlike `Ramda` where fallback can only be a synchronous function).",
    "example": "const fn = x => x.foo\n\nconst result = [\n  R.tryCatch(fn, false)(null),\n  R.tryCatch(fn, false)({foo: 'bar'})\n]\n// => [false, 'bar']",
    "typescriptDefinitionTest": "import {tryCatch, delay} from 'rambda'\n\ndescribe('R.tryCatch', () => {\n  it('synchronous', () => {\n    const fn = (x: any) => x.x === 1\n\n    const result = tryCatch(fn, false)(null)\n    result // $ExpectType boolean\n  })\n  it('synchronous + fallback is function', () => {\n    const fn = (x: any) => typeof x.x\n    const fallback = (x: any) => typeof x\n    const result = tryCatch<any, string>(fn, fallback)(null)\n    result // $ExpectType string\n  })\n\n  it('asynchronous', async() => {\n    const fn = async(input: any) => {\n      return typeof JSON.parse('{a:')\n    }\n    const result = await tryCatch<string>(fn, 'fallback')(100)\n    result // $ExpectType string\n  })\n\n  it('asynchronous + fallback is asynchronous', async() => {\n    const fn = async(input: any) => {\n      await delay(100)\n      return JSON.parse(`{a:${input}`)\n    }\n    const fallback = async(input: any) => {\n      await delay(100)\n      return 'foo'\n    }\n    const result = await tryCatch<string>(fn, fallback)(100)\n    result // $ExpectType string\n  })\n})",
    "failedSpecsReasons": "Ramda method returns a function with the same arity",
    "failedSpecsCount": 1
  },
  "type": {
    "typing": "\ntype(x: any): RambdaTypes",
    "allTypings": "type(x: any): RambdaTypes;",
    "categories": [
      "Logic"
    ],
    "notes": "`NaN`, `Promise` and `Async` are types specific for **Rambda**.",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nexport function type(input){\n  const typeOf = typeof input\n\n  if (input === null){\n    return 'Null'\n  } else if (input === undefined){\n    return 'Undefined'\n  } else if (typeOf === 'boolean'){\n    return 'Boolean'\n  } else if (typeOf === 'number'){\n    return Number.isNaN(input) ? 'NaN' : 'Number'\n  } else if (typeOf === 'string'){\n    return 'String'\n  } else if (_isArray(input)){\n    return 'Array'\n  } else if (typeOf === 'symbol'){\n    return 'Symbol'\n  } else if (input instanceof RegExp){\n    return 'RegExp'\n  }\n\n  const asStr = input && input.toString ? input.toString() : ''\n\n  if ([ 'true', 'false' ].includes(asStr)) return 'Boolean'\n  if (!Number.isNaN(Number(asStr))) return 'Number'\n  if (asStr.startsWith('async')) return 'Async'\n  if (asStr === '[object Promise]') return 'Promise'\n  if (typeOf === 'function') return 'Function'\n  if (input instanceof String) return 'String'\n\n  return 'Object'\n}",
    "rambdaSpecs": "import { type as ramdaType } from 'ramda'\n\nimport { type } from './type'\n\ntest('with symbol', () => {\n  expect(type(Symbol())).toBe('Symbol')\n})\n\ntest('with simple promise', () => {\n  expect(type(Promise.resolve(1))).toBe('Promise')\n})\n\ntest('with new Boolean', () => {\n  expect(type(new Boolean(true))).toBe('Boolean')\n})\n\ntest('with new String', () => {\n  expect(type(new String('I am a String object'))).toEqual('String')\n})\n\ntest('with new Number', () => {\n  expect(type(new Number(1))).toBe('Number')\n})\n\ntest('with new promise', () => {\n  const delay = ms =>\n    new Promise(resolve => {\n      setTimeout(() => {\n        resolve(ms + 110)\n      }, ms)\n    })\n\n  expect(type(delay(10))).toEqual('Promise')\n})\n\ntest('async function', () => {\n  expect(type(async () => {})).toEqual('Async')\n})\n\ntest('async arrow', () => {\n  const asyncArrow = async () => {}\n  expect(type(asyncArrow)).toBe('Async')\n})\n\ntest('function', () => {\n  const fn1 = () => {}\n  const fn2 = function (){}\n\n  function fn3(){}\n\n  ;[ () => {}, fn1, fn2, fn3 ].map(val => {\n    expect(type(val)).toEqual('Function')\n  })\n})\n\ntest('object', () => {\n  expect(type({})).toEqual('Object')\n})\n\ntest('number', () => {\n  expect(type(1)).toEqual('Number')\n})\n\ntest('boolean', () => {\n  expect(type(false)).toEqual('Boolean')\n})\n\ntest('string', () => {\n  expect(type('foo')).toEqual('String')\n})\n\ntest('null', () => {\n  expect(type(null)).toEqual('Null')\n})\n\ntest('array', () => {\n  expect(type([])).toEqual('Array')\n  expect(type([ 1, 2, 3 ])).toEqual('Array')\n})\n\ntest('regex', () => {\n  expect(type(/\\s/g)).toEqual('RegExp')\n})\n\ntest('undefined', () => {\n  expect(type(undefined)).toEqual('Undefined')\n})\n\ntest('not a number', () => {\n  expect(type(Number('s'))).toBe('NaN')\n})\n\ntest('function inside object 1', () => {\n  const obj = {\n    f(){\n      return 4\n    },\n  }\n\n  expect(type(obj.f)).toBe('Function')\n  expect(ramdaType(obj.f)).toBe('Function')\n})\n\ntest('function inside object 2', () => {\n  const name = 'f'\n  const obj = {\n    [ name ](){\n      return 4\n    },\n  }\n  expect(type(obj.f)).toBe('Function')\n  expect(ramdaType(obj.f)).toBe('Function')\n})",
    "explanation": "It accepts any input and it returns its type.",
    "example": "R.type(() => {}) // => 'Function'\nR.type(async () => {}) // => 'Async'\nR.type([]) // => 'Array'\nR.type({}) // => 'Object'\nR.type('foo') // => 'String'\nR.type(1) // => 'Number'\nR.type(true) // => 'Boolean'\nR.type(null) // => 'Null'\nR.type(/[A-z]/) // => 'RegExp'\nR.type('foo'*1) // => 'NaN'\n\nconst delay = ms => new Promise(resolve => {\n  setTimeout(function () {\n    resolve()\n  }, ms)\n})\nR.type(delay) // => 'Promise'",
    "typescriptDefinitionTest": "import {type} from 'rambda'\n\ndescribe('R.type', () => {\n  it('happy', () => {\n    const result = type(4)\n\n    result // $ExpectType RambdaTypes\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('type', function() {\n  // it('\"Arguments\" if given an arguments object', function() {\n  //   var args = (function() { return arguments; }());\n  //   eq(R.type(args), 'Arguments');\n  // });\n  it('\"Number\" if given the NaN value', function() {\n    eq(R.type(NaN), 'Number');\n  });\n});",
    "failedSpecsReasons": "Ramda method returns 'Number' type to NaN input, while Rambda method returns 'NaN'",
    "failedSpecsCount": 1
  },
  "union": {
    "typing": "\nunion<T>(x: readonly T[], y: readonly T[]): T[]",
    "allTypings": "union<T>(x: readonly T[], y: readonly T[]): T[];\nunion<T>(x: readonly T[]): (y: readonly T[]) => T[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { includes } from './includes'\n\nexport function union(x, y){\n  if (arguments.length === 1) return _y => union(x, _y)\n\n  const toReturn = x.slice()\n\n  y.forEach(yInstance => {\n    if (!includes(yInstance, x)) toReturn.push(yInstance)\n  })\n\n  return toReturn\n}",
    "rambdaSpecs": "import { union } from './union'\n\ntest('happy', () => {\n  expect(union([ 1, 2 ], [ 2, 3 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('with list of objects', () => {\n  const list1 = [ { a : 1 }, { a : 2 } ]\n  const list2 = [ { a : 2 }, { a : 3 } ]\n  const result = union(list1)(list2)\n})",
    "explanation": "It takes two lists and return a new list containing a merger of both list with removed duplicates. \n\n`R.equals` is used to compare for duplication, which means that it can be safely used with array of objects.",
    "example": "const result = R.union([1,2,3], [3,4,5]);\n//=> [1, 2, 3, 4, 5]",
    "typescriptDefinitionTest": "import {union} from 'rambda'\n\ndescribe('R.union', () => {\n  it('happy', () => {\n    const result = union([1, 2], [2, 3])\n\n    result // $ExpectType number[]\n  })\n  it('with array of objects - case 1', () => {\n    const list1 = [{a: 1}, {a: 2}]\n    const list2 = [{a: 2}, {a: 3}]\n    const result = union(list1, list2)\n    result // $ExpectType { a: number; }[]\n  })\n  it('with array of objects - case 2', () => {\n    const list1 = [{a: 1, b: 1}, {a: 2}]\n    const list2 = [{a: 2}, {a: 3, b: 3}]\n    const result = union(list1, list2)\n    result[0].a // $ExpectType number\n    result[0].b // $ExpectType number | undefined\n  })\n})\n\ndescribe('R.union - curried', () => {\n  it('happy', () => {\n    const result = union([1, 2])([2, 3])\n\n    result // $ExpectType number[]\n  })\n  it('with array of objects - case 1', () => {\n    const list1 = [{a: 1}, {a: 2}]\n    const list2 = [{a: 2}, {a: 3}]\n    const result = union(list1)(list2)\n    result // $ExpectType { a: number; }[]\n  })\n  it('with array of objects - case 2', () => {\n    const list1 = [{a: 1, b: 1}, {a: 2}]\n    const list2 = [{a: 2}, {a: 3, b: 3}]\n    const result = union(list1)(list2)\n    result[0].a // $ExpectType number\n    result[0].b // $ExpectType number | undefined\n  })\n})",
    "failedSpecsReasons": "Ramda library supports fantasy-land",
    "failedSpecsCount": 1
  },
  "uniq": {
    "typing": "\nuniq<T>(list: readonly T[]): T[]",
    "allTypings": "uniq<T>(list: readonly T[]): T[];",
    "categories": [
      "List"
    ],
    "notes": "`R.equals` is used to determine equality",
    "rambdaSource": "import { includes } from './includes'\n\nexport function uniq(list){\n  let index = -1\n  const willReturn = []\n\n  while (++index < list.length){\n    const value = list[ index ]\n\n    if (!includes(value, willReturn)){\n      willReturn.push(value)\n    }\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { uniq } from './uniq'\n\ntest('uniq', () => {\n  expect(uniq([ 1, 2, 3, 3, 3, 1, 2, 0 ])).toEqual([ 1, 2, 3, 0 ])\n  expect(uniq([ 1, 1, 2, 1 ])).toEqual([ 1, 2 ])\n  expect([ 1, '1' ]).toEqual([ 1, '1' ])\n  expect(uniq([ [ 42 ], [ 42 ] ])).toEqual([ [ 42 ] ])\n})",
    "explanation": "It returns a new array containing only one copy of each element of `list`.",
    "example": "const list = [1, 1, {a: 1}, {a: 2}, {a:1}]\n\nR.uniq(list)\n// => [1, {a: 1}, {a: 2}]",
    "typescriptDefinitionTest": "import {uniq} from 'rambda'\n\ndescribe('R.uniq', () => {\n  it('happy', () => {\n    const result = uniq([1, 2, 3, 3, 3, 1, 2, 0])\n    result // $ExpectType number[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('uniq', function() {\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.uniq([-0, -0]).length, 1);\n    eq(R.uniq([0, -0]).length, 2);\n    eq(R.uniq([NaN, NaN]).length, 1);\n    eq(R.uniq([[1], [1]]).length, 1);\n    eq(R.uniq([new Just([42]), new Just([42])]).length, 1);\n  it('handles null and undefined elements', function() {\n    eq(R.uniq([void 0, null, void 0, null]), [void 0, null]);\n  it('uses reference equality for functions', function() {\n    eq(R.uniq([R.add, R.identity, R.add, R.identity, R.add, R.identity]).length, 2);\n});",
    "failedSpecsReasons": "Ramda method pass to `uniq` method | Ramda method uses reference equality for functions",
    "failedSpecsCount": 2
  },
  "uniqWith": {
    "typing": "\nuniqWith<T, U>(uniqFn: (x: T, y: T) => boolean, list: readonly T[]): T[]",
    "allTypings": "uniqWith<T, U>(uniqFn: (x: T, y: T) => boolean, list: readonly T[]): T[];\nuniqWith<T, U>(uniqFn: (x: T, y: T) => boolean): (list: readonly T[]) => T[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { any } from './any'\n\nexport function uniqWith(fn, list){\n  if (arguments.length === 1) return _list => uniqWith(fn, _list)\n\n  let index = -1\n  const len = list.length\n  const willReturn = []\n\n  while (++index < len){\n    const value = list[ index ]\n    const flag = any(willReturnInstance => fn(value, willReturnInstance),\n      willReturn)\n\n    if (!flag){\n      willReturn.push(value)\n    }\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { uniqWith } from './uniqWith'\n\ntest('happy', () => {\n  const input = [\n    {\n      id    : 0,\n      title : 'foo',\n    },\n    {\n      id    : 1,\n      title : 'bar',\n    },\n    {\n      id    : 2,\n      title : 'baz',\n    },\n    {\n      id    : 3,\n      title : 'foo',\n    },\n    {\n      id    : 4,\n      title : 'bar',\n    },\n  ]\n\n  const expectedResult = [\n    {\n      id    : 0,\n      title : 'foo',\n    },\n    {\n      id    : 1,\n      title : 'bar',\n    },\n    {\n      id    : 2,\n      title : 'baz',\n    },\n  ]\n\n  const fn = (x, y) => x.title === y.title\n\n  const result = uniqWith(fn, input)\n  const curriedResult = uniqWith(fn)(input)\n\n  expect(result).toEqual(expectedResult)\n\n  expect(curriedResult).toEqual(expectedResult)\n})\n\ntest('uniqWith', () => {\n  const input = [\n    {\n      id    : 0,\n      title : 'foo',\n    },\n    {\n      id    : 1,\n      title : 'bar',\n    },\n    {\n      id    : 2,\n      title : 'baz',\n    },\n    {\n      id    : 3,\n      title : 'foo',\n    },\n    {\n      id    : 4,\n      title : 'bar',\n    },\n  ]\n\n  const expectedResult = [\n    {\n      id    : 0,\n      title : 'foo',\n    },\n    {\n      id    : 1,\n      title : 'bar',\n    },\n    {\n      id    : 2,\n      title : 'baz',\n    },\n  ]\n\n  const fn = (x, y) => x.title === y.title\n\n  const result = uniqWith(fn, input)\n  //const result = uniqWith(Ramda.eqBy(Ramda.prop('title')), input)\n\n  expect(result).toEqual(expectedResult)\n})",
    "explanation": "It returns a new array containing only one copy of each element in `list` according to boolean returning function `uniqFn`.",
    "example": "const list = [\n  {id: 0, title:'foo'},\n  {id: 1, title:'bar'},\n  {id: 2, title:'baz'},\n  {id: 3, title:'foo'},\n  {id: 4, title:'bar'},\n]\n\nconst expected = [\n  {id: 0, title:'foo'},\n  {id: 1, title:'bar'},\n  {id: 2, title:'baz'},\n]\n\nconst uniqFn = (x,y) => x.title === y.title\n\nconst result = R.uniqWith(uniqFn, list)\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {uniqWith} from 'rambda'\n\ndescribe('R.uniqWith', () => {\n  it('happy', () => {\n    const input = [\n      {\n        id: 0,\n        title: 'foo',\n      },\n      {\n        id: 1,\n        title: 'bar',\n      },\n      {\n        id: 2,\n        title: 'baz',\n      },\n      {\n        id: 3,\n        title: 'foo',\n      },\n      {\n        id: 4,\n        title: 'bar',\n      },\n    ]\n\n    const fn = (x: any, y: any) => x.title === y.title\n\n    const result = uniqWith(fn, input)\n    result // $ExpectType { id: number; title: string; }[]\n  })\n})"
  },
  "unless": {
    "typing": "\nunless<T, U>(predicate: (x: T) => boolean, whenFalseFn: (x: T) => U, obj: T): U",
    "allTypings": "unless<T, U>(predicate: (x: T) => boolean, whenFalseFn: (x: T) => U, obj: T): U;\nunless<T, U>(predicate: (x: T) => boolean, whenFalseFn: (x: T) => U): (obj: T) => U;",
    "categories": [
      "Logic",
      "Function"
    ],
    "rambdaSource": "export function unless(predicate, whenFalse){\n  if (arguments.length === 1){\n    return _whenFalse => unless(predicate, _whenFalse)\n  }\n\n  return input => {\n    if (predicate(input)) return input\n\n    return whenFalse(input)\n  }\n}",
    "rambdaSpecs": "import { inc } from './inc'\nimport { isNil } from './isNil'\nimport { unless } from './unless'\n\nconst safeInc = unless(isNil, inc)\n\ntest('happy', () => {\n  expect(safeInc(null)).toBeNull()\n  expect(safeInc(1)).toBe(2)\n})\n\ntest('curried', () => {\n  const safeIncCurried = unless(isNil)(inc)\n  expect(safeIncCurried(null)).toBeNull()\n  expect(safeIncCurried(1)).toBe(2)\n})",
    "explanation": "The method returns function that will be called with argument `input`.\n\nIf `predicate(input)` returns `false`, then the end result will be the outcome of `whenFalse(input)`.\n\nIn the other case, the final output will be the `input` itself.",
    "example": "const fn = R.unless(\n  x => x > 2,\n  x => x + 10\n)\n\nconst result = [\n  fn(1),\n  fn(5)\n]\n// => [11, 5]",
    "typescriptDefinitionTest": "import {unless, isNil, inc} from 'rambda'\n\ndescribe('R.unless', () => {\n  it('happy', () => {\n    const safeInc = unless<any, number>(isNil, inc)\n    const result = [safeInc(null), safeInc(1)]\n    result[0] // $ExpectType number\n    result[1] // $ExpectType number\n  })\n\n  it('it needs explicitly declared types', () => {\n    const safeInc = unless(x => x > 5, inc)\n    const result = safeInc(1)\n    result // $ExpectType number\n  })\n})",
    "failedSpecsReasons": "Rambda library doesn't have `R.of`",
    "failedSpecsCount": 4
  },
  "update": {
    "typing": "\nupdate<T>(index: number, newValue: T, list: readonly T[]): T[]",
    "allTypings": "update<T>(index: number, newValue: T, list: readonly T[]): T[];\nupdate<T>(index: number, newValue: T): (list: readonly T[]) => T[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { curry } from './curry'\n\nfunction updateFn(\n  index, newValue, list\n){\n  const arrClone = list.slice()\n\n  return arrClone.fill(\n    newValue, index, index + 1\n  )\n}\n\nexport const update = curry(updateFn)",
    "rambdaSpecs": "import { update } from './update'\n\nconst list = [ 1, 2, 3 ]\n\ntest('happy', () => {\n  const newValue = 8\n  const index = 1\n  const result = update(\n    index, newValue, list\n  )\n  const curriedResult = update(index, newValue)(list)\n  const tripleCurriedResult = update(index)(newValue)(list)\n\n  const expected = [ 1, 8, 3 ]\n  expect(result).toEqual(expected)\n  expect(curriedResult).toEqual(expected)\n  expect(tripleCurriedResult).toEqual(expected)\n})\n\ntest('list has no such index', () => {\n  const newValue = 8\n  const index = 10\n  const result = update(\n    index, newValue, list\n  )\n\n  expect(result).toEqual(list)\n})",
    "explanation": "It returns a copy of `list` with updated element at `index` with `newValue`.",
    "example": "const index = 2\nconst newValue = 88\nconst list = [1, 2, 3, 4, 5]\n\nconst result = R.update(index, newValue, list)\n// => [1, 2, 88, 4, 5]",
    "typescriptDefinitionTest": "import {update} from 'rambda'\n\ndescribe('R.update', () => {\n  it('happy', () => {\n    const result = update(1, 0, [1, 2, 3])\n    result // $ExpectType number[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('update', function() {\n  it('accepts an array-like object', function() {\n    function args() {\n      return arguments;\n    }\n    eq(R.update(2, 4, args(0, 1, 2, 3)), [0, 1, 4, 3]);\n  });\n});",
    "failedSpecsReasons": "Ramda method accepts an array-like object",
    "failedSpecsCount": 1
  },
  "values": {
    "typing": "\nvalues<T extends object, K extends keyof T>(obj: T): T[K][]",
    "allTypings": "values<T extends object, K extends keyof T>(obj: T): T[K][];",
    "categories": [
      "Object"
    ],
    "rambdaSource": "import { type } from './type'\n\nexport function values(obj){\n  if (type(obj) !== 'Object') return []\n\n  return Object.values(obj)\n}",
    "rambdaSpecs": "import { values } from './values'\n\ntest('happy', () => {\n  expect(values({\n    a : 1,\n    b : 2,\n    c : 3,\n  })).toEqual([ 1, 2, 3 ])\n})\n\ntest('with bad input', () => {\n  expect(values(null)).toEqual([])\n  expect(values(undefined)).toEqual([])\n  expect(values(55)).toEqual([])\n  expect(values('foo')).toEqual([])\n  expect(values(true)).toEqual([])\n  expect(values(false)).toEqual([])\n  expect(values(NaN)).toEqual([])\n  expect(values(Infinity)).toEqual([])\n  expect(values([])).toEqual([])\n})",
    "explanation": "With correct input, this is nothing more than `Object.values(obj)`. If `obj` is not an object, then it returns an empty array.",
    "example": "const obj = {a:1, b:2}\n\nR.values(obj)\n// => [1, 2]",
    "typescriptDefinitionTest": "import {values} from 'rambda'\n\ndescribe('R.values', () => {\n  it('happy', () => {\n    const result = values({\n      a: 1,\n      b: 2,\n      c: 3,\n    })\n    result // $ExpectType number[]\n  })\n})"
  },
  "when": {
    "typing": "\nwhen<T, U>(predicate: (x: T) => boolean, whenTrueFn: (a: T) => U, input: T): T | U",
    "allTypings": "when<T, U>(predicate: (x: T) => boolean, whenTrueFn: (a: T) => U, input: T): T | U;\nwhen<T, U>(predicate: (x: T) => boolean, whenTrueFn: (a: T) => U): (input: T) => T | U;\nwhen<T, U>(predicate: (x: T) => boolean): FunctionToolbelt.Curry<(whenTrueFn: (a: T) => U, input: T) => T | U>;",
    "categories": [
      "Logic",
      "Function"
    ],
    "rambdaSource": "import { curry } from './curry'\n\nfunction whenFn(\n  predicate, whenTrueFn, input\n){\n  if (!predicate(input)) return input\n\n  return whenTrueFn(input)\n}\n\nexport const when = curry(whenFn)",
    "rambdaSpecs": "import { add } from './add'\nimport { when } from './when'\n\nconst predicate = x => typeof x === 'number'\n\ntest('happy', () => {\n  const fn = when(predicate, add(11))\n  expect(fn(11)).toBe(22)\n  expect(fn('foo')).toBe('foo')\n})",
    "typescriptDefinitionTest": "import {when} from 'rambda'\n\nconst predicate = (x: number) => x > 2\nconst whenTrueFn = (x: number) => String(x)\n\ndescribe('R.when', () => {\n  it('happy', () => {\n    const result = when(predicate, whenTrueFn, 1)\n    result // $ExpectType string | 1\n  })\n\n  it('curry 1', () => {\n    const fn = when(predicate, whenTrueFn)\n    const result = fn(1)\n    result // $ExpectType string | number\n  })\n\n  it('curry 2 require explicit types', () => {\n    const fn = when<number, string>(predicate)(whenTrueFn)\n    const result = fn(1)\n    result // $ExpectType string | number\n  })\n\n  it('curry 3 require explicit types', () => {\n    const result = when<number, string>(predicate)(whenTrueFn, 1)\n    result // $ExpectType string | number\n  })\n})"
  },
  "where": {
    "typing": "\nwhere<T, U>(conditions: T, input: U): boolean",
    "allTypings": "where<T, U>(conditions: T, input: U): boolean;\nwhere<T>(conditions: T): <U>(input: U) => boolean;\nwhere<ObjFunc2, U>(conditions: ObjFunc2, input: U): boolean;\nwhere<ObjFunc2>(conditions: ObjFunc2): <U>(input: U) => boolean;",
    "categories": [
      "Object",
      "Logic"
    ],
    "rambdaSource": "export function where(conditions, input){\n  if (input === undefined){\n    return _input => where(conditions, _input)\n  }\n  let flag = true\n  for (const prop in conditions){\n    const result = conditions[ prop ](input[ prop ])\n    if (flag && result === false){\n      flag = false\n    }\n  }\n\n  return flag\n}",
    "rambdaSpecs": "import { equals } from './equals'\nimport { where } from './where'\n\ntest('when true', () => {\n  const predicate = where({\n    a : equals('foo'),\n    b : equals('bar'),\n  })\n  expect(predicate({\n    a : 'foo',\n    b : 'bar',\n    x : 11,\n    y : 19,\n  })).toEqual(true)\n})\n\ntest('when false', () => {\n  const predicate = where({\n    a : equals('foo'),\n    b : equals('baz'),\n  })\n  expect(predicate({\n    a : 'foo',\n    b : 'bar',\n    x : 11,\n    y : 19,\n  })).toEqual(false)\n})",
    "explanation": "It returns `true` if all each property in `conditions` returns `true` when applied to corresponding property in `input` object.",
    "example": "const condition = R.where({\n  a : x => typeof x === \"string\",\n  b : x => x === 4\n})\nconst input = {\n  a : \"foo\",\n  b : 4,\n  c : 11,\n}\n\nconst result = condition(input) \n// => true",
    "typescriptDefinitionTest": "import {where, equals} from 'rambda'\n\ndescribe('R.where', () => {\n  it('happy', () => {\n    const input = {\n      a: 'foo',\n      b: 'bar',\n      x: 11,\n      y: 19,\n    }\n    const conditions = {\n      a: equals('foo'),\n      b: equals('bar'),\n    }\n    const result = where(conditions, input)\n    const curriedResult = where(conditions)(input)\n    result // $ExpectType boolean\n    curriedResult // $ExpectType boolean\n  })\n})",
    "failedSpecsReasons": "Ramba method looks inside `prototype` property",
    "failedSpecsCount": 2
  },
  "whereEq": {
    "typing": "\nwhereEq<T, U>(condition: T, input: U): boolean",
    "allTypings": "whereEq<T, U>(condition: T, input: U): boolean;\nwhereEq<T>(condition: T): <U>(input: U) => boolean;",
    "categories": [
      "Object"
    ],
    "rambdaSource": "import { equals } from './equals'\nimport { filter } from './filter'\n\nexport function whereEq(condition, input){\n  if (arguments.length === 1){\n    return _input => whereEq(condition, _input)\n  }\n\n  const result = filter((conditionValue, conditionProp) =>\n    equals(conditionValue, input[ conditionProp ]),\n  condition)\n\n  return Object.keys(result).length === Object.keys(condition).length\n}",
    "rambdaSpecs": "import { whereEq } from './whereEq'\n\ntest('when true', () => {\n  const condition = { a : 1 }\n  const input = {\n    a : 1,\n    b : 2,\n  }\n\n  const result = whereEq(condition, input)\n  const expectedResult = true\n\n  expect(result).toEqual(expectedResult)\n})\n\ntest('when false', () => {\n  const condition = { a : 1 }\n  const input = { b : 2 }\n\n  const result = whereEq(condition, input)\n  const expectedResult = false\n\n  expect(result).toEqual(expectedResult)\n})\n\ntest('with nested object', () => {\n  const condition = { a : { b : 1 } }\n  const input = {\n    a : { b : 1 },\n    c : 2,\n  }\n\n  const result = whereEq(condition)(input)\n  const expectedResult = true\n\n  expect(result).toEqual(expectedResult)\n})\n\ntest('with wrong input', () => {\n  const condition = { a : { b : 1 } }\n\n  expect(() => whereEq(condition, null)).toThrowWithMessage(TypeError,\n    'Cannot read property \\'a\\' of null')\n})",
    "explanation": "It will return `true` if all of `input` object fully or partially include `rule` object.",
    "example": "const condition = { a : { b : 1 } }\nconst input = {\n  a : { b : 1 },\n  c : 2\n}\n\nconst result = whereEq(condition, input)\n//=> true",
    "typescriptDefinitionTest": "import {whereEq} from 'rambda'\n\ndescribe('R.whereEq', () => {\n  it('happy', () => {\n    const result = whereEq({a: {b: 2}}, {b: 2})\n    const curriedResult = whereEq({a: {b: 2}})({b: 2})\n    result // $ExpectType boolean\n    curriedResult // $ExpectType boolean\n  })\n})",
    "failedSpecsReasons": "Ramba method looks inside `prototype` property | Rambda.equals doesn't support equality of functions",
    "failedSpecsCount": 2
  },
  "without": {
    "typing": "\nwithout<T>(matchAgainst: readonly T[], source: readonly T[]): T[]",
    "allTypings": "without<T>(matchAgainst: readonly T[], source: readonly T[]): T[];\nwithout<T>(matchAgainst: readonly T[]): (source: readonly T[]) => T[];",
    "categories": [
      "List"
    ],
    "notes": "`R.equals` is used to determine equality",
    "rambdaSource": "import { includes } from './includes'\nimport { reduce } from './reduce'\n\nexport function without(matchAgainst, source){\n  if (source === undefined){\n    return _source => without(matchAgainst, _source)\n  }\n\n  return reduce(\n    (prev, current) =>\n      includes(current, matchAgainst) ? prev : prev.concat(current),\n    [],\n    source\n  )\n}",
    "rambdaSpecs": "import { without } from './without'\n\ntest('should return a new list without values in the first argument ', () => {\n  const itemsToOmit = [ 'A', 'B', 'C' ]\n  const collection = [ 'A', 'B', 'C', 'D', 'E', 'F' ]\n\n  expect(without(itemsToOmit, collection)).toEqual([ 'D', 'E', 'F' ])\n  expect(without(itemsToOmit)(collection)).toEqual([ 'D', 'E', 'F' ])\n})\n\ntest('ramda test', () => {\n  expect(without([ 1, 2 ])([ 1, 2, 1, 3, 4 ])).toEqual([ 3, 4 ])\n})",
    "explanation": "It will return a new array, based on all members of `source` list that are not part of `matchAgainst` list.",
    "example": "const source = [1, 2, 3, 4]\nconst matchAgainst = [2, 3]\n\nconst result = R.without(matchAgainst, source)\n// => [1, 4]",
    "typescriptDefinitionTest": "import {without} from 'rambda'\n\nconst itemsToOmit = ['A', 'B', 'C']\nconst collection = ['A', 'B', 'C', 'D', 'E', 'F']\n\ndescribe('R.without', () => {\n  it('happy', () => {\n    const result = without(itemsToOmit, collection)\n\n    result // $ExpectType string[]\n  })\n  it('curried', () => {\n    const result = without(itemsToOmit)(collection)\n\n    result // $ExpectType string[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('without', function() {\n  it('can act as a transducer', function() {\n    eq(R.into([], R.without([1]), [1]), []);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.without([0], [-0]).length, 1);\n    eq(R.without([-0], [0]).length, 1);\n    eq(R.without([NaN], [NaN]).length, 0);\n    eq(R.without([[1]], [[1]]).length, 0);\n    eq(R.without([new Just([42])], [new Just([42])]).length, 0);\n  });\n});",
    "failedSpecsReasons": "Ramda method act as a transducer | Ramda method pass to `equals` method",
    "failedSpecsCount": 2
  },
  "xor": {
    "typing": "\nxor(x: boolean, y: boolean): boolean",
    "allTypings": "xor(x: boolean, y: boolean): boolean;\nxor(y: boolean): (y: boolean) => boolean;",
    "categories": [
      "Logic"
    ],
    "rambdaSource": "export function xor(a, b){\n  if (arguments.length === 1) return _b => xor(a, _b)\n\n  return Boolean(a) && !b || Boolean(b) && !a\n}",
    "rambdaSpecs": "import { xor } from './xor'\n\ntest('compares two values with exclusive or', () => {\n  expect(xor(true, true)).toEqual(false)\n  expect(xor(true, false)).toEqual(true)\n  expect(xor(false, true)).toEqual(true)\n  expect(xor(false, false)).toEqual(false)\n})\n\ntest('when both values are truthy, it should return false', () => {\n  expect(xor(true, 'foo')).toEqual(false)\n  expect(xor(42, true)).toEqual(false)\n  expect(xor('foo', 42)).toEqual(false)\n  expect(xor({}, true)).toEqual(false)\n  expect(xor(true, [])).toEqual(false)\n  expect(xor([], {})).toEqual(false)\n  expect(xor(new Date(), true)).toEqual(false)\n  expect(xor(true, Infinity)).toEqual(false)\n  expect(xor(Infinity, new Date())).toEqual(false)\n})\n\ntest('when both values are falsy, it should return false', () => {\n  expect(xor(null, false)).toEqual(false)\n  expect(xor(false, undefined)).toEqual(false)\n  expect(xor(undefined, null)).toEqual(false)\n  expect(xor(0, false)).toEqual(false)\n  expect(xor(false, NaN)).toEqual(false)\n  expect(xor(NaN, 0)).toEqual(false)\n  expect(xor('', false)).toEqual(false)\n})\n\ntest('when one argument is truthy and the other is falsy, it should return true', () => {\n  expect(xor('foo', null)).toEqual(true)\n  expect(xor(null, 'foo')).toEqual(true)\n  expect(xor(undefined, 42)).toEqual(true)\n  expect(xor(42, undefined)).toEqual(true)\n  expect(xor(Infinity, NaN)).toEqual(true)\n  expect(xor(NaN, Infinity)).toEqual(true)\n  expect(xor({}, '')).toEqual(true)\n  expect(xor('', {})).toEqual(true)\n  expect(xor(new Date(), 0)).toEqual(true)\n  expect(xor(0, new Date())).toEqual(true)\n  expect(xor([], null)).toEqual(true)\n  expect(xor(undefined, [])).toEqual(true)\n})",
    "example": "const result = [\n  xor(true, true),\n  xor(false, false),\n  xor(false, true),\n]\n// => [false, false, true]",
    "typescriptDefinitionTest": "import {xor} from 'rambda'\n\ndescribe('R.xor', () => {\n  it('happy', () => {\n    xor(true, false) // $ExpectType boolean\n  })\n  it('curry', () => {\n    xor(true)(false) // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('xor', function() {\n  it('returns a curried function', function() {\n    eq(R.xor()(true)(true), false);\n    eq(R.xor()(true)(false), true);\n    eq(R.xor()(false)(true), true);\n    eq(R.xor()(false)(false), false);\n  });\n});",
    "failedSpecsReasons": "Ramda method support empty call of method",
    "failedSpecsCount": 1
  },
  "zip": {
    "typing": "\nzip<K, V>(x: readonly K[], y: readonly V[]): KeyValuePair<K, V>[]",
    "allTypings": "zip<K, V>(x: readonly K[], y: readonly V[]): KeyValuePair<K, V>[];\nzip<K>(x: readonly K[]): <V>(y: readonly V[]) => KeyValuePair<K, V>[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function zip(left, right){\n  if (arguments.length === 1) return _right => zip(left, _right)\n\n  const result = []\n  const length = Math.min(left.length, right.length)\n\n  for (let i = 0; i < length; i++){\n    result[ i ] = [ left[ i ], right[ i ] ]\n  }\n\n  return result\n}",
    "rambdaSpecs": "import { zip } from './zip'\n\nconst array1 = [ 1, 2, 3 ]\nconst array2 = [ 'A', 'B', 'C' ]\n\ntest('should return an array', () => {\n  const actual = zip(array1)(array2)\n  expect(actual).toBeInstanceOf(Array)\n})\n\ntest('should return and array or tuples', () => {\n  const expected = [\n    [ 1, 'A' ],\n    [ 2, 'B' ],\n    [ 3, 'C' ],\n  ]\n  const actual = zip(array1, array2)\n  expect(actual).toEqual(expected)\n})\n\ntest('should truncate result to length of shorted input list', () => {\n  const expectedA = [\n    [ 1, 'A' ],\n    [ 2, 'B' ],\n  ]\n  const actualA = zip([ 1, 2 ], array2)\n  expect(actualA).toEqual(expectedA)\n\n  const expectedB = [\n    [ 1, 'A' ],\n    [ 2, 'B' ],\n  ]\n  const actualB = zip(array1, [ 'A', 'B' ])\n  expect(actualB).toEqual(expectedB)\n})",
    "explanation": "It will return a new array containing tuples of equally positions items from both `x` and `y` lists. \n\nThe returned list will be truncated to match the length of the shortest supplied list.",
    "example": "const x = [1, 2]\nconst y = ['A', 'B']\nR.zip(x, y)\n// => [[1, 'A'], [2, 'B']]\n\n// truncates to shortest list\nR.zip([...x, 3], ['A', 'B'])\n// => [[1, 'A'], [2, 'B']]",
    "typescriptDefinitionTest": "import {zip} from 'rambda'\n\ndescribe('R.zip', () => {\n  it('happy', () => {\n    const array1 = [1, 2, 3]\n    const array2 = ['A', 'B', 'C']\n\n    const result = zip(array1)(array2)\n    result // $ExpectType KeyValuePair<number, string>[]\n  })\n})"
  },
  "zipObj": {
    "typing": "\nzipObj<T, K extends string>(keys: readonly K[], values: readonly T[]): { [P in K]: T }",
    "allTypings": "zipObj<T, K extends string>(keys: readonly K[], values: readonly T[]): { [P in K]: T };\nzipObj<K extends string>(keys: readonly K[]): <T>(values: readonly T[]) => { [P in K]: T };\nzipObj<T, K extends number>(keys: readonly K[], values: readonly T[]): { [P in K]: T };\nzipObj<K extends number>(keys: readonly K[]): <T>(values: readonly T[]) => { [P in K]: T };",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { take } from './take'\n\nexport function zipObj(keys, values){\n  if (arguments.length === 1) return yHolder => zipObj(keys, yHolder)\n\n  return take(values.length, keys).reduce((\n    prev, xInstance, i\n  ) => {\n    prev[ xInstance ] = values[ i ]\n\n    return prev\n  }, {})\n}",
    "rambdaSpecs": "import { equals } from './equals'\nimport { zipObj } from './zipObj'\n\ntest('zipObj', () => {\n  expect(zipObj([ 'a', 'b', 'c' ], [ 1, 2, 3 ])).toEqual({\n    a : 1,\n    b : 2,\n    c : 3,\n  })\n})\n\ntest('0', () => {\n  expect(zipObj([ 'a', 'b' ])([ 1, 2, 3 ])).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('1', () => {\n  expect(zipObj([ 'a', 'b', 'c' ])([ 1, 2 ])).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('ignore extra keys', () => {\n  const result = zipObj([ 'a', 'b', 'c', 'd', 'e', 'f' ], [ 1, 2, 3 ])\n  const expected = {\n    a : 1,\n    b : 2,\n    c : 3,\n  }\n\n  expect(equals(result, expected)).toBeTrue()\n})",
    "explanation": "It will return a new object with keys of `keys` array and values of `values` array.",
    "example": "const keys = ['a', 'b', 'c']\n\nR.zipObj(keys, [1, 2, 3])\n//=> {a: 1, b: 2, c: 3}\n\n// truncates to shortest list\nR.zipObj(keys, [1, 2])\n//=> {a: 1, b: 2}",
    "typescriptDefinitionTest": "import {zipObj} from 'rambda'\n\ndescribe('R.zipObj', () => {\n  it('happy', () => {\n    // this is wrong since `@types/ramda` changes are imported 24.10.2020\n    const result = zipObj(['a', 'b', 'c', 'd'], [1, 2, 3])\n    result // $ExpectType { b: number; a: number; c: number; d: number; }\n  })\n  it('imported from @types/ramda', () => {\n    const result = zipObj(['a', 'b', 'c'], [1, 2, 3]);\n    const curriedResult = zipObj(['a', 'b', 'c'])([1, 2, 3]);\n    result // $ExpectType { b: number; a: number; c: number; }\n    curriedResult // $ExpectType { b: number; a: number; c: number; }\n  })\n})"
  },
  "props": {
    "typing": "\nprops<P extends string, T>(propsToPick: P[], obj: Record<P, T>): T[]",
    "allTypings": "props<P extends string, T>(propsToPick: P[], obj: Record<P, T>): T[];\nprops<P extends string>(propsToPick: P[]): <T>(obj: Record<P, T>) => T[];\nprops<P extends string, T>(propsToPick: P[]): (obj: Record<P, T>) => T[];",
    "categories": [
      "Object"
    ],
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\nimport { mapArray } from './map'\n\nexport function props(propsToPick, obj){\n  if (arguments.length === 1){\n    return _obj => props(propsToPick, _obj)\n  }\n  if (!_isArray(propsToPick)){\n    throw new Error('propsToPick is not a list')\n  }\n\n  return mapArray(prop => obj[ prop ], propsToPick)\n}",
    "rambdaSpecs": "import { props } from './props'\n\nconst obj = {\n  a : 1,\n  b : 2,\n}\nconst propsToPick = [ 'a', 'c' ]\n\ntest('happy', () => {\n  const result = props(propsToPick, obj)\n  expect(result).toEqual([ 1, undefined ])\n})\n\ntest('curried', () => {\n  const result = props(propsToPick)(obj)\n  expect(result).toEqual([ 1, undefined ])\n})",
    "explanation": "It takes list with properties `propsToPick` and returns a list with property values in `obj`.",
    "example": "const result = [\n  R.props(['a', 'b'], {a:1, c:3})\n// => [1, undefined]",
    "typescriptDefinitionTest": "import {props} from 'rambda'\n\nconst obj = {a: 1, b: 2}\n\ndescribe('R.props', () => {\n  it('happy', () => {\n    const result = props(['a', 'b'], obj)\n\n    result // $ExpectType number[]\n  })\n  it('curried', () => {\n    const result = props(['a', 'b'])(obj)\n\n    result // $ExpectType number[]\n  })\n})"
  },
  "zipWith": {
    "typing": "\nzipWith<T, U, TResult>(fn: (x: T, y: U) => TResult, list1: readonly T[], list2: readonly U[]): TResult[]",
    "allTypings": "zipWith<T, U, TResult>(fn: (x: T, y: U) => TResult, list1: readonly T[], list2: readonly U[]): TResult[];\nzipWith<T, U, TResult>(fn: (x: T, y: U) => TResult, list1: readonly T[]): (list2: readonly U[]) => TResult[];\nzipWith<T, U, TResult>(fn: (x: T, y: U) => TResult): (list1: readonly T[], list2: readonly U[]) => TResult[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { curry } from './curry'\nimport { take } from './take'\n\nfunction zipWithFn(\n  fn, x, y\n){\n  return take(x.length > y.length ? y.length : x.length,\n    x).map((xInstance, i) => fn(xInstance, y[ i ]))\n}\n\nexport const zipWith = curry(zipWithFn)",
    "rambdaSpecs": "import { add } from './add'\nimport { zipWith } from './zipWith'\n\nconst list1 = [ 1, 2, 3 ]\nconst list2 = [ 10, 20, 30, 40 ]\nconst list3 = [ 100, 200 ]\n\ntest('when second list is shorter', () => {\n  const result = zipWith(\n    add, list1, list3\n  )\n  expect(result).toEqual([ 101, 202 ])\n})\n\ntest('when second list is longer', () => {\n  const result = zipWith(\n    add, list1, list2\n  )\n  expect(result).toEqual([ 11, 22, 33 ])\n})",
    "example": "const list1 = [ 10, 20, 30, 40 ]\nconst list2 = [ 100, 200 ]\n\nconst result = R.zipWith(\n  R.add, list1, list2\n)\n// => [110, 220]",
    "typescriptDefinitionTest": "import {zipWith} from 'rambda'\n\nconst list1 = [1, 2]\nconst list2 = [10, 20, 30]\n\ndescribe('R.zipWith', () => {\n  it('happy', () => {\n    const result = zipWith(\n      (x, y) => {\n        x // $ExpectType number\n        y // $ExpectType number\n        return `${x}-${y}`\n      },\n      list1,\n      list2\n    )\n\n    result // $ExpectType string[]\n  })\n  it('curried', () => {\n    const result = zipWith((x, y) => {\n      x // $ExpectType unknown\n      y // $ExpectType unknown\n      return `${x}-${y}`\n    })(list1, list2)\n\n    result // $ExpectType string[]\n  })\n})"
  },
  "splitAt": {
    "typing": "\nsplitAt<T>(index: number, input: T[]): [T[], T[]]",
    "allTypings": "splitAt<T>(index: number, input: T[]): [T[], T[]];\nsplitAt(index: number, input: string): [string, string];\nsplitAt(index: number): {\n    <T>(input: T[]): [T[], T[]];\n    (input: string): [string, string];\n};",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\nimport { drop } from './drop'\nimport { maybe } from './maybe'\nimport { take } from './take'\n\nexport function splitAt(index, input){\n  if (arguments.length === 1){\n    return _list => splitAt(index, _list)\n  }\n  if (!input) throw new TypeError(`Cannot read property 'slice' of ${ input }`)\n\n  if (!_isArray(input) && typeof input !== 'string') return [ [], [] ]\n  \n  const correctIndex = maybe(\n    index < 0,\n    input.length + index < 0 ? 0 : input.length + index,\n    index\n  )\n\n  return [ take(correctIndex, input), drop(correctIndex, input) ]\n}",
    "rambdaSpecs": "import { splitAt as splitAtRamda } from 'ramda'\n\nimport { splitAt } from './splitAt'\n\nconst list = [ 1, 2, 3 ]\nconst str = 'foo bar'\n\ntest('with array', () => {\n  const result = splitAt(2, list)\n  expect(result).toEqual([ [ 1, 2 ], [ 3 ] ])\n})\n\ntest('with array - index is negative number', () => {\n  const result = splitAt(-6, list)\n  expect(result).toEqual([ [], list ])\n})\n\ntest('with array - index is out of scope', () => {\n  const result = splitAt(4, list)\n  expect(result).toEqual([ [ 1, 2, 3 ], [] ])\n})\n\ntest('with string', () => {\n  const result = splitAt(4, str)\n  expect(result).toEqual([ 'foo ', 'bar' ])\n})\n\ntest('with string - index is negative number', () => {\n  const result = splitAt(-2, str)\n  expect(result).toEqual([ 'foo b', 'ar' ])\n})\n\ntest('with string - index is out of scope', () => {\n  const result = splitAt(10, str)\n  expect(result).toEqual([ str, '' ])\n})\n\ntest('with array - index is out of scope', () => {\n  const result = splitAt(4)(list)\n  expect(result).toEqual([ [ 1, 2, 3 ], [] ])\n})\n\nconst badInputs = [ 1, true, /foo/g, {} ]\nconst throwingBadInputs = [ null, undefined ]\n\ntest('with bad inputs', () => {\n  throwingBadInputs.forEach(badInput => {\n    expect(() => splitAt(1, badInput)).toThrowWithMessage(TypeError,\n      `Cannot read property 'slice' of ${ badInput }`)\n    expect(() => splitAtRamda(1, badInput)).toThrowWithMessage(TypeError,\n      `Cannot read property 'slice' of ${ badInput }`)\n  })\n\n  badInputs.forEach(badInput => {\n    const result = splitAt(1, badInput)\n    const ramdaResult = splitAtRamda(1, badInput)\n    expect(result).toEqual(ramdaResult)\n  })\n})",
    "explanation": "It splits string or array at a given index.",
    "example": "const list = [ 1, 2, 3 ]\nconst result = splitAt(2, list)\n// => [[ 1, 2 ], [ 3 ]]",
    "typescriptDefinitionTest": "import {splitAt} from 'ramda'\n\nconst index = 1\nconst str = 'foo'\nconst list = [1, 2, 3]\n\ndescribe('R.splitAt with array', () => {\n  it('happy', () => {\n    const result = splitAt(index, list)\n\n    result // $ExpectType [number[], number[]]\n  })\n  it('curried', () => {\n    const result = splitAt(index)(list)\n\n    result // $ExpectType [number[], number[]]\n  })\n})\n\ndescribe('R.splitAt with string', () => {\n  it('happy', () => {\n    const result = splitAt(index, str)\n\n    result // $ExpectType [string, string]\n  })\n  it('curried', () => {\n    const result = splitAt(index)(str)\n\n    result // $ExpectType [string, string]\n  })\n})"
  },
  "splitWhen": {
    "typing": "\nsplitWhen<T, U>(predicate: Predicate<T>, list: U[]): U[][]",
    "allTypings": "splitWhen<T, U>(predicate: Predicate<T>, list: U[]): U[][];\nsplitWhen<T>(predicate: Predicate<T>): <U>(list: U[]) => U[][];",
    "categories": [
      "List"
    ],
    "rambdaSource": "export function splitWhen(predicate, input){\n  if (arguments.length === 1){\n    return _input => splitWhen(predicate, _input)\n  }\n  if (!input)\n    throw new TypeError(`Cannot read property 'length' of ${ input }`)\n\n  const preFound = []\n  const postFound = []\n  let found = false\n  let counter = -1\n\n  while (counter++ < input.length - 1){\n    if (found){\n      postFound.push(input[ counter ])\n    } else if (predicate(input[ counter ])){\n      postFound.push(input[ counter ])\n      found = true\n    } else {\n      preFound.push(input[ counter ])\n    }\n  }\n\n  return [ preFound, postFound ]\n}",
    "rambdaSpecs": "import { splitWhen as splitWhenRamda } from 'ramda'\n\nimport { equals } from './equals'\nimport { splitWhen } from './splitWhen'\n\nconst list = [ 1, 2, 1, 2 ]\n\ntest('happy', () => {\n  const result = splitWhen(equals(2), list)\n  expect(result).toEqual([ [ 1 ], [ 2, 1, 2 ] ])\n})\n\ntest('when predicate returns false', () => {\n  const result = splitWhen(equals(3))(list)\n  expect(result).toEqual([ list, [] ])\n})\n\nconst badInputs = [ 1, true, /foo/g, {} ]\nconst throwingBadInputs = [ null, undefined ]\n\ntest('with bad inputs', () => {\n  throwingBadInputs.forEach(badInput => {\n    expect(() => splitWhen(equals(2), badInput)).toThrowWithMessage(TypeError,\n      `Cannot read property 'length' of ${ badInput }`)\n    expect(() => splitWhenRamda(equals(2), badInput)).toThrowWithMessage(TypeError,\n      `Cannot read property 'length' of ${ badInput }`)\n  })\n\n  badInputs.forEach(badInput => {\n    const result = splitWhen(equals(2), badInput)\n    const ramdaResult = splitWhenRamda(equals(2), badInput)\n    expect(result).toEqual(ramdaResult)\n  })\n})",
    "explanation": "It splits `list` to two arrays according to a `predicate` function. \n\nThe first array contains all members of `list` before `predicate` returns `true`.",
    "example": "const list = [1, 2, 1, 2]\nconst result = R.splitWhen(R.equals(2), list)\n// => [[1], [2, 1, 2]]",
    "typescriptDefinitionTest": "import {splitWhen} from 'rambda'\n\nconst list = [1, 2, 1, 2]\nconst predicate = (x: number) => x === 2\n\ndescribe('R.splitWhen', () => {\n  it('happy', () => {\n    const result = splitWhen(predicate, list)\n\n    result // $ExpectType number[][]\n  })\n  it('curried', () => {\n    const result = splitWhen(predicate)(list)\n\n    result // $ExpectType number[][]\n  })\n})"
  },
  "takeLastWhile": {
    "typing": "\ntakeLastWhile(predicate: (x: string) => boolean, input: string): string",
    "allTypings": "takeLastWhile(predicate: (x: string) => boolean, input: string): string;\ntakeLastWhile(predicate: (x: string) => boolean): (input: string) => string;\ntakeLastWhile<T>(predicate: (x: T) => boolean, input: readonly T[]): T[];\ntakeLastWhile<T>(predicate: (x: T) => boolean): <T>(input: readonly T[]) => T[];",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "import { _isArray } from './_internals/_isArray.js'\n\nexport function takeLastWhile(predicate, input){\n  if (arguments.length === 1){\n    return _input => takeLastWhile(predicate, _input)\n  }\n  if (input.length === 0) return input\n  let found = false\n  const toReturn = []\n  let counter = input.length\n\n  while (!found || counter === 0){\n    counter--\n    if (predicate(input[ counter ]) === false){\n      found = true\n    } else if (!found){\n      toReturn.push(input[ counter ])\n    }\n  }\n\n  return _isArray(input) ? toReturn.reverse() : toReturn.reverse().join('')\n}",
    "rambdaSpecs": "import { takeLastWhile } from './takeLastWhile'\nconst assert = require('assert')\n\nconst list = [ 1, 2, 3, 4 ]\n\ntest('happy', () => {\n  const predicate = x => x > 2\n  const result = takeLastWhile(predicate, list)\n  expect(result).toEqual([ 3, 4 ])\n})\n\ntest('predicate is always true', () => {\n  const predicate = x => x > 0\n  const result = takeLastWhile(predicate)(list)\n  expect(result).toEqual(list)\n})\n\ntest('predicate is always false', () => {\n  const predicate = x => x < 0\n  const result = takeLastWhile(predicate, list)\n  expect(result).toEqual([])\n})\n\ntest('with string', () => {\n  const result = takeLastWhile(x => x !== 'F', 'FOOBAR')\n  expect(result).toEqual('OOBAR')\n})",
    "example": "const result = R.takeLastWhile(\n  x => x > 2,\n  [1, 2, 3, 4]\n)\n// => [3, 4]",
    "typescriptDefinitionTest": "import {takeLastWhile} from 'rambda'\n\nconst list = [1, 2, 3]\nconst str = 'FOO'\n\ndescribe('R.takeLastWhile', () => {\n  it('with array', () => {\n    const result = takeLastWhile(x => x > 1, list)\n\n    result // $ExpectType number[]\n  })\n  it('with array - curried', () => {\n    const result = takeLastWhile(x => x > 1, list)\n\n    result // $ExpectType number[]\n  })\n  it('with string', () => {\n    const result = takeLastWhile(x => x !== 'F', str)\n\n    result // $ExpectType string\n  })\n  it('with string - curried', () => {\n    const result = takeLastWhile(x => x !== 'F')(str)\n\n    result // $ExpectType string\n  })\n})"
  },
  "evolve": {
    "typing": "\nevolve<T, U>(rules: Array<(x: T) => U>, list: T[]): U[]",
    "allTypings": "evolve<T, U>(rules: Array<(x: T) => U>, list: T[]): U[];\nevolve<T, U>(rules: Array<(x: T) => U>) : (list: T[]) => U[];\nevolve<E extends Evolver, V extends Evolvable<E>>(rules: E, obj: V): Evolve<V, E>;\nevolve<E extends Evolver>(rules: E): <V extends Evolvable<E>>(obj: V) => Evolve<V, E>;",
    "categories": [
      "Object",
      "List"
    ],
    "notes": "Error handling of this method differs between Ramda and Rambda. Ramda for some wrong inputs returns result and for other - it returns one of the inputs. Rambda simply throws when inputs are not correct. Full details for this mismatch are listed in `source/_snapshots/evolve.spec.js.snap` file.",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\nimport { mapArray, mapObject } from './map'\nimport { type } from './type'\n\nexport function evolveArray(rules, list){\n  return mapArray(\n    (x, i) => {\n      if (type(rules[ i ]) === 'Function'){\n        return rules[ i ](x)\n      }\n\n      return x\n    },\n    list,\n    true\n  )\n}\n\nexport function evolveObject(rules, iterable){\n  return mapObject((x, prop) => {\n    if (type(x) === 'Object'){\n      const typeRule = type(rules[ prop ])\n      if (typeRule === 'Function'){\n        return rules[ prop ](x)\n      }\n      if (typeRule === 'Object'){\n        return evolve(rules[ prop ], x)\n      }\n\n      return x\n    }\n    if (type(rules[ prop ]) === 'Function'){\n      return rules[ prop ](x)\n    }\n\n    return x\n  }, iterable)\n}\n\nexport function evolve(rules, iterable){\n  if (arguments.length === 1){\n    return _iterable => evolve(rules, _iterable)\n  }\n  const rulesType = type(rules)\n  const iterableType = type(iterable)\n\n  if (iterableType !== rulesType){\n    throw new Error('iterableType !== rulesType')\n  }\n\n  if (![ 'Object', 'Array' ].includes(rulesType)){\n    throw new Error(`'iterable' and 'rules' are from wrong type ${ rulesType }`)\n  }\n\n  if (iterableType === 'Object'){\n    return evolveObject(rules, iterable)\n  }\n\n  return evolveArray(rules, iterable)\n}",
    "rambdaSpecs": "import { evolve as evolveRamda } from \"ramda\";\n\nimport { add } from \"../rambda.js\";\nimport { compareCombinations, compareToRamda } from \"./_internals/testUtils\";\nimport { evolve } from \"./evolve\";\n\ntest(\"happy\", () => {\n  const rules = {\n    foo: add(1),\n    bar: add(-1),\n  };\n  const input = {\n    a: 1,\n    foo: 2,\n    bar: 3,\n  };\n  const result = evolve(rules, input);\n  expect(result).toEqual({\n    a: 1,\n    foo: 3,\n    bar: 2,\n  });\n});\n\ntest(\"is recursive\", () => {\n  const rules = {\n    nested: {\n      second: add(-1),\n      third: add(1),\n    },\n  };\n  const object = {\n    first: 1,\n    nested: {\n      second: 2,\n      third: 3,\n    },\n  };\n  const expected = {\n    first: 1,\n    nested: {\n      second: 1,\n      third: 4,\n    },\n  };\n  const result = evolve(rules, object);\n  expect(result).toEqual(expected);\n});\n\ntest(\"ignores primitive value rulesormations\", () => {\n  const rules = {\n    n: 2,\n    m: \"foo\",\n  };\n  const object = {\n    n: 0,\n    m: 1,\n  };\n  const expected = {\n    n: 0,\n    m: 1,\n  };\n  const result = evolve(rules, object);\n  expect(result).toEqual(expected);\n});\n\ntest(\"with array\", () => {\n  const rules = [add(1), add(-1)];\n  const list = [100, 1400];\n  const expected = [101, 1399];\n  const result = evolve(rules, list);\n  expect(result).toEqual(expected);\n});\n\nconst rulesObject = { a: add(1) };\nconst rulesList = [add(1)];\nconst possibleIterables = [null, undefined, \"\", 42, [], [1], { a: 1 }];\nconst possibleRules = [...possibleIterables, rulesList, rulesObject];\n\ndescribe(\"brute force\", () => {\n  compareCombinations({\n    firstInput: possibleRules,\n    callback: (errorsCounters) => {\n      expect(errorsCounters).toMatchInlineSnapshot(`\n        Object {\n          \"ERRORS_MESSAGE_MISMATCH\": 0,\n          \"ERRORS_TYPE_MISMATCH\": 4,\n          \"RESULTS_MISMATCH\": 0,\n          \"SHOULD_NOT_THROW\": 51,\n          \"SHOULD_THROW\": 0,\n        }\n      `);\n    },\n    secondInput: possibleIterables,\n    fn: evolve,\n    fnRamda: evolveRamda,\n  });\n});",
    "explanation": "It takes object or array of functions as set of rules. These `rules` are applied to the `iterable` input to produce the result.",
    "example": "const rules = {\n  foo : add(1),\n  bar : add(-1),\n}\nconst input = {\n  a   : 1,\n  foo : 2,\n  bar : 3,\n}\nconst result = evolve(rules, input)\nconst expected = {\n  a   : 1,\n  foo : 3,\n  bar : 2,\n})\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {evolve, add} from 'rambda'\n\ndescribe('R.evolve', () => {\n  it('happy', () => {\n    const input = {\n      foo: 2,\n      nested: {\n        a: 1,\n        bar: 3,\n      },\n    }\n    const rules = {\n      foo: add(1),\n      nested: {\n        a: add(-1),\n        bar: add(1),\n      },\n    }\n    const result = evolve(rules, input)\n    const curriedResult = evolve(rules)(input)\n\n    result.nested.a // $ExpectType number\n    curriedResult.nested.a // $ExpectType number\n    result.nested.bar // $ExpectType number\n    result.foo // $ExpectType number\n  })\n  it('with array', () => {\n    const rules = [String, String]\n    const input = [100, 1400]\n    const result = evolve(rules, input)\n    const curriedResult = evolve(rules)(input)\n    result // $ExpectType string[]\n    curriedResult // $ExpectType string[]\n  })\n})",
    "failedSpecsReasons": "Rambda throws if `iterable` input is neither array nor object",
    "failedSpecsCount": 1
  },
  "dropLastWhile": {
    "typing": "\ndropLastWhile(predicate: (x: string) => boolean, iterable: string): string",
    "allTypings": "dropLastWhile(predicate: (x: string) => boolean, iterable: string): string;\ndropLastWhile(predicate: (x: string) => boolean): (iterable: string) => string;\ndropLastWhile<T>(predicate: (x: T) => boolean, iterable: readonly T[]): T[];\ndropLastWhile<T>(predicate: (x: T) => boolean): <T>(iterable: readonly T[]) => T[];",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "import { _isArray } from './_internals/_isArray.js'\n\nexport function dropLastWhile(predicate, iterable){\n  if (arguments.length === 1){\n    return _iterable => dropLastWhile(predicate, _iterable)\n  }\n  if (iterable.length === 0) return iterable\n  const isArray = _isArray(iterable)\n\n  if (typeof predicate !== 'function'){\n    throw new Error(`'predicate' is from wrong type ${ typeof predicate }`)\n  }\n  if (!isArray && typeof iterable !== 'string'){\n    throw new Error(`'iterable' is from wrong type ${ typeof iterable }`)\n  }\n\n  let found = false\n  const toReturn = []\n  let counter = iterable.length\n\n  while (counter > 0){\n    counter--\n    if (!found && predicate(iterable[ counter ]) === false){\n      found = true\n      toReturn.push(iterable[ counter ])\n    } else if (found){\n      toReturn.push(iterable[ counter ])\n    }\n  }\n\n  return isArray ? toReturn.reverse() : toReturn.reverse().join('')\n}",
    "rambdaSpecs": "import { dropLastWhile as dropLastWhileRamda } from \"ramda\";\n\nimport { compareCombinations } from \"./_internals/testUtils\";\nimport { dropLastWhile } from \"./dropLastWhile\";\n\nconst list = [1, 2, 3, 4, 5];\nconst str = \"foobar\";\n\ntest(\"with list\", () => {\n  const result = dropLastWhile((x) => x >= 3, list);\n  expect(result).toEqual([1, 2]);\n});\n\ntest(\"with string\", () => {\n  const result = dropLastWhile((x) => x !== \"b\")(str);\n  expect(result).toBe(\"foob\");\n});\n\ntest(\"with empty list\", () => {\n  expect(dropLastWhile(() => true, [])).toEqual([]);\n  expect(dropLastWhile(() => false, [])).toEqual([]);\n});\n\nconst possiblePredicates = [\n  (x) => x > 2,\n  (x) => x < 2,\n  (x) => x < -2,\n  (x) => x > 10,\n  \"\",\n  [],\n  [1],\n];\n\nconst possibleIterables = [\n  list,\n  [{}, \"1\", 2],\n  str,\n  `${str}${str}`,\n  /foo/g,\n  Promise.resolve(\"foo\"),\n  2,\n];\n\ndescribe(\"brute force\", () => {\n  compareCombinations({\n    fn: dropLastWhile,\n    fnRamda: dropLastWhileRamda,\n    firstInput: possiblePredicates,\n    secondInput: possibleIterables,\n    callback: (errorsCounters) => {\n      expect(errorsCounters).toMatchInlineSnapshot(`\n        Object {\n          \"ERRORS_MESSAGE_MISMATCH\": 0,\n          \"ERRORS_TYPE_MISMATCH\": 12,\n          \"RESULTS_MISMATCH\": 0,\n          \"SHOULD_NOT_THROW\": 21,\n          \"SHOULD_THROW\": 0,\n        }\n      `);\n    },\n  });\n});",
    "example": "const list = [1, 2, 3, 4, 5];\nconst predicate = x => x >= 3\n\nconst result = dropLastWhile(predicate, list);\n// => [1, 2]",
    "typescriptDefinitionTest": "import {dropLastWhile} from 'rambda'\n\nconst list = [1, 2, 3]\nconst str = 'FOO'\n\ndescribe('R.dropLastWhile', () => {\n  it('with array', () => {\n    const result = dropLastWhile(x => x > 1, list)\n\n    result // $ExpectType number[]\n  })\n  it('with array - curried', () => {\n    const result = dropLastWhile(x => x > 1, list)\n\n    result // $ExpectType number[]\n  })\n  it('with string', () => {\n    const result = dropLastWhile(x => x !== 'F', str)\n\n    result // $ExpectType string\n  })\n  it('with string - curried', () => {\n    const result = dropLastWhile(x => x !== 'F')(str)\n\n    result // $ExpectType string\n  })\n})",
    "failedSpecsReasons": "Ramda method can act as a transducer",
    "failedSpecsCount": 1
  },
  "dropRepeats": {
    "typing": "\ndropRepeats<T>(list: readonly T[]): T[]",
    "allTypings": "dropRepeats<T>(list: readonly T[]): T[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\nimport { equals } from './equals'\n\nexport function dropRepeats(list){\n  if (!_isArray(list)){\n    throw new Error(`${ list } is not a list`)\n  }\n\n  const toReturn = []\n\n  list.reduce((prev, current) => {\n    if (!equals(prev, current)){\n      toReturn.push(current)\n    }\n\n    return current\n  }, undefined)\n\n  return toReturn\n}",
    "rambdaSpecs": "import { dropRepeats as dropRepeatsRamda } from \"ramda\";\n\nimport { compareCombinations } from \"./_internals/testUtils\";\nimport { add } from \"./add\";\nimport { dropRepeats } from \"./dropRepeats\";\n\nconst list = [1, 2, 2, 2, 3, 4, 4, 5, 5, 3, 2, 2, { a: 1 }, { a: 1 }];\nconst listClean = [1, 2, 3, 4, 5, 3, 2, { a: 1 }];\n\ntest(\"happy\", () => {\n  const result = dropRepeats(list);\n  expect(result).toEqual(listClean);\n});\n\nconst possibleLists = [\n  [add(1), async () => {}, [1], [1], [2], [2]],\n  [add(1), add(1), add(2)],\n  [],\n  1,\n  /foo/g,\n  Promise.resolve(1),\n];\n\ndescribe(\"brute force\", () => {\n  compareCombinations({\n    firstInput: possibleLists,\n    callback: (errorsCounters) => {\n      expect(errorsCounters).toMatchInlineSnapshot(`\n        Object {\n          \"ERRORS_MESSAGE_MISMATCH\": 0,\n          \"ERRORS_TYPE_MISMATCH\": 0,\n          \"RESULTS_MISMATCH\": 0,\n          \"SHOULD_NOT_THROW\": 3,\n          \"SHOULD_THROW\": 0,\n        }\n      `);\n    },\n    fn: dropRepeats,\n    fnRamda: dropRepeatsRamda,\n  });\n});",
    "explanation": "It removes any successive duplicates according to `R.equals`.",
    "example": "const result = R.dropRepeats([\n  1, \n  1, \n  {a: 1}, \n  {a:1}, \n  1\n])\n// => [1, {a: 1}, 1]",
    "typescriptDefinitionTest": "import {dropRepeats} from 'rambda'\n\ndescribe('R.dropRepeats', () => {\n  it('happy', () => {\n    const result = dropRepeats([1, 2, 2, 3])\n\n    result // $ExpectType number[]\n  })\n})",
    "failedSpecsReasons": "Ramda method can act as a transducer",
    "failedSpecsCount": 1
  },
  "dropRepeatsWith": {
    "typing": "\ndropRepeatsWith<T>(predicate: (x: T, y: T) => boolean, list: readonly T[]): T[]",
    "allTypings": "dropRepeatsWith<T>(predicate: (x: T, y: T) => boolean, list: readonly T[]): T[];\ndropRepeatsWith<T>(predicate: (x: T, y: T) => boolean): (list: readonly T[]) => T[];",
    "categories": [
      "List"
    ],
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nexport function dropRepeatsWith(predicate, list){\n  if (arguments.length === 1){\n    return _iterable => dropRepeatsWith(predicate, _iterable)\n  }\n\n  if (!_isArray(list)){\n    throw new Error(`${ list } is not a list`)\n  }\n\n  const toReturn = []\n\n  list.reduce((prev, current) => {\n    if (prev === undefined){\n      toReturn.push(current)\n\n      return current\n    }\n    if (!predicate(prev, current)){\n      toReturn.push(current)\n    }\n\n    return current\n  }, undefined)\n\n  return toReturn\n}",
    "rambdaSpecs": "import { dropRepeatsWith as dropRepeatsWithRamda, eqProps } from \"ramda\";\n\nimport { compareCombinations } from \"./_internals/testUtils\";\nimport { dropRepeatsWith } from \"./dropRepeatsWith\";\nimport { path } from \"./path\";\n\nconst eqI = eqProps(\"i\");\n\ntest(\"happy\", () => {\n  const list = [{ i: 1 }, { i: 2 }, { i: 2 }, { i: 3 }];\n  const expected = [{ i: 1 }, { i: 2 }, { i: 3 }];\n  const result = dropRepeatsWith(eqI, list);\n  expect(result).toEqual(expected);\n});\n\ntest(\"keeps elements from the left predicate input\", () => {\n  const list = [\n    {\n      i: 1,\n      n: 1,\n    },\n    {\n      i: 1,\n      n: 2,\n    },\n    {\n      i: 1,\n      n: 3,\n    },\n    {\n      i: 4,\n      n: 1,\n    },\n    {\n      i: 4,\n      n: 2,\n    },\n  ];\n  const expected = [\n    {\n      i: 1,\n      n: 1,\n    },\n    {\n      i: 4,\n      n: 1,\n    },\n  ];\n  const result = dropRepeatsWith(eqI, list);\n  expect(result).toEqual(expected);\n});\n\nconst possiblePredicates = [\n  null,\n  undefined,\n  (x) => x + 1,\n  (x) => true,\n  (x) => false,\n  (x) => \"\",\n  path([\"a\", \"b\"]),\n];\nconst possibleLists = [\n  null,\n  undefined,\n  [],\n  [1],\n  [{ a: { b: 1 } }, { a: { b: 1 } }],\n  [/foo/g, /foo/g],\n];\n\ndescribe(\"brute force\", () => {\n  compareCombinations({\n    firstInput: possiblePredicates,\n    secondInput: possibleLists,\n    callback: (errorsCounters) => {\n      expect(errorsCounters).toMatchInlineSnapshot(`\n        Object {\n          \"ERRORS_MESSAGE_MISMATCH\": 4,\n          \"ERRORS_TYPE_MISMATCH\": 14,\n          \"RESULTS_MISMATCH\": 0,\n          \"SHOULD_NOT_THROW\": 0,\n          \"SHOULD_THROW\": 0,\n        }\n      `);\n    },\n    fn: dropRepeatsWith,\n    fnRamda: dropRepeatsWithRamda,\n  });\n});",
    "example": "const list = [{a:1,b:2}, {a:1,b:3}, {a:2, b:4}]\nconst result = R.dropRepeatsWith(R.prop('a'))\n\n// => [{a:1,b:2}, {a:2, b:4}]",
    "typescriptDefinitionTest": "import {dropRepeatsWith} from 'rambda'\n\ninterface Foo {\n  a: number,\n}\n\ndescribe('R.dropRepeatsWith', () => {\n  it('happy', () => {\n    const result = dropRepeatsWith(\n      (x: Foo, y: Foo) => {\n        return x.a > y.a\n      },\n      [{a: 2}, {a: 1}]\n    )\n\n    result // $ExpectType { a: number; }[]\n    result[0].a // $ExpectType number\n  })\n  it('curried', () => {\n    const result = dropRepeatsWith((x: Foo, y: Foo) => {\n      return x.a > y.a\n    })([{a: 2}, {a: 1}])\n\n    result // $ExpectType Foo[]\n  })\n})"
  },
  "dropWhile": {
    "typing": "\ndropWhile(fn: Predicate<string>, iterable: string): string",
    "allTypings": "dropWhile(fn: Predicate<string>, iterable: string): string;\ndropWhile(fn: Predicate<string>): (iterable: string) => string;\ndropWhile<T>(fn: Predicate<T>, iterable: readonly T[]): T[];\ndropWhile<T>(fn: Predicate<T>): (iterable: readonly T[]) => T[];",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "import { _isArray } from '../src/_internals/_isArray'\n\nexport function dropWhile(predicate, iterable){\n  if (arguments.length === 1){\n    return _iterable => dropWhile(predicate, _iterable)\n  }\n  const isArray = _isArray(iterable)\n  if (!isArray && typeof iterable !== 'string'){\n    throw new Error('`iterable` is neither list nor a string')\n  }\n  let flag = false\n  const holder = []\n  let counter = -1\n\n  while (counter++ < iterable.length - 1){\n    if (flag){\n      holder.push(iterable[ counter ])\n    } else if (!predicate(iterable[ counter ])){\n      if (!flag) flag = true\n\n      holder.push(iterable[ counter ])\n    }\n  }\n\n  return isArray ? holder : holder.join('')\n}",
    "rambdaSpecs": "import { dropWhile as dropWhileRamda } from 'ramda'\n\nimport { compareCombinations } from './_internals/testUtils'\nimport { dropWhile } from './dropWhile'\n\nconst list = [ 1, 2, 3, 4 ]\n\ntest('happy', () => {\n  const predicate = x => x < 3\n  const result = dropWhile(predicate, list)\n  expect(result).toEqual([3,4])\n})\n\ntest('always true', () => {\n  const predicate = () => true\n  const result = dropWhileRamda(predicate, list)\n  expect(result).toEqual([])\n})\n\ntest('always false', () => {\n  const predicate = () => 0\n  const result = dropWhile(predicate, list)\n  expect(result).toEqual(list)\n})\n\ntest('works with string as iterable', () => {\n  const iterable = 'foobar'\n  const predicate = x => x !== 'b'\n  const result = dropWhile(predicate, iterable)\n  expect(result).toBe('bar')\n})\n\nconst possiblePredicates = [\n  null,\n  undefined,\n  () => 0,\n  () => true,\n  /foo/g,\n  {},\n  [],\n]\n\nconst possibleIterables = [\n  null,\n  undefined,\n  [],\n  {},\n  1,\n  '',\n  'foobar',\n  [ '' ],\n  [ 1, 2, 3, 4, 5 ],\n]\n\ndescribe('brute force', () => {\n  compareCombinations({\n    firstInput : possiblePredicates,\n    callback   : errorsCounters => {\n      expect(errorsCounters).toMatchInlineSnapshot(`\n        Object {\n          \"ERRORS_MESSAGE_MISMATCH\": 15,\n          \"ERRORS_TYPE_MISMATCH\": 14,\n          \"RESULTS_MISMATCH\": 0,\n          \"SHOULD_NOT_THROW\": 14,\n          \"SHOULD_THROW\": 0,\n        }\n      `)\n    },\n    secondInput : possibleIterables,\n    fn          : dropWhile,\n    fnRamda     : dropWhileRamda,\n  })\n})",
    "example": "const list = [1, 2, 3, 4]\nconst predicate = x => x < 3\nconst result = R.dropWhile(predicate, list)\n// => [3, 4]",
    "typescriptDefinitionTest": "import {dropWhile} from 'rambda'\n\nconst list = [1, 2, 3, 4]\n\ndescribe('R.dropWhile', () => {\n  it('happy', () => {\n    const result = dropWhile(x => x > 2, list)\n\n    result // $ExpectType number[]\n  })\n  it('curried require explicit type', () => {\n    const result = dropWhile<number>(x => x > 2)(list)\n\n    result // $ExpectType number[]\n  })\n})\n\ndescribe('with string as iterable', () => {\n  const str = 'foobar'\n  it('happy', () => {\n    const result = dropWhile(x => x !== 'b', str)\n\n    result // $ExpectType string\n  })\n  it('curried require explicit type', () => {\n    const result = dropWhile(x => x !== 'b')(str)\n\n    result // $ExpectType string\n  })\n})"
  },
  "takeWhile": {
    "typing": "\ntakeWhile(fn: Predicate<string>, iterable: string): string",
    "allTypings": "takeWhile(fn: Predicate<string>, iterable: string): string;\ntakeWhile(fn: Predicate<string>): (iterable: string) => string;\ntakeWhile<T>(fn: Predicate<T>, iterable: readonly T[]): T[];\ntakeWhile<T>(fn: Predicate<T>): (iterable: readonly T[]) => T[];",
    "categories": [
      "List",
      "String"
    ],
    "rambdaSource": "import { _isArray } from '../src/_internals/_isArray'\n\nexport function takeWhile(predicate, iterable){\n  if (arguments.length === 1){\n    return _iterable => takeWhile(predicate, _iterable)\n  }\n  const isArray = _isArray(iterable)\n  if (!isArray && typeof iterable !== 'string'){\n    throw new Error('`iterable` is neither list nor a string')\n  }\n  let flag = true\n  const holder = []\n  let counter = -1\n\n  while (counter++ < iterable.length - 1){\n    if (!predicate(iterable[ counter ])){\n      if (flag) flag = false\n    } else if (flag){\n      holder.push(iterable[ counter ])\n    }\n  }\n  holder\n\n  return isArray ? holder : holder.join('')\n}",
    "rambdaSpecs": "import { takeWhile as takeWhileRamda } from \"ramda\";\n\nimport { takeWhile } from \"./takeWhile\";\nimport { compareCombinations } from \"./_internals/testUtils\";\n\nconst list = [1, 2, 3, 4, 5];\n\ntest(\"happy\", () => {\n  const result = takeWhile((x) => x < 3, list);\n  expect(result).toEqual([1, 2]);\n});\n\ntest(\"always true\", () => {\n  const result = takeWhile((x) => true, list);\n  expect(result).toEqual(list);\n});\n\ntest(\"always false\", () => {\n  const result = takeWhile((x) => 0, list);\n  expect(result).toEqual([]);\n});\n\ntest(\"with string\", () => {\n  const result = takeWhile((x) => x !== \"b\", \"foobar\");\n  console.log(result);\n  expect(result).toBe(\"foo\");\n});\n\nconst possiblePredicates = [\n  null,\n  undefined,\n  () => 0,\n  () => true,\n  (x) => x !== \"b\",\n  /foo/g,\n  {},\n  [],\n];\n\nconst possibleIterables = [\n  null,\n  undefined,\n  [],\n  {},\n  1,\n  \"\",\n  \"foobar\",\n  [\"\"],\n  [1, 2, 3, 4, 5],\n];\n\ndescribe(\"brute force\", () => {\n  compareCombinations({\n    firstInput: possiblePredicates,\n    callback: (errorsCounters) => {\n      expect(errorsCounters).toMatchInlineSnapshot(`\n        Object {\n          \"ERRORS_MESSAGE_MISMATCH\": 15,\n          \"ERRORS_TYPE_MISMATCH\": 16,\n          \"RESULTS_MISMATCH\": 0,\n          \"SHOULD_NOT_THROW\": 16,\n          \"SHOULD_THROW\": 0,\n        }\n      `);\n    },\n    secondInput: possibleIterables,\n    fn: takeWhile,\n    fnRamda: takeWhileRamda,\n  });\n});",
    "example": "const list = [1, 2, 3, 4]\nconst predicate = x => x < 3\n\nconst result = R.takeWhile(predicate, list)\n// => [1, 2]",
    "typescriptDefinitionTest": "import {takeWhile} from 'rambda'\n\nconst list = [1, 2, 3, 4]\n\ndescribe('R.takeWhile', () => {\n  it('happy', () => {\n    const result = takeWhile(x => x > 2, list)\n\n    result // $ExpectType number[]\n  })\n  it('curried require explicit type', () => {\n    const result = takeWhile<number>(x => x > 2)(list)\n\n    result // $ExpectType number[]\n  })\n})\n\ndescribe('with string as iterable', () => {\n  const str = 'foobar'\n  it('happy', () => {\n    const result = takeWhile(x => x !== 'b', str)\n\n    result // $ExpectType string\n  })\n  it('curried require explicit type', () => {\n    const result = takeWhile(x => x !== 'b')(str)\n\n    result // $ExpectType string\n  })\n})",
    "failedSpecsReasons": "Ramda method works with strings not only arrays",
    "failedSpecsCount": 2
  },
  "eqProps": {
    "typing": "\neqProps<T, U>(prop: string, obj1: T, obj2: U): boolean",
    "allTypings": "eqProps<T, U>(prop: string, obj1: T, obj2: U): boolean;\neqProps<P extends string>(prop: P): <T, U>(obj1: Record<P, T>, obj2: Record<P, U>) => boolean;\neqProps<T>(prop: string, obj1: T): <U>(obj2: U) => boolean;",
    "categories": [
      "Object"
    ],
    "rambdaSource": "import { curry } from \"./curry\";\nimport { equals } from \"./equals\";\n\nfunction eqPropsFn(prop, obj1, obj2) {\n  if(!obj1 || !obj2){\n    throw new Error('wrong object inputs are passed to R.eqProps')\n  }\n\n  return equals(obj1[prop], obj2[prop])\n}\n\nexport const eqProps = curry(eqPropsFn)",
    "rambdaSpecs": "import { eqProps as eqPropsRamda } from 'ramda'\n\nimport { compareCombinations } from './_internals/testUtils'\nimport { eqProps } from './eqProps'\n\nconst obj1 = {\n  a : 1,\n  b : 2,\n}\nconst obj2 = {\n  a : 1,\n  b : 3,\n}\n\ntest('props are equal', () => {\n  const result = eqProps(\n    'a', obj1, obj2\n  )\n  expect(result).toBeTrue()\n})\n\ntest('props are not equal', () => {\n  const result = eqProps(\n    'b', obj1, obj2\n  )\n  expect(result).toBeFalse()\n})\n\ntest('prop does not exist ', () => {\n  const result = eqProps(\n    'c', obj1, obj2\n  )\n  expect(result).toBeTrue()\n})\n\nconst possibleProps = [ 'a', 'a.b', null, false, 0, 1, {}, [] ]\n\nconst possibleObjects = [\n  { a : 1 },\n  {\n    a : 1,\n    b : 2,\n  },\n  {},\n  [],\n  null,\n  {\n    a : { b : 1 },\n    c : 2,\n  },\n  {\n    a : { b : 1 },\n    c : 3,\n  },\n  { a : { b : 2 } },\n]\n\ndescribe('brute force', () => {\n  let totalTestsCounter = 0\n\n  compareCombinations({\n    firstInput : possibleProps,\n    setCounter : () => totalTestsCounter++,\n    callback   : errorsCounters => {\n      // console.log({ totalTestsCounter })\n\n      expect(errorsCounters).toMatchInlineSnapshot(`\n        Object {\n          \"ERRORS_MESSAGE_MISMATCH\": 0,\n          \"ERRORS_TYPE_MISMATCH\": 120,\n          \"RESULTS_MISMATCH\": 0,\n          \"SHOULD_NOT_THROW\": 0,\n          \"SHOULD_THROW\": 0,\n        }\n      `)\n    },\n    secondInput : possibleObjects,\n    thirdInput  : possibleObjects,\n    fn          : eqProps,\n    fnRamda     : eqPropsRamda,\n  })\n})",
    "explanation": "It returns `true` if property `prop` in `obj1` is equal to property `prop` in `obj2` according to `R.equals`.",
    "example": "const obj1 = {a: 1, b:2}\nconst obj2 = {a: 1, b:3}\nconst result = R.eqProps('a', obj1, obj2)\n// => true",
    "typescriptDefinitionTest": "import {eqProps} from 'rambda'\n\nconst obj1 = {a: {b: 1}, c: 2}\nconst obj2 = {a: {b: 1}, c: 3}\n\ndescribe('R.eqProps', () => {\n  it('happy', () => {\n    const result = eqProps('a', obj1, obj2)\n\n    result // $ExpectType boolean\n  })\n  it('curried', () => {\n    const result = eqProps('a', obj1)(obj2)\n\n    result // $ExpectType boolean\n  })\n})"
  }
}
